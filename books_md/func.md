Введение в функциональное программирование John Harrison jrh@cl.cam.ac.uk
3rd December 1997
Оригинальный курс: http://www.cl.cam.ac.uk/Teaching/Lectures/funprog-jrh-1996/
Сайт проекта перевода: https://funprog-ru.github.io/

## Предисловие

Это пособие представляет собой конспект лекций по курсу Введение в функциональное программирование, который преподавался мной в университете Кембриджа в 1996/7 учебном году.

Структура курса, в основе которой лежит чередование теории с практикой, сохранилась с прошлых лет в том виде, в котором она была предложена моим предшественником Майком Гордоном. Его лекционные материалы [27, часть II] послужили важным источником заимствований. Существенное влияние также оказали авторы смежных курсов: Энди Гордон, Ларри Полсон, Энди Питтс (теория типов).

Отдельная глава полностью посвящена реализации нескольких примеров. В силу своего объёма, она не рассматривается на экзамене и предназначена для самостоятельного изучения. Её цель - закрепление пройденного материала и демонстрация возможностей ML на практике.

Большинство глав включает упражнения, либо созданные специально для данного курса, либо взятые из других источников. Их решение, как правило, не сводится к выработке шаблонных навыков, а требует некоторых размышлений. Задачи, которые мне представляются достаточно сложными, отмечены знаком (*).

Эти материалы не подвергались интенсивному тестированию и, без сомнения, содержат различные ошибки и неясности. Я буду благодарен каждому читателю, который сможет уделить некоторое время их конструктивной критике.

John Harrison (jrh@cl.cam.ac.uk).

## План Лекций

В этом разделе приведено распределение материала по 12 лекциям курса, каждая из которых длится немногим менее часа.

1. **Введение и обзор** Императивное и функциональное программирование: различия, «за» и «против». Общая структура курса: как λ-исчисление превратилось в язык программирования общего назначения. Вклад λ-нотации в уточнение понятия связывания переменных и её ценность как средства общего анализа математической нотации. Каррирование. Парадокс Рассела.
2. λ**-исчисление как формальная система** Свободные и связанные переменные. Подстановка. Правила преобразования. Эквивалентность λ-термов. Экстенсиональность. Редукция и её стратегии. Теорема Чёрча-Россера: формулировка и следствия. Комбинаторы.
3. λ**-исчисление как язык программирования** Становление теории алгоритмов; полнота по Тьюрингу (без доказательства). Представление данных и основные операции: логические значения, пары и кортежи, натуральные числа. Вычисление предшествующего числа. Определение рекурсивных функций: комбинаторы неподвижной точки. Let-выражения. λ-исчисление как декларативный язык.
4. **Типы** Зачем нужны типы? Ответы из программирования и логики. Простое типизированное λ-исчисление. Типизация по Чёрчу и Карри. Let-полиморфизм. Наиболее общие типы и алгоритм Милнера. Сильная нормализация (без доказательства), и её негативное влияние на полноту по Тьюрингу. Добавляем оператор рекурсии.
5. ML ML как типизированное λ-исчисление с энергичным вычислением. Подробности стратегии вычисления. Условное выражение. Семейство языков ML. Практика работы с ML. Создание функций. Связывания и объявления. Рекурсивные и полиморфные функции. Сравнение функций.
6. **Более подробно о ML** Загрузка кода из файлов. Комментарии. Основные типы данных: процедурный, логический, числа и строки. Встроенные операции. Конкретный синтаксис и инфиксные операции. Дополнительные примеры. Рекурсивные типы и сопоставление с образцом. Примеры: списки и рекурсивные функции для работы с ними.
7. **Доказательство корректности программ** Проблема корректности. Тестирование и верификация. Область применимости верификации. Функциональ-
ные программы как математические объекты. Примеры доказательства свойств программ: вычисление степени и НОД, конкатенация и обращение списков.

8. **Эффективный ML** Стандартные комбинаторы. Проход по списку и другие
полезные примеры использования комбинаторов. Хвостовая рекурсия и аккумуляторы; почему хвостовая рекурсия более эффективна. Принудительное вычисление. Минимизация операций cons. Более эффективная реализация обращения данных. Использование as. Императивные возможности: исключения,
ссылки, массивы и последовательность вычислений. Императивность и типы; ограничение значения.
9. **Примеры на ML I: символьное дифференцирование** Символьные вычисления. Представление данных. Приоритет операций. Ассоциативные списки.
Форматированная печать выражений. Установка процедуры печати. Дифференцирование. Упрощение. Проблема «правильного» упрощения.
10. **Примеры на ML II: синтаксический анализ** Понятие грамматики, задача
синтаксического анализа. Устранение неоднозначностей. Метод рекурсивного спуска. Реализация синтаксического анализа на языке ML. Комбинаторы синтаксического анализа, примеры. Лексический анализ. Анализатор термов. Автоматический учёт приоритетов операций. Устранение возвратов. Сравнение с другими методами.
11. **Примеры на ML III: арифметика вещественных чисел** Вещественные
числа и конечные представления. Вещественные числа как программы или функции. Выбор представления вещественных чисел. Целые числа произвольной разрядности. Преобразование целочисленных значений в вещественные. Операции смены знака и вычисления абсолютной величины. Сложение: важность деления с округлением. Умножение и деление на целое число. Умножение: общий случай. Обратные числа и деление. Отношения порядка и равенства. Тестирование. Устранение избыточных вычислений при помощи функций
с памятью.
12. **Примеры на ML IV: Пролог и доказательство теорем** Выражения Пролога. Лексический анализ с учётом регистра. Разбор и печать с поддержкой списков. Унификация. Поиск с возвратом. Примеры. Доказательство теорем в стиле Пролога. Работа с формулами, отрицательная нормальная форма. Базовая система доказательства теорем, использование продолжений. Примеры доказательств: задачи Пеллетье и программа-детектив.

## Оглавление

|               | 1                                                     | Введение   |   1 |
|---------------|-------------------------------------------------------|------------|-----|
| 1.1           | Достоинства функционального программирования          |            |   3 |
| 1.2           | План                                                  |            |   5 |
| 2             | Лямбда-исчисление                                     | 7          |     |
| 2.1           | Преимущества лямбда-нотации                           |            |   8 |
| 2.2           | Парадокс Рассела                                      |            |  11 |
| 2.3           | Лямбда-исчисление как формальная система              |            |  11 |
| 2.3.1         | Лямбда-термы                                          |            |  12 |
| 2.3.2         | Свободные и связанные переменные                      |            |  13 |
| 2.3.3         | Подстановка                                           |            |  14 |
| 2.3.4         | Преобразования                                        |            |  15 |
| 2.3.5         | Эквивалентность лямбда-выражений                      |            |  16 |
| 2.3.6         | Экстенсиональность                                    |            |  17 |
| 2.3.7         | Лямбда-редукция                                       |            |  17 |
| 2.3.8         | Стратегии редукции                                    |            |  18 |
| 2.3.9         | Теорема Чёрча-Россера                                 |            |  19 |
| 2.4           | Комбинаторы                                           |            |  20 |
| 3             | Лямбда-исчисление как язык программирования           | 25         |     |
| 3.1           | Представление данных в лямбда-исчислении              |            |  27 |
| 3.1.1         | Логические значения и условия                         |            |  27 |
| 3.1.2         | Пары и кортежи                                        |            |  28 |
| 3.1.3         | Натуральные числа                                     |            |  30 |
| 3.2           | Рекурсивные функции                                   |            |  32 |
| 3.3           |                                                       |            |     |
| Let           |                                                       |            |     |
| -выражения    |                                                       | 33         |     |
| 3.4           | Достижение уровня полноценного языка программирования |            |  35 |
| 3.5           | Дополнительная литература                             |            |  36 |
| 4             | Типы                                                  | 37         |     |
| 4.1           | Типизированное лямбда-исчисление                      |            |  39 |
| 4.1.1         | Множество допустимых типов                            |            |  39 |
| 4.1.2         | Типизация по Чёрчу и Карри                            |            |  40 |
| 4.1.3         | Формальные правила типизации                          |            |  41 |
| 4.1.4         | Сохранение типа                                       |            |  42 |
| 4.2           | Полиморфизм                                           |            |  43 |
| 4.2.1         | Проблемы                                              |            |     |
| let           |                                                       |            |     |
| -полиморфизма |                                                       | 44         |     |
| 4.2.2         | Наиболее общий тип                                    |            |  45 |
| 4.3   | Сильная нормализация                                |     |   46 |
|-------|-----------------------------------------------------|-----|------|
| 5     | Знакомство с ML                                     | 49  |      |
| 5.1   | Энергичное вычисление                               |     |   49 |
| 5.2   | Результаты энергичного вычисления                   |     |   52 |
| 5.3   | Семейство языков ML                                 |     |   53 |
| 5.4   | Запуск ML                                           |     |   53 |
| 5.5   | Взаимодействие с ML                                 |     |   54 |
| 5.6   | Связывания и объявления                             |     |   55 |
| 5.7   | Полиморфные функции                                 |     |   57 |
| 5.8   | Равенство функций                                   |     |   58 |
| 6     | Более подробно о ML                                 | 61  |      |
| 6.1   | Основные типы данных и операции                     |     |   62 |
| 6.2   | Дальнейшие примеры                                  |     |   65 |
| 6.3   | Определения типов                                   |     |   67 |
| 6.3.1 | Сопоставление с образцом                            |     |   68 |
| 6.3.2 | Рекурсивные типы                                    |     |   71 |
| 6.3.3 | Древовидные структуры                               |     |   73 |
| 6.3.4 | Тонкости рекурсивных типов                          |     |   75 |
| 7     | Доказательство корректности программ                | 79  |      |
| 7.1   | Функциональные программы как математические объекты |     |   81 |
| 7.2   | Вычисление степени                                  |     |   82 |
| 7.3   | Вычисление НОД                                      |     |   83 |
| 7.4   | Конкатенация списков                                |     |   85 |
| 7.5   | Обращение списков                                   |     |   86 |
| 8     | Эффективный ML                                      | 91  |      |
| 8.1   | Полезные комбинаторы                                |     |   91 |
| 8.2   | Создание эффективного кода                          |     |   93 |
| 8.2.1 | Хвостовая рекурсия и аккумуляторы                   |     |   93 |
| 8.2.2 | Минимизация операций cons                           |     |   95 |
| 8.2.3 | Принудительное вычисление                           |     |   98 |
| 8.3   | Императивные возможности                            |     |   99 |
| 8.3.1 | Исключения                                          |     |   99 |
| 8.3.2 | Ссылки и массивы                                    | 100 |      |
| 8.3.3 | Последовательность вычислений                       | 102 |      |
| 8.3.4 | Работа с системой типов                             | 102 |      |
| 9     | Примеры                                             | 107 |      |
| 9.1   | Символьное дифференцирование                        | 107 |      |
| 9.1.1 | Термы первого порядка                               | 107 |      |
| 9.1.2 | Печать                                              | 108 |      |
| 9.1.3 | Дифференцирование                                   | 112 |      |
| 9.1.4 | Упрощение                                           | 113 |      |
| 9.2   | Синтаксический анализ                               | 116 |      |
| 9.2.1 | Метод рекурсивного спуска                           | 117 |      |
| 9.2.2   | Комбинаторы синтаксического анализа    |    118 |
|---------|----------------------------------------|--------|
| 9.2.3   | Лексический анализ                     |    120 |
| 9.2.4   | Анализатор термов                      |    121 |
| 9.2.5   | Автоматический учёт приоритетов        |    123 |
| 9.2.6   | Недостатки метода                      |    124 |
| 9.3     | Точная арифметика вещественных чисел   |    127 |
| 9.3.1   | Выбор представления вещественных чисел |    127 |
| 9.3.2   | Целые числа произвольной разрядности   |    128 |
| 9.3.3   | Основные операции                      |    129 |
| 9.3.4   | Умножение: общий случай                |    133 |
| 9.3.5   | Обратные числа                         |    134 |
| 9.3.6   | Отношения порядка                      |    136 |
| 9.3.7   | Кэширование                            |    137 |
| 9.4     | Пролог и доказательство теорем         |    140 |
| 9.4.1   | Термы Пролога                          |    141 |
| 9.4.2   | Лексический анализ                     |    141 |
| 9.4.3   | Синтаксический анализ                  |    142 |
| 9.4.4   | Унификация                             |    144 |
| 9.4.5   | Поиск с возвратом                      |    146 |
| 9.4.6   | Примеры                                |    147 |
| 9.4.7   | Доказательство теорем                  |    149 |

## Глава 1 Введение

Программы, написанные на традиционных языках программирования, таких как FORTRAN, Algol, C и Modula-3, в своей работе опираются на изменение значений набора переменных, называемого *состоянием*. Если мы пренебрежём операциями ввода-вывода и вероятностью того, что программа будет работать постоянно (например, управляющая система для производства), то мы можем прийти к следующей абстракции. Первоначально состояние имеет некоторое значение σ, представляющее собой входные данные для программы, а после завершения её исполнения - новое значение σ′, представляющее результаты. Выполнение отдельных операторов сводится к изменению ними состояния, которое последовательно проходит через конечное число значений:

## Σ = Σ0 →Σ1 →Σ2 →· · · →Σn = Σ′

Например, в программе сортировки состояние первоначально включает в себя массив значений, а после того, как программа завершается, состояние модифицируется таким образом, что эти значения становятся упорядоченными, в то время как промежуточные состояния представляют собой ход достижения данной цели.

Состояние обычно изменяется с помощью операторов *присваивания*, часто записываемых в виде v = E или v := E, где v - переменная, а E - некоторое выражение.

Последовательность выполнения таких операторов задаётся в тексте программы их размещением друг за другом (при этом часто в качестве разделителя применяется точка с запятой). С помощью составных операторов, таких как if и while, можно выполнять операторы в зависимости от условия или циклически, часто полагаясь на другие свойства текущего состояния. В результате программа превращается в набор инструкций по изменению состояния, и поэтому данный стиль программирования часто называется *императивным* или *процедурным*. Соответственно, традиционные языки программирования, поддерживающие такой стиль, также известны как императивные или процедурные языки.

Функциональное программирование радикально отличается от этой модели. По существу, функциональная программа представляет собой просто выражение, а выполнение программы - процесс его вычисления.1 В общих чертах мы можем понять, как это возможно, используя следующие рассуждения. Предположим, что императивная программа (вся целиком) детерминирована, т.е. выход полностью определяется входом; мы можем сказать, что конечное состояние или тот его фрагмент, который нас интересует, являются функцией начального состояния, например σ′ = f(σ).2 В
функциональном программировании эта точка зрения имеет особое значение: программа - это выражение, которое соответствует математической функции f. Функциональные языки поддерживают создание таких выражений за счет того, что позволяют использовать мощные функциональные конструкции.

Функциональное программирование может противопоставляться императивному как c хорошей, так и с плохой стороны. К недостаткам ФП можно отнести то, что функциональные программы не используют переменные - то есть *не имеют* состояния. Соответственно, они не могут использовать присваивание, поскольку нечему присваивать. Кроме того, идея последовательного выполнения операторов также бессмысленна, поскольку первый оператор не имеет никакого влияния на второй, так как нет никакого состояния, передаваемого между ними. К достоинствам функционального подхода можно отнести то, что функциональные программы могут использовать функции более изящным способом. Функции могут рассматриваться точно так же, как и более простые объекты, такие как целые числа: они могут передаваться в другие функции как аргументы и возвращаться в качестве результатов, а также применяться в вычислениях. Вместо последовательного выполнения операторов и использования циклов, функциональные языки программирования предлагают рекурсивные функции, т.е. функции, определённые в терминах самих себя. Большинство традиционных языков программирования обеспечивают весьма скудные возможности в этих областях. Язык C имеет некоторые ограниченные возможности работы с функциями при помощи указателей, но не позволяет создавать новые функции динамически, а язык FORTRAN вообще не поддерживает рекурсию.

Продемонстрируем разницу между императивным и функциональным программированием на примере функции вычисления факториала. Она может быть записана императивно на языке C как:
int fact ( **int** n)
{ **int** x = 1;
while (n > 0)
{ x = x ∗n ;
n = n −1;
}
return x ;
}
в то время как на языке ML (функциональном языке программирования, который мы обсудим позже) она может быть реализована в виде рекурсивной функции:
let rec fact n =
if n = 0 **then** 1
else n ∗fact (n −1 ) ; ;
Отметим, что такое определение достаточно просто реализовать и на языке C.

Однако, при необходимости более сложной работы с функциями функциональные языки не имеют себе равных.

Глава 1. Введение
1.1. Достоинства функционального программирования

## 1.1 Достоинства Функционального Программирования

На первый взгляд, язык без переменных или возможности последовательного выполнения инструкций кажется совершенно непрактичным. Это впечатление не может быть разрушено с помощью нескольких слов, но мы надеемся, что изучая материал, приведённый далее, читатель получит представление о том, какое разнообразие задач можно решить, программируя в функциональном стиле.

Императивный стиль программирования не является нерушимой догмой. Многие свойства императивных языков развились в процессе абстрагирования от типового компьютерного оборудования, от машинного кода к ассемблерам, затем к макроассемблерам, языку FORTRAN и так далее. Нет оснований утверждать, что такие языки представляют собой наиболее удобный способ взаимодействия человека и машины. В самом деле, последнее слово в развитии компьютерных архитектур еще не сказано, и компьютеры должны служить нашим нуждам, а не наоборот. Вероятно, было бы правильнее не начинать с оборудования и продвигаться вверх, а наоборот, взяв за основу язык программирования, как средство описания алгоритмов, следовать вниз к оборудованию [22]. В действительности, данная тенденция может быть обнаружена и в традиционных языках программирования. Даже FORTRAN позволяет записывать арифметические выражения обычным способом, освобождая программиста от линеаризации последовательности вычисления подвыражений и выделения памяти для хранения промежуточных результатов.

Из этих соображений можно сделать вывод, что идея разработки языков программирования, сильно отличающихся от традиционных, императивных языков, является вполне законной. Однако, для того, чтобы показать, что мы не просто предлагаем изменения ради изменений, нам следует сказать несколько слов о том, почему мы могли бы предпочесть функциональные языки программирования императивным.

Возможно, главной причиной является то, что программы на функциональных языках точнее соответствуют математическим объектам, и их свойства легче доказывать. Для того, чтобы понять смысл программы предельно ясно, мы можем дать ей или отдельным её операторам абстрактную математическую трактовку, в чём и состоит суть *денотационной семантики* (семантика = значение, смысл). В императивных языках это должно делаться скорее побочным способом, из-за неявной зависимости от состояния. Для простых императивных языков можно связать оператор с функцией Σ →Σ, где Σ - множество допустимых состояний. Таким образом, оператор получает некоторое состояние и порождает другое. Однако, не каждый оператор всегда завершает свою работу (например, while true do x := x), так что эта функция, вообще говоря, является частичной. Иногда более предпочтительными являются альтернативные средства формализации семантики, например, преобразователи предикатов Дейкстры [22]. Но если мы добавим возможности, которые могут сложным образом изменить последовательность выполнения операторов, например, goto, или конструкции break и continue языка C, то даже такие решения перестанут работать, поскольку один оператор может привести к пропуску выполнения других операторов, следующих за ним в тексте программы. Вместо этого обычно используют более сложные семантики, основанные на *продолжениях (continuations)*.

В противоположность сказанному выше, функциональные программы, по словам
1.1. Достоинства функционального программирования Глава 1. Введение Хенсона, «носят свою семантику с собой» [29].3 Мы можем показать это на примере ML. Основные типы напрямую могут рассматриваться как математические объекты.

Используя стандартную запись [
[X]
] для «семантики X», мы можем сказать, например, что [
[int]
] = Z. Например, функция ML fact, определённая выражением:
let rec fact n =
if n = 0 **then** 1
else n ∗ fact (n −1 ) ; ;

integer ojouj direjim urina int, n bozpaulner auselichele runa int, tak tvo oua proporcionalierenciobzd'unfloi c aocevorkinhoi d'acrorejouoi d'avruehoi d'avruei n't, tak t'o oha i'opcros'isti'.

$$[\mbox{fact}](n)=\left\{\begin{array}{ll}n!&\mbox{if}n\geq0\\ \perp&\mbox{otherwise}\end{array}\right.$$
(Здесь ⊥ обозначает неопределённость, поскольку для отрицательных аргументов программа не сможет завершиться). Однако этот способ простой интерпретации не работает для не-функциональных программ, поскольку, так называемые «функции» могут не быть функциями в математическом смысле. Например, в стандартной библиотеке языка C есть функция rand(), которая возвращает различные псевдослучайные значения при последовательных вызовах. Это может быть сделано с помощью локальных статических переменных, используемых для хранения предыдущих результатов, например, так:
int rand ( **void** ) {
static int n = 0;
return n = 2147001325 ∗n + 715136305;
}
Таким образом, мы можем рассматривать отказ от переменных и присваивания, как следующий шаг после отказа от goto, поскольку каждый такой шаг делает семантику проще. Более простая семантика делает доказательство свойств программ яснее. В свою очередь, это даёт нам больше возможностей для доказательства корректности программ и преобразований, используемых для их оптимизации.

NOTE: обособленные функции спасают от ошибок и помогают поддерживать код
У функциональных языков есть и другое потенциальное преимущество. Поскольку вычисление выражений не имеет побочных эффектов для любых состояний, то отдельные подвыражения могут вычисляться в произвольном порядке, не влияя друг на друга. Это означает, что функциональные программы хорошо поддаются распараллеливанию, т. е. компьютер может автоматически вычислять различные подвыражения на разных процессорах. В то же время, императивные программы часто задают жёсткий порядок вычислений, так что даже ограниченное перемешивание инструкций в современных процессорах с конвейерной обработкой ведёт к сложностям и возникновению технических проблем.

На самом деле, ML не является чисто функциональным языком программирования; в нём есть переменные и присваивания, если потребуется. Большую часть времени мы будем делать нашу работу, оставаясь в рамках чисто функционального некоторые из ранее перечисленных достоинств, останется в силе большая гибкость в работе с функциями, свойственная языкам, подобным ML. Программы часто могут быть выражены очень кратко и элегантно при помощи функций высшего порядка
(функций, которые оперируют другими функциями).4 Код может быть более общим, поскольку он может параметризоваться другими функциями. Например, программа, которая складывает список чисел, и программа, которая его умножает, могут рассматриваться как экземпляры одной и той же программы, которая параметризуется арифметической операцией над парой чисел и единичным элементом. В первом случае это будут + и 0, а во втором - ∗и 1.5 В заключение, функции могут использоваться для представления *бесконечных* наборов данных удобным способом, например, мы позже покажем как использовать функции для выполнения вычислений с вещественными числами, в отличие от использования приближений в виде чисел с плавающей запятой.

В то же время, функциональные программы не лишены собственных проблем.

Поскольку для функциональных программ не столь очевидно, какие действия будут в итоге выполнены аппаратурой, для них может быть тяжело вычислить точно потребление ресурсов, таких как время и память. Ввод-вывод также непросто выразить в рамках функциональной модели, хотя существуют остроумные способы, основанные на бесконечных последовательностях.

Читатели данной книги должны сами сделать заключение о достоинствах функционального стиля. Мы хотим не навязывать какую-либо идеологию, а лишь показать, что *существуют* разные подходы к программированию, и что в соответствующих ситуациях функциональное программирование может иметь значительные достоинства. Большинство наших примеров выбрано из областей, которые могут быть определены как «символьные вычисления». Мы верим, что функциональные программы успешно работают в таких приложениях. Однако, как всегда, человек должен использовать наиболее подходящие для работы инструменты. Возможно, что императивное, объектно-ориентированное или логическое программирование лучше подходят для определённых задач.

## 1.2 План

Для тех, кто использовал императивное программирование, переход к функциональному будет неизбежно тяжёл, независимо от избранного подхода. Хотя есть люди, которые сразу хотят перейти непосредственно к программированию, мы выбрали другой порядок - мы начнём с λ-исчисления и покажем, как оно может быть использовано в роли теоретической основы функциональных языков. Такой подход обладает тем достоинством, что он хорошо соответствует реальной истории разработки функциональных языков.

Следовательно, сначала мы введём λ-исчисление и покажем, как оно, первоначально предназначенное на роль формальной логической основы математики, превратилось в полноценный язык программирования. Затем мы обсудим, зачем мы хотим добавить типы в λ-исчисление, и покажем, как добиться требуемого. Это приведёт нас к языку ML, который по существу является оптимизированной реализацией типизированного λ-исчисления с определённой стратегией вычисления выражений. Мы рассмотрим практические основы функционального программирования на ML, обсудим полиморфизм и понятие наиболее общего типа данных. Затем мы перейдём к более сложным темам, таким как исключения и императивные возможности ML. В заключение, приведём несколько реальных примеров, которые, как мы надеемся, подтвердят мощь ML.

## Дополнительная Литература

Множество книг о «функциональном программировании» включают в себя общее введение в предмет и описание отличий данного подхода от императивного - просмотрите несколько и выберите ту, которая вам нравится. Например, Хенсон предлагает хорошее вводное обсуждение [29], которое содержит такую же смесь теории и практики, как и данный текст. Детальная и спорная пропаганда функционального стиля программирования изложена в работе создателя FORTRAN Джона Бэкуса [4]. Э. Гордон обсуждает возникающие в функциональных языках проблемы ввода-вывода, а также приводит некоторые их решения [26]. Читатели, заинтересовавшиеся денотационной семантикой для императивных и функциональных языков, могут обратиться к [63].

## Глава 2 Λ-Исчисление

В основе λ-исчисления лежит идея представления функций в так называемой λ-
нотации. В неформальной математике, когда кто-то хочет сослаться на функцию, то обычно сначала даёт ей произвольное имя, а затем использует уже его, например:
Предположим, что функция f : R →R определена выражением:

$$f(x)={\left\{\begin{array}{l l}{0}&{{\mathrm{if~}}x=0}\\ {x^{2}s i n(1/x^{2})}&{{\mathrm{if~}}x\neq0}\end{array}\right.}$$
Тогда f ′(x) не интегрируема по Лебегу в пределах [0, 1].

Большинство языков программирования, например C, в этом отношении похожи:
мы можем определять только именованные функции. Например, для того, чтобы использовать функцию successor (которая добавляет 1 к своему аргументу) нетривиально (например, через указатель), то несмотря на её простоту, нам всё равно придётся предварительно задать определение, в которое входит имя:
int suc ( **int** n) {
return n + 1;
}
С точки зрения традиционной математики либо программирования это выглядит естественно и, в общем случае, достаточно удобно. Однако, такой подход начинает причинять массу затруднений при необходимости работы с функциями высшего порядка (которые манипулируют другими функциями). В любом случае, если мы хотим рассматривать функции наравне с другими математическими объектами, то требование давать им имена будет нелогичным. При обсуждении арифметического выражения, построенного из более простых подвыражений, мы просто записываем их без каких-либо имён. Представим, что было бы, если бы мы всегда работали с арифметическими выражениями таким образом:
Определим x и y так, что x = 2 и y = 4. Тогда xx = y.

Применение λ-нотации позволяет задавать функции практически тем же способом, что и остальные виды математических объектов. Существуют общепринятые обозначения, которые иногда использовались в математике для этих целей, хотя
2.1. Преимущества лямбда-нотации Глава 2. Лямбда-исчисление обычно они встречаются в составе именованных определений. Мы могли бы записать x 7→t[x]
для обозначения функции, отображающей любой аргумент x в некоторое произвольное выражение t[x], которое обычно, но не обязательно, содержит x (иногда полезно "отбросить" аргумент). Однако, мы будем использовать другую нотацию, разработанную Чёрчем [14]:

## Λx. T[X]

Это выражение имеет точно такой же смысл, как и предыдущее. Например, *λx.x* является тождественной функцией, которая просто возвращает переданный аргумент, в то время как *λx. x*2 обозначает функцию возведения в квадрат.

Выбор символа λ является произвольным и не несёт никакой смысловой нагрузки.

(Так, например, нередко встречается, особенно во французских текстах, обозначение [x] t[x].) Вероятно, что он возник в ходе сложного эволюционного процесса. Первоначально в известной книге *Principia Mathematica* [62] использовалось обозначение t[ˆ
x]
для функции от x, производящей t[x]. Чёрч изменил его на ˆ
x. t[x], но поскольку наборщики текстов не могли поместить значок ˆ над x, то оно вышло в свет как
∧*x. t*[x], которое затем трансформировалось в *λx. t*[x] в руках других наборщиков.

## 2.1 Преимущества Λ-Нотации

Используя λ-нотацию мы можем прояснить некоторые неточности, присущие неформальным математическим обозначениям. Например, часто говорят о 'f(x)', подразумевая, что из контекста понятно, о чём идёт речь - о самой функции f, или о результате её применения к конкретному x. Дополнительной пользой будет то, что λ-нотация даёт нам возможности анализа почти всего языка математики.

Если мы начнём с переменных и констант и будем строить выражения, используя лишь λ-абстрацию и применение функций к аргументам, то сможем в конечном счёте представить очень сложные математические выражения.

Будем использовать общепринятое обозначение f(x) для операции применения функции f к аргументу x, за тем исключением, что в традиционной λ-нотации скобки могут быть опущены, позволяя тем самым записать это выражение в виде *f x*. По причинам, которые станут понятны в процессе чтения следующего абзаца, мы считаем, что применение функции ассоциативно слева, т. е. *f x y* означает (f(x))(y). В
качестве сокращённой записи для λx.λy.t[*x, y*] будем использовать λx y.t[*x, y*], и т. д.

Мы также предполагаем, что область действия λ-абстракции распространяется вправо, насколько это возможно. Например, *λx. x y* означает λx. (x y), а не (*λx. x*) y.

На первый взгляд, нам необходимо введение специальных обозначений для функций нескольких аргументов. Однако, существует способ представления таких функций в обычной λ-нотации. Этот способ называется каррированием (*currying*), по имени математика-логика Карри [16]. (В действительности, такой приём уже использовался и Фреге [24], и Шейнфинкелем [56], но легко понять, почему соответствующие термины не получили общественного признания.) Идея заключается в особой трактовке выражений вида *λx y. x* + y. Это выражение может рассматриваться как функция R →(R →R), так что можно сказать, что оно является 'функцией высшего порядка (higher order function)' или 'функционалом (functional)', поскольку в результате применения к другой функции производит новую функцию, которая получает второй аргумент. На самом деле, она получает аргументы по очереди, по одному, а не все сразу. Например, рассмотрим:

$$(\lambda x\ y.\ x+y)\ 1\ 2=(\lambda y.\ 1+y)\ 2=1+2$$
Заметим, что в λ-нотации применение функции считается левоассоциативной операцией, поскольку каррирование используется очень часто.

Возможности λ-нотации особенно полезны для унификации понятия связанных переменных. В математике переменные обычно выражают зависимость некоторого выражения от значения этой переменной; например, значение x2 + 2 зависит от значения x. В таком контексте мы будем говорить, что переменная является *свободной*.

Однако, существуют другие ситуации, где переменная просто используется в качестве обозначения, а не показывает зависимость от значения. В качестве примеров можно рассмотреть переменную m в выражении

$$\sum_{m=1}^{n}m={\frac{n(n+1)}{2}}$$
и переменную y в выражении

$$\int_{0}^{x}2y+a\ dy=x^{2}+ax$$

$$\int_{0}^{x}2z+a\ dz=x^{2}+ax$$.

Немалое количество подобных примеров доступно и в других областях. Так, в логике применяются кванторы ∀*x. P*[x] ('для всех x, справедливо P[x]') и ∃*x. P*[x]
('существует такое значение x, для которого P[x] истинно'); в теории множеств —
абстрактные множества, наподобие {x | P[x]}, а также индексированные объединения и пересечения. В таких случаях говорят, что переменная должна быть связанной (bound). В определённых подвыражениях она является свободной, но в полном выражении связана *операцией связывания переменных*, такой как сложение. Часть, находящаяся 'внутри' этой операции связывания переменных, называется областью видимости (scope) связанной переменной.

Похожая ситуация возникает в большинстве языков программирования, по крайней мере, среди потомков Algol 60. Переменные имеют определённую область видимости, а формальные аргументы процедур и функций являются связанными переменными, например, n в приведённом выше определении функции successor на языке C.

Кто-то может рассматривать объявления переменных как операцию связывания для вложенных объектов соответствующих переменных. Отметим, что область видимости переменной не следует отождествлять с её *временем жизни*. В функции rand на языке C, которую мы привели во введении, переменная n имеет ограниченную область видимости, но сохраняет своё значение даже за пределами данного блока кода.

Мы можем свободно изменить имя связанной переменной, не затрагивая смысл выражения. Например, Z x
2.1. Преимущества лямбда-нотации Глава 2. Лямбда-исчисление

0 2a + a da ̸= x2 + ax
Аналогичным образом, при использовании λ-нотации выражения *λx. E*[x] и
λy. E[y] являются эквивалентными; это называется *альфа*-эквивалентностью, а процесс преобразования одного выражения в другое - альфа-преобразованием. Следует особо оговорить, что переменная y не должна быть свободной в выражении E[x], иначе его значение изменится, например, как в Z x

0 2x + a dx = x2 + ax
Также возможно использовать в одном выражении одинаковые имена для свободных и связанных переменных; хотя это может сбивать с толку, но с технической точки зрения неоднозначности не возникает, например Z x В действительности, обычная нотация Лейбница для производных имеет то же самое свойство, например, в d

dxx2 = 2x
переменная x используется и как связанная для того, чтобы показать, что дифференцирование производится относительно x, и как свободная, чтобы показать, где будет происходить окончательное вычисление производной. Это может сбивать с толку, например, f ′(g(x)) обычно означает что-то отличное от d dxf(g(x)). Авторы, стремящиеся к максимальной точности формулировок, особенно в работах, посвящённых функциям многих переменных, зачастую подчёркивают это различие специальными обозначениями, например,

| d dxx2|x = 2x или | d dzz2|x = 2x
Одной из привлекательных черт λ-нотации является возможность рассматривать все операции связывания переменных, такие как суммирование, дифференцирование или интегрирование, как функции, применяемые к λ-выражениям. Обобщение таких операций с помощью λ-абстракции позволяет нам сконцентрироваться на технических проблемах связанных переменных в конкретной ситуации. Например, мы можем рассматривать d dxx2 как синтаксическую обвязку (syntactic sugaring) для D (λx.x2) x где D : (R →R) →R →R является оператором дифференцирования, результат применения которого - производная первого аргумента (функции) в точке, указанной вторым аргументом. Преобразуя обычный синтаксис в λ-нотацию, мы получим D (λx. EXP x 2) x для некоторой константы EXP, представляющей экспоненциальную функцию.

щего 'абстрактного синтаксиса'; всё что нам нужно - соответствующий набор констант, с которыми мы будем работать. В ретроспективе, λ-абстракция выглядит как подходящий примитив, в терминах которого проводится анализ связывания переменных. Эта идея уходит корнями к записи логики высшего порядка в λ-нотации, использованной Чёрчем, и ко мнению Лэндина, которое будет продемонстрировано в следующей главе, что множество конструкций различных языков программирования имеет аналогичную интерпретацию. В последнее время, идея использования λ-нотации в качестве универсального абстрактного синтаксиса была введена Мартином-Лёфом, и часто на неё ссылаются как на 'теорию Мартина-Лёфа для выражений и арности
(arity)'.1

## 2.2 Парадокс Рассела

Как мы уже упоминали, одной из привлекательных сторон λ-нотации является её
пригодность для анализа почти всего математического синтаксиса. Первоначально, Чёрч надеялся продвинуться дальше и затронуть теорию множеств, которая, как хорошо известно, является достаточно мощной основой для большей части современной математики. Взяв любое множество S, мы можем задать для него так называемый характеристический предикат χS такой, что:

$$\chi_{S}(x)={\left\{\begin{array}{l l}{t r u e}&{{\mathrm{if~}}x\in S}\\ {f l a s e}&{{\mathrm{if~}}x\not\in S}\end{array}\right.}$$
И наоборот, для любого унарного предиката (т.е. функции одного аргумента) P, мы можем рассмотреть множество всех x, удовлетворяющих P(x) - мы будем просто записывать P(x) для P(x) = *true*. Таким образом, мы видим, что множества и предикаты являются лишь различными способами выражения одних и тех же понятий.

Вместо трактовки S как множества и записи x ∈S, мы можем рассматривать его как предикат и записывать как S(x).

Это позволяет проведение обычного анализа в λ-нотации: мы можем допустить что произвольные λ-выражения являются как функциями, так, косвенным образом, и множествами. К сожалению, это приводит к противоречиям. Простейшим способом убедиться в этом служит парадокс Рассела про множество всех множеств, которые не содержат сами себя:

## R = {X | X ̸∈X}

У нас имеется R ∈R ⇔R ̸∈R, сильное противоречие. В терминах функций, определённых с помощью λ-нотации, мы задаём R = λx. ¬(x x), а затем находим, что R R = ¬(R R), исходя из интуитивного понимания операции отрицания ¬.

Для того, чтобы избежать таких парадоксов, Чёрч развивает идею Рассела путём добавления в λ-нотацию понятия *типа* [13], которое будет подробно рассмотрено далее. Однако, сам парадокс предлагает некоторые интересные возможности в стандартной, нетипизированной системе, в чём мы убедимся позже.

## 2.3 Λ-Исчисление Как Формальная Система

До сих пор некоторые очевидные факты принимались нами без обоснования, например, что (λy. 1 + y) 2 = 1 + 2, поскольку это соответствует желаемым свойствам операций применения и абстракции, которые считаются в определённом смысле вза-
Глава 2. Лямбда-исчисление их) формальными правилами. Привлекательность этого шага в том, что правила в дальнейшем могут применяться механически, подобно тому, как преобразование уравнения x −3 = 5 −x в равносильное ему 2x = 5 + 3 не требует каждый раз задумываться, *почему* допустимо такое перемещение слагаемых из одной части равенства в другую. Как писал Уайтхед [61], формальная символика и правила действий. . .

[. . . ] вводились всякий раз, когда требовались что-либо упростить. [. . . ] используя формальные обозначения, мы можем переходить от одного этапа рассуждений к другому почти механически, зрительно, в противном же случае нам пришлось бы задействовать гораздо больше интеллектуальных ресурсов. [. . . ] Цивилизация прогрессирует, увеличивая количество важных операций, которые могут производиться, не задумываясь.

## 2.3.1 Λ-Термы

Основой λ-исчисления служит формальное понятие λ-термов, которые строятся из переменных и некоторого фиксированного множества констант при помощи операций применения (аппликации) функций и λ-абстракции. Это значит, что всевозможные λ-термы разбиваются на четыре класса:

1. **Переменные:** обозначаются произвольными алфавитно-цифровыми строками; как правило, мы будем использовать в качестве имён буквы, расположенные ближе к концу латинского алфавита, например, x, y и z.
2. **Константы:** количество констант определяется конкретной λ-нотацией, иногда
их нет вовсе. Мы будем также обозначать их алфавитно-цифровыми строками, как и переменные, отличая друг от друга по контексту.
3. **Комбинации:** применение функции s к аргументу t, где s и t представляют собой произвольные термы. Будем обозначать комбинации как *s t*, а их составные
части называть «ратор» и «ранд» соответственно.2
4. **Абстракция** произвольного λ-терма s по переменной x (которая может как
входить свободно в s, так и нет) имеет вид *λx. s*.
Формально, этот набор правил представляет собой индуктивное определение множества λ-термов, т. е. последние могут конструироваться *только так*, как описано выше. Благодаря этому, мы получаем основания для
- определения функций над λ-термами при помощи примитивной рекурсии;
- доказательства утверждений о свойствах λ-термов методом структурной индукции.

Формальное изложение понятий индуктивного построения, а также примитивной рекурсии и структурной индукции доступно из многих источников. Мы надеемся, что читатель, не знакомый с этими формализмами, сможет получить достаточное Глава 2. Лямбда-исчисление
2.3. Лямбда-исчисление как формальная система Подобно языкам программирования, синтаксис λ-термов может быть задан при помощи БНФ (форм Бэкуса-Наура):

## Exp = V Ar | Const | Exp Exp | Λ V Ar. Exp

после чего мы можем трактовать термы, как это принято в теории формальных языков, не просто как цепочки символов, а как абстрактные синтаксические деревья. Это значит, что соглашения наподобие левоассоциативности операции применения функции либо интерпретации *λx y. s* как *λx. λy. s*, а также неразличимость переменных и констант по именам не являются неотъемлемой частью формализма λ-исчисления, а имеют смысл исключительно в момент преобразования терма в форму, подходящую для восприятия человеком, либо в обратном направлении.

В завершение упомянем ещё одно соглашение, принятое в данном пособии. Будем использовать в λ-термах односимвольные имена не только для констант и переменных, но и для так называемых *метапеременных*, обозначающих любые термы.

Например, выражение *λx. s* может представлять как константную функцию со значением s, так и произвольную λ-абстракцию по переменной x. Для предотвращения путаницы, условимся применять буквы s, t и u в качестве метапеременных. Устранить неоднозначность полностью возможно, например, за счёт потери компактности записи: введением имён переменных вида Vx вместо x, а констант - Ck вместо k, после чего исчезает необходимость приписывать именам особый статус.

## 2.3.2 Свободные И Связанные Переменные

В этом разделе мы формализуем интуитивное понятие свободных и связанных переменных, которое, между прочим, служит хорошим примером определения примитивно-рекурсивных функций. Интуитивно, вхождение переменной в заданный терм считается свободным, если оно не лежит в области действия соответствующей абстракции. Обозначим множество свободных переменных в терме s через FV (s) и дадим его рекурсивное определение:

$$\begin{array}{r c l}{F V(x)}&{=}&{\{x\}}\\ {F V(c)}&{=}&{\emptyset}\\ {F V(s\;t)}&{=}&{F V(s)\cup F V(t)}\\ {F V(\lambda x.\,s)}&{=}&{F V(s)-\{x\}}\end{array}$$
Аналогично вводится и понятие множества связанных переменных BV (s):

$$\begin{array}{r c l}{{B V(x)}}&{{=}}&{{\emptyset}}\\ {{}}&{{B V(c)}}&{{=}}&{{\emptyset}}\\ {{}}&{{B V(s\;t)}}&{{=}}&{{B V(s)\cup B V(t)}}\\ {{B V(\lambda x.\,s)}}&{{=}}&{{B V(s)\cup\{x\}}}\end{array}$$
Например, если s = (*λx y.x*) (*λx.z x*), то FV (s) = {z} и BV (s) = {*x, y*}. Отметим, что в общем случае переменная может быть одновременно и свободной, и связанной в одном и том же терме, как это было показано выше. Воспользуемся структурной индукцией, чтобы продемонстрировать доказательство утверждений о свойствах λ- термов на примере следующей теоремы (аналогичные рассуждения применимы и ко множеству BV ).

2.3. Лямбда-исчисление как формальная система Глава 2. Лямбда-исчисление Теорема 2.1 Для произвольного λ-терма s множество FV (s) конечно.

Доказательство: Применим структурную индукцию. Очевидно, что для терма s, имеющего вид переменной либо константы, множество FV (s) конечно по определению (содержит единственный элемент либо пусто соответственно). Если терм s представляет собой комбинацию t u, то согласно индуктивному предположению, как FV (t), так и FV (u) *конечны, в силу чего* FV (s) = FV (t)∪FV (u) также конечно, как объединение двух конечных множеств. Наконец, если s имеет форму λx. t, то по определению FV (s) = FV (t) −{x}, а FV (t) конечно по индуктивному предположению, откуда следует, что FV (s) также конечно, поскольку его мощность не может превышать мощности FV (t).□

## 2.3.3 Подстановка

Одним из правил, которые мы хотим формализовать, является соглашение о том, что λ-абстракция и применение функции представляют собой взаимно обратные операции. То есть, если мы возьмём терм *λx. s* и применим его как функцию к термуаргументу t, результатом будет терм s, в котором все свободные вхождения переменной x заменены термом t. Для большей наглядности это действие принято обозначать λx. s[x] и s[t] соответственно.

Однако, простое на первый взгляд понятие подстановки одного терма вместо переменной в другой терм на самом деле оказалось весьма коварным, так что даже некоторые выдающиеся логики не избежали ложных утверждений относительно его свойств. Подобный грустный опыт разочаровывает довольно сильно, ведь как мы говорили ранее, одним из привлекательных свойств формальных правил служит возможность их чисто механического применения.

Обозначим операцию подстановки терма s вместо переменной x в другой терм t как t[s/x]. Иногда можно встретить другие обозначения, например, t[x:=s], [s/x]t, или даже t[x/s]. Мы полагаем, что предложенный нами вариант легче всего запомнить по аналогии с умножением дробей: x[t/x] = t. На первый взгляд, рекуррентное определение понятия подстановки выглядит так:

$$\begin{array}{r c l}{{x[t/x]}}&{{=}}&{{t}}\\ {{y[t/x]}}&{{=}}&{{y,\ \operatorname{ecim}\,x\neq y}}\\ {{}}&{{}}&{{c[t/x]}}&{{=}}&{{c}}\\ {{(s_{1}\ s_{2})[t/x]}}&{{=}}&{{s_{1}[t/x]\ s_{2}[t/x]}}\\ {{(\lambda x.\ s)[t/x]}}&{{=}}&{{\lambda x.\ s}}\\ {{(\lambda y.\ s)[t/x]}}&{{=}}&{{\lambda y.\ (s[t/x]),\ \operatorname{ecim}\,x\neq y}}\end{array}$$
К сожалению, это определение не совсем верно. Например, подстановка (*λy. x* +
y)[y/x] = *λy.y*+y не соответствует интуитивным ожиданиям от её результата.3 Исходный λ-терм интерпретировался как функция, прибавляющая x к своему аргументу, так что после подстановки мы ожидали получить функцию, которая прибавляет y, а на деле получили функцию, которая свой аргумент удваивает. Источником проблемы служит *захват* переменной y, которую мы подставляем, операцией *λy. . . .*, которая Глава 2. Лямбда-исчисление
2.3. Лямбда-исчисление как формальная система связывает одноимённую переменную. Чтобы этого не произошло, связанную переменную требуется предварительно переименовать:

$$(\lambda y.\,x+y)=(\lambda w.\,x+w),$$
а лишь затем производить подстановку:

$$(\lambda w.\ x+w)[y/x]=\lambda w.\ y+w$$
Существуют два подхода к решению этой проблемы. С одной стороны, можно условиться, что подстановка недопустима в ситуации захвата переменной, а с другой - расширить формальное определение подстановки таким образом, чтобы требуемое переименование переменных происходило автоматически. Мы остановимся на последнем варианте:

    x[t/x]
          =
            t
    y[t/x]
          =
            y, если x ̸= y
    c[t/x]
          =
            c
(s1 s2)[t/x]
          =
            s1[t/x] s2[t/x]
(λx. s)[t/x]
          =
            λx. s
(λy. s)[t/x]
          =
            λy. (s[t/x]), если x ̸= y и либо x ̸∈FV (s), либо y ̸∈FV (t)
(λy. s)[t/x]
          =
            λz. (s[z/y][t/x]) в противном случае, причём z ̸∈FV (s) ∪FV (t)

  Единственное отличие этого определения заключается в двух последних прави-
лах. Мы следуем предыдущему определению в двух безопасных ситуациях, когда
либо переменная x не свободна в терме s, так что подстановка оказывается триви-
альной, либо когда y не свободна в t, так что захват переменной не произойдёт (на
данном уровне). Однако, в случае, когда оба эти условия не выполняются, мы пред-
варительно переименовываем переменную y в z, выбранную так, чтобы она не была
свободной ни в терме s, ни в терме t, после чего продолжаем, как описано выше.
Для определённости, переменная z может выбираться некоторым фиксированным
способом, например, как первая в лексикографическом порядке имён переменная из
множества всех переменных, не имеющих свободных вхождений ни в s, ни в t.4

## 2.3.4 Преобразования

Ещё одной из основ λ-исчисления служат три «преобразования» - операции получения по заданному терму другого, равного ему в интуитивном смысле. Традиционно
2.3. Лямбда-исчисление как формальная система Глава 2. Лямбда-исчисление

- Альфа-преобразование: λx. s −
→
α
λy. s[y/x], при условии, что y ̸∈FV (s). Например, λu.u v −
→
α
λw.w v, но λu.u v ̸−
→
α
λv.v v. Такое ограничение устраняет
возможность ещё одного случая захвата переменной.
- Бета-преобразование: (λx. s) t −
→
β
s[t/x].
- Эта-преобразование: λx. t x −
→
η
t, если x ̸∈FV (t). Например, λu. v u −
→
η
v,
но λu. u u ̸−
→
η
u.
Среди этих трёх операций наиболее важной для нас является β-преобразование, поскольку оно соответствует вычислению функции для заданного аргумента. В то же время, α-преобразование играет роль вспомогательного средства переименования связанных переменных, а η-преобразование представляет собой разновидность экстенсиональности, в силу чего интересно главным образом с точки зрения логиков, а не программистов.

## 2.3.5 Эквивалентность Λ-Выражений

Используя приведённые выше правила преобразований, мы можем определить формально условия, при которых два λ-терма считаются эквивалентными. В общих чертах, два терма эквивалентны, если один из них может быть получен из другого в ходе конечной последовательности α, β либо η-преобразований, которые применяются к произвольным подтермам как в прямом, так и в обратном направлении. Другими словами, отношение λ-эквивалентности представляет собой конгруэнтное замыкание трёх преобразований и обладает свойствами рефлексивности, симметричности, транзитивности и заменяемости. Ниже приводится формальное индуктивное определение, правила которого трактуются следующим образом: если утверждение над горизонтальной чертой выполняется, то справедливо и утверждение под ней.

s −
  →
  α
     t или s −
              →
              β
                 t или s −
                         →
                         η
                            t

s = t

     t = t
    s = t
    t = s
s = t и t = u

s = u
s = t

s u = t u
 s = t

u s = u t
 s = t

λx. s = λx. t Отметим, что использование обычного знака равенства (=) в данном контексте может ввести в заблуждение. В самом деле, мы *задаём* некоторое отношение λ-эквивалентности, взаимосвязь которого с понятием равенства соответствующих Глава 2. Лямбда-исчисление
2.3. Лямбда-исчисление как формальная система математических объектов остаётся неясной.6 В то же время очевидно, что следует отличать λ-эквивалентность от *синтаксического равенства*. Последнее будем называть «тождеством» и обозначим символом ≡. Например, λx. x ̸≡*λy. y*, хотя в то же время λx. x = *λy. y*.

Во многих случаях оказывается, что α-преобразования не играют роли, в силу чего вместо строгого тождества применяется его вариант ≡α. Это отношение определяется подобно λ-эквивалентности, но исключительно для α-преобразований. Например, (λx.x)y ≡α (*λy.y*)y. Многие авторы используют его как тождество λ-термов, тем самым разбивая множество термов на соответствующие классы эквивалентности. Существуют альтернативные системы обозначений, например [20], в которых связанные переменные не имеют имён. В таких системах традиционное понятие тождества совпадает с ≡α.

## 2.3.6 Экстенсиональность

Мы уже упоминали ранее, что η-преобразование воплощает принцип экстенсиональности. В рамках общепринятых философских понятий два свойства называются экстенсионально эквивалентными (либо *коэкстенсивными*), если этими свойствами обладают в точности одни и те же объекты. В теории множеств принята аксиома экстенсиональности, согласно которой два множества совпадают, если они состоят из одних и тех же элементов. Аналогично, будем говорить, что две функции эквивалентны, если области их определения совпадают, а значения функций для всевозможных аргументов также одинаковы.

Введение η-преобразования делает наше понятие λ-эквивалентности экстенсиональным. В самом деле, пусть f x и *g x* равны для произвольного значения x; в частности, f y = *g y*, где переменная y выбирается так, чтобы она не была свободной как в f, так и в g. Согласно последнему из приведённых выше правил эквивалентности,
λy. f y = *λy. g y*. Применив дважды η-преобразование, получаем, что f = g. С другой стороны, из экстенсиональности следует, что всевозможные η-преобразования не нарушают эквивалентности, поскольку согласно правилу β-редукции (λx.t x) y = t y для произвольного y, если переменная x не является свободной в терме t. На этом мы завершаем обсуждение сущности η-преобразования и его влияния на теорию в целом, чтобы уделить больше внимания более перспективному с точки зрения вычислимости β-преобразованию.

## 2.3.7 Λ-Редукция

Отношение λ-эквивалентности, как и следовало ожидать, является симметричным. Оно достаточно хорошо соответствует интуитивному понятию эквивалентности λ-термов, но с алгоритмической точки зрения более интересен его несимметричный аналог. Определим отношение редукции −
→следующим образом:

s −
  →
  α
     t или s −
              →
              β
                 t или s −
                         →
                         η
                            t

s −
  →t

$$t\longrightarrow t$$ $$s\longrightarrow t\text{n}t\longrightarrow u$$ $$s\longrightarrow u$$ $$s\longrightarrow t$$ $$u\longrightarrow t\text{n}u$$ $$s\longrightarrow t$$ $$u\longrightarrow u\text{n}t$$ $$s\longrightarrow t$$ $$\lambda x.\text{}s\longrightarrow\lambda x.\text{}t$$

B 'reflexiture:Inichtchi Ichoo ejecnykhus' (u acutrocnt, repumit $\beta$-pejvkhus, kotro-pkhu mouzza nusmabori $\beta$-mpe0pasovannu) in opuaxetor roumo curt $\eta$-pejvkhus', kotro-pocov.

| (     | λx. x x x   | ) (   | λx. x x x   | )   |
|-------|-------------|-------|-------------|-----|
| −     | →           |       |             |     |
| (     | λx. x x x   | ) (   | λx. x x x   | ) ( |
| −     | →           |       |             |     |
| (     | λx. x x x   | ) (   | λx. x x x   | ) ( |
| −     | →           |       |             |     |
| . . . |             |       |             |     |

Однако, несмотря на это редукция имеет прямое отношение к процедуре вычисления терма, в ходе которой последовательно вычисляются комбинации вида f(x), где f - λ-абстракция. Если на некотором этапе оказывается, что не могут быть применены никакие правила редукции, кроме α-преобразований, то говорят, что терм имеет нормальную форму.

## 2.3.8 Стратегии Редукции

Отложив на время наши теоретические рассуждения, напомним их взаимосвязь с практикой функционального программирования. Программа на функциональном языке представляет собой *выражение*, а её выполнение - вычисление этого выражения. То есть, в терминах, изложенных выше, мы собираемся начать процесс вычислений с соответствующего терма и применять к нему правила редукции до тех пор, пока это возможно. Возникает вопрос: какое из имеющихся правил следует применять на каждом этапе? Отношение редукции - недетерминированное, то есть, для некоторых термов t найдётся множество термов ti таких, что t −
→ti. Выбор того или иного варианта оказывается иногда принципиально важным, поскольку может привести как к конечной, так и к бесконечной последовательности редукций (выполнение соответствующей программы при этом либо завершается, либо зацикливается). Например, подвергая редукции наиболее глубокий *редекс*7 в выражении, приведённом ниже, мы получаем бесконечную последовательность редукций:

$$(\lambda x.\,y)\,\left((\lambda x.\,x\,x\,x)\,\left(\lambda x.\,x\,x\,x\right)\right)$$ $$\longrightarrow\,\,\left(\lambda x.\,y\right)\,\left((\lambda x.\,x\,x\,x)\,\left(\lambda x.\,x\,x\right)\,\left(\lambda x.\,x\,x\right)\right)$$ $$\longrightarrow\,\,\left(\lambda x.\,y\right)\,\left((\lambda x.\,x\,x\,x)\,\left(\lambda x.\,x\,x\right)\,\left(\lambda x.\,x\,x\right)\,\left(\lambda x.\,x\,x\right)\right)$$ $$\longrightarrow\,\,\cdots$$

${}^{7}$arr:n. _redex_ (reducible expression) - ${}^{6}$pcayruppewoe nispache${}^{5}$
Глава 2. Лямбда-исчисление
2.3. Лямбда-исчисление как формальная система В то же время, редукция самого внешнего редекса

## (*Λx. Y*) ((*Λx. X X X*) (Λx. X X X)) − →Y

немедленно ведёт нас к желаемому результату.

Значение выбора стратегии редукции окончательно проясняется следующими теоремами, которые мы рассмотрим без доказательств, поскольку они слишком велики для данного учебника. Первая теорема утверждает, что ситуация, с которой мы столкнулись в последнем примере, и её решение достаточно общие, т. е. стратегия редукции самого левого редекса является наилучшей с точки зрения завершимости.

Теорема 2.2 Если справедливо s −
                             →t, где терм t имеет нормальную форму, то
последовательность редукций, которая начинается с терма s и состоит в приме-
нении правил редукции к самому левому редексу, всегда завершается и приводит к
терму в нормальной форме.

Применение этой теоремы требует формального определения понятия самого левого редекса: для терма (*λx.s*) t это он сам, для произвольного другого терма вида s t самым левым является самый левый редекс s, наконец, для абстракции *λx.s* это тоже самый левый редекс s. В рамках принятых в данном пособии обозначений мы будем всегда выбирать такой редекс, чтобы соответствующий ему символ λ был расположен левее прочих.

## 2.3.9 Теорема Чёрча-Россера

Следующее утверждение, которое мы рассмотрим, широко известно как теорема Чёрча-Россера. Оно гласит, что для двух конечных последовательностей редукций, начатых с терма t, всегда найдутся две другие последовательности, сводящие результаты предыдущих к одному и тому же терму (который, впрочем, может и не быть в нормальной форме).

Теорема 2.3 Если t −
                  →s1 и t −
                           →s2, то существует терм u такой, что s1 −
                                                                  →u
и s2 −
    →u.

Важные следствия данного утверждения:

Corollary 2.4 Если t1 = t2 то найдётся терм u такой, что t1 −
                                                            →u и t2 −
                                                                     →u.
Доказательство: Легко показать (при помощи структурной индукции), что от-
ношение λ-равенства = представляет собой симметричное транзитивное замы-
кание отношения редукции. Дальнейшее следует по индукции согласно свойствам
симметричного транзитивного замыкания. Приведённая ниже диаграмма может
показаться читателям, не склонным к формальным построениям, более доходчи-
вой:

t1 t2 @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  @ @ R  u
Мы полагаем, что t1 = t2, т. е. существует некоторая последовательность редукций в обеих направлениях (зигзагообразная линия в верхней части рисунка), которая их объединяет. Теорема Чёрча-Россера позволяет нам заполнить недостающие участки на краях диаграммы, после чего требуемый результат достигается композицией этих редукций.

Corollary 2.5 Если t = t1 и t = t2, причём t1 и t2 имеют нормальную форму,
то t1 ≡α t2, т. е. t1 и t2 равны с точностью до α-преобразований.
Доказательство: Согласно изложенному выше, найдётся некоторый терм u та-
кой, что t1 −
            →u и t2 −
                      →u. Но так как t1 и t2 уже имеют нормальную форму,
последовательность редукций, приводящая к терму u, может состоять лишь из
α-преобразований. □

  Таким образом, нормальные формы, если они существуют, являются единствен-
ными с точностью до α-преобразования. Это даёт нам первое обоснование того, что
отношение λ-эквивалентности нетривиально, т. е. что существуют неэквивалентные
термы. Например, поскольку λx y.x и λx y.y несводимы друг к другу исключительно
при помощи α-преобразований, они не эквивалентны.
  Подытожим важность полученных результатов в свете теории вычислимости.
Стратегия редукции, в которой на каждом шаге выбирается самый левый редекс,
считается, в известном смысле, наилучшей, поскольку она применима всегда, когда
применима любая другая стратегия. Такая стратегия получила название нормально-
го порядка редукции. С другой стороны, любая другая конечная последовательность
редукций будет всегда давать тот же самый результат; более того, всегда остаётся
возможность прекратить применение этой стратегии, перейдя при необходимости к
нормальному порядку. Мы увидим практическое применение этого принципа далее.

## 2.4 Комбинаторы

Впервые понятие комбинатора и основанная на нём теория были сформулированы М.И. Шейнфинкелем ещё до появления λ-исчисления [56]. Вскоре после этого аналогичные результаты были получены Карри, независимо от Шейнфинкеля и Чёрча. (Когда Карри ознакомился с работами Шейнфинкеля, он предпринял попытку с ним связаться, но к этому времени Шейнфинкель оказался в психиатрической лечебнице.) В данной работе мы позволим себе не соблюдать историческую достоверность, изложив теорию комбинаторов как один из аспектов λ-исчисления.

Будем называть *комбинатором* терм λ-исчисления без свободных переменных.

Такие термы также принято называть *замкнутыми*, поскольку их значение не зависит от значений каких-либо переменных. В дальнейшем в курсе функционального программирования мы встретимся с большим количеством полезных комбинаторов, но краеугольным камнем теории комбинаторов служит тот факт, что на самом деле достаточно лишь немногих из них. Оказывается, что произвольный терм может быть выражен при помощи определённого множества комбинаторов и всевозможных переменных, операция λ-абстракции становится ненужной. В частности, замкнутый терм может быть представлен исключительно через эти комбинаторы. Дадим их определения:

$$\begin{array}{r c l}{{I}}&{{=}}&{{\lambda x.\;x}}\\ {{K}}&{{=}}&{{\lambda x\;y.\;x}}\\ {{S}}&{{=}}&{{\lambda f\;g\;x.\;(f\;x)(g\;x)}}\end{array}$$
Чтобы легче их запомнить, можно воспользоваться простыми мнемоническими правилами.8 Комбинатор I представляет собой тождественную функцию («идентичность»), комбинатор K порождает семейство константных9 функций: после применения к аргументу a он даёт функцию *λy. a*. Наконец, S - комбинатор «совместного применения», который принимает в качестве аргументов две функции, применяемые к общему аргументу. Докажем следующее утверждение:

Лемма 2.6 Для произвольного λ-терма t, не содержащего λ-абстракций, найдётся
терм u, который также не содержит λ-абстракций и представляет собой компо-
зицию S, K, I и переменных, причём FV (u) = FV (t)−{x} и u = λx.t, т. е. терм u
λ-равен λx. t.
Доказательство: Применим к терму t структурную индукцию. Согласно условию,
он не может быть абстракцией, поэтому нам требуется рассмотреть лишь три
случая.

- Если t представляет собой переменную, возможны два случая, из которых
 непосредственно следует требуемый вывод: при t = x мы получаем λx. x = I,
 иначе, например, при t = y, λx. y = K y.

- Если t - константа c, то λx. c = K c.
- Если t представляет собой комбинацию термов, например, s u, то согласно
индуктивному предположению найдутся термы s′ и u′, которые не содержат
λ-абстракций и для которых справедливы равенства s′ = λx. s и u′ = λx. u. Из
этого можно сделать вывод, что S s′ u′ является искомым выражением. В
самом деле,
$S$$s^{\prime}$$u^{\prime}$$x$$=$$S$$(\lambda x.$$s)$$(\lambda x.$$u)$$x$$=$$((\lambda x.$$s)$$x)((\lambda x.$$u)$$x)$ $$\begin{array}{r l}{={}}&{{}s\ u}\\ {={}}&{{}t}\end{array}$$

Таким
      образом,
              применив
                       η-преобразование,
                                      мы
                                          получаем
                                                  S
                                                     s′
                                                        u′
                                                            =
λx. S s′ u′ x = λx. t, поскольку согласно индуктивному предположению пе-
ременная x не является свободной в термах s′ либо u′.

## □

Теорема 2.7 Для
                произвольного
                             λ-терма
                                      t
                                        существует
                                                    не
                                                       содержащий
                                                                   λ-
абстракций
           терм
                 t′,
                    полученный
                               композицией
                                           K,
                                               I
                                                 и
                                                    переменных,
                                                               такой,
что FV (t′) = FV (t) и t′ = t.
Доказательство: Применим структурную индукцию к терму t и воспользуем-
ся леммой 2.6. Например, если терм t имеет вид λx. s, то мы сначала можем
получить, согласно индуктивному предположению, терм s′ - свободный от λ-
абстракций эквивалент s. Далее применим лемму к λx.s′. Прочие случаи очевидны.
□

  Это примечательное утверждение может быть даже усилено, поскольку комбина-
тор I выражается через S и K. Отметим, что для произвольного A

$$\begin{array}{r c l}{{S\;K\;A\;x}}&{{=}}&{{(K\;x)(A\;x)}}\\ {{}}&{{=}}&{{(\lambda y.\;x)(A\;x)}}\\ {{}}&{{=}}&{{x}}\end{array}$$
Отсюда, применив η-преобразование, получаем, что I = *S K A* для любых A. Однако, по причинам, которые станут яснее после знакомства с понятием типа, наиболее удобно положить A = K. Таким образом, I = *S K K*, что даёт нам возможность устранить все вхождения I в комбинаторные выражения.

Заметим, что приведённые выше доказательства имеют конструктивный характер, поскольку предлагают конкретные процедуры получения по заданному терму эквивалентного комбинаторного выражения. Процесс его построения идёт в направлении снизу вверх, и для каждой λ-абстракции, которая по построению имеет тело, свободное от λ-абстракций, применяются сверху вниз преобразования, изложенные в лемме.

Несмотря на то, что мы рассматриваем комбинаторы как некоторые термы λ-
исчисления, на их основе можно сформулировать независимую теорию. Её построение начинается с определения формальных правил конструирования выражений, в которые не входит λ-абстракция, но входят комбинаторы. Далее вместо α, β и η- преобразований вводятся правила преобразования для выражений, включающих комбинаторы, например, K x y −
→x. Такая теория будет иметь множество аналогий в традиционном λ-исчислении, например, теорема Чёрча-Россера оказывается справедливой и для приведённого выше определения редукции. Кроме того, полностью устраняются сложности со связыванием переменных. Тем не менее, мы считаем полученный формализм не слишком интуитивным, поскольку комбинаторные выражения нередко бывают весьма неясными.

Помимо важной роли, которую комбинаторы играют в логике, они также имеют и определённый практический потенциал. Как мы уже кратко упоминали (подробное изложение ожидается в следующих разделах), λ-исчисление может считаться простым функциональным языком, основой для более развитых и практически применимых языков, наподобие ML. Теорема о комбинаторной полноте даёт основание говорить, что выражения λ-исчисления могут быть «скомпилированы» в «машинный код» комбинаторов. Эта терминология из теории языковых процессоров оказывается на самом деле вполне уместной. Комбинаторы применялись как средство реализации функциональных языков, в том числе и на уровне аппаратного обеспечения, предназначенного для вычисления комбинаторных выражений.

## Дополнительная Литература

Работа Барендрегта по теории λ-исчисления [5] отличается одновременно энциклопедичностью и доступностью. Другой популярный учебник принадлежит перу Р. Хиндли и Дж. Селдина [30]. Обе эти книги содержат доказательства результатов, которые мы приводим без обоснования. М. Гордон [27, часть 2] даёт упрощённое изложение предмета, ориентированное на его применение в прикладной математике. Существенная часть данного курса базируется на последней работе.

## Упражнения

1. Найдите нормальную форму терма (λx x x. x) *a b c*. 2. Пусть twice = *λf x. f*(fx). Каков интуитивный смысл *twice*? Найдите нормальную форму *twice twice twice f x*. (Напомним, что операция применения
функции левоассоциативна.)
3. Найдите терм t такой, что t −
→
β
t. Можно ли утверждать, что терм имеет
нормальную форму тогда и только тогда, когда из t −
→t′ следует t ≡α t′?
4. В каком случае справедливо s[t/x][u/y] ≡α s[u/y][t/x]?
5. Постройте выражение, равносильное λf x. f(x x), используя лишь комбинаторы I, K и S.
6. Найдите *единственный* комбинатор X такой, что все λ-термы эквивалентны
термам, построенным композицией X и переменных. Указание: положите A =
λp. p K S K, а затем рассмотрите A A A и A (A A).
7. Докажите, что терм X является комбинатором неподвижной точки тогда и
только тогда, когда он представляет собой неподвижную точку комбинатора G
такого, что G = λy m. m(y m).

## Глава 3 Λ-Исчисление Как Язык Программирования

«Проблема разрешимости» (также известная как *Entscheidungsproblem*) была одним из основных предметов изучения логиков 1930-х. Формулировка задачи такова: существует ли некоторая систематическая (механическая) процедура определения истинности утверждения в логике первого порядка? Положительный ответ на этот вопрос имел бы фундаментальное философское и, возможно, практическое значение: принципиальную возможность решить большое количество разнообразных сложных математических задач исключительно при помощи некоторого фиксированного метода (в настоящий момент используется термин *алгоритм*) без привлечения дополнительных творческих усилий.

Очевидно, что проблема разрешимости непроста, поскольку требует точного определения понятия «систематической» либо «механической» процедуры на языке математики. Вероятно, лучший анализ этой задачи был дан Тьюрингом [59], утверждавшим, что механическими можно считать действия, которые могут быть в принципе выполнены достаточно умным клерком, не обладающим знаниями об объекте этих действий. Абстрагирование поведения такого клерка привело в дальнейшем к известному понятию «машины Тьюринга». Вопреки тому, что эта концепция была чисто математической, а роль исполнителя действий первоначально предназначалась человеку, мы можем также рассматривать машину Тьюринга как очень простой компьютер. Несмотря на простоту, эта машина способна проделать любые вычисления, доступные реальным машинным исполнителям.1 Вычислительную модель, эквивалентную по своей полноте машине Тьюринга, принято называть полной по Тьюрингу либо *Тьюринг-полной*.

Почти одновременно с Тьюрингом, другими авторами были предложены независимые определения понятия «механической процедуры», большая часть которых оказалась эквивалентной машине Тьюринга по своей вычислительной полноте. В частности, лямбда-исчисление, первоначально предназначенное на роль формальной основы математики, также возможно трактовать и как язык программирования, в котором исполнение программ сводится к последовательности бета-преобразований.

В самом деле, Чёрч ещё до публикации работ Тьюринга сделал предположение, что множество операций, представимых в рамках лямбда-исчисления, является формальным эквивалентом интуитивного понятия «механической процедуры». Этот постулат получил название *тезиса Чёрча*. В дальнейшем было показано, что из данного тезиса следует неразрешимость *Entscheidungsproblem* [12]. Тьюринг впоследствии доказал, что множество функций, представимых в рамках лямбда-исчисления, в точности совпадает со множеством функций, вычислимых машиной Тьюринга. Этот результат послужил ещё одним доводом в пользу справедливости тезиса Чёрча.

С точки зрения современных программистов, программы для машины Тьюринга могут считаться достаточно примитивной разновидностью машинных кодов. В самом деле, очень вероятно, что именно машины Тьюринга, в особенности так называемая
«универсальная машина»,2 оказали решающее влияние на разработку современных компьютерных архитектур с хранимой программой; впрочем, степень этого влияния и его природа продолжают служить объектом дискуссий [55]. Примечательно то, что некоторые другие альтернативные определения «механической процедуры», часто сформулированные задолго до появления электронных компьютеров, достаточно точно соответствуют реальным методам программирования. Например, алгоритмы Маркова (формальная вычислительная модель, популярная в Советском Союзе) могут считаться основой языка программирования SNOBOL. В дальнейшем нас будет интересовать аналогичное влияние лямбда-исчисления на эволюцию функциональных языков.

Язык LISP, второй (после FORTRAN) старейший язык высокого уровня, использует некоторые понятия лямбда-исчисления, в частности, обозначение (LAMBDA *· · ·*)
для безымянных функций, но в целом ему не соответствует. В самом деле, как ранние версии языка, так и некоторые его современные диалекты используют принцип динамического связывания имён переменных, несовместимый с лямбда-исчислением (подробное обсуждение см. ниже). Более того, в ранних версиях отсутствовала приемлемая поддержка понятия функций высших порядков, зато имелся существенный объём императивных конструкций. Но несмотря на это, LISP заслуживает внимания как первый функциональный язык программирования, в котором также впервые были реализованы многие сопутствующие возможности, такие как автоматическое распределение памяти и «сборка мусора».

Влияние лямбда-исчисления на языки программирования приобрело реальный вес с появлением в 1960-х работ Лэндина и Стрейчи. В частности, Лэндин показал, что множество свойств распространённых в то время (императивных) языков может успешно анализироваться в терминах лямбда-исчисления (к примеру, понятие областей видимости переменных в Algol 60). Ним же было предложено использовать лямбда-исчисление как основу языков программирования, примером чего послужил функциональный язык ISWIM («If you See What I Mean»—досл. «Если вам понятно, о чём речь») [35]. Эта публикация завоевала в дальнейшем широкую известность и стала отправной точкой в разработке многих других языков, нашедших практическое применение.

Язык ML ведёт свою историю с появления в роли метаязыка (откуда, собственно, и происходит его название ML, Meta Language) системы доказательства теорем Глава 3. Лямбда-исчисление как язык программирования
3.1. Представление данных в лямбда-исчислении Edinburgh LCF [28]. Это значит, что язык был предназначен для реализации алгоритмов логического вывода в формальном дедуктивном исчислении. Определение языка обнаруживает существенное влияние ISWIM, но в отличие от последнего, ML был расширен такими возможностями, как новаторская полиморфная типизация, включающая абстрактные типы данных, либо система обработки ошибок на основе исключений. Эти черты языка были введены, исходя из реальных практических потребностей, что в итоге привело к целостному и точному дизайну. Подобная узкая специализация характерна для успешных языков (язык C может служить ещё одним хорошим примером) и резко их отличает от провальных попыток коллективного проектирования, таких как Algol 60, который оказался скорее источником важных идей, нежели практичным инструментом. Дальнейшее знакомство с ML состоится позже, а в данный момент мы рассмотрим, как в роли языка программирования может быть использовано чистое лямбда-исчисление.

## 3.1 Представление Данных В Λ-Исчислении

Программы для своей работы требуют входных данных, поэтому мы начнём с фиксации определённого способа представления данных в виде выражений лямбдаисчисления. Далее введём некоторые базовые операции над этим представлением. Во многих случаях оказывается, что выражение s, представленное в форме, удобной для восприятия человеком, может напрямую отображаться в лямбда-выражение s′.

Этот процесс получил жаргонное название «синтаксическая глазировка» («syntactic sugaring»), поскольку делает горькую пилюлю чистой лямбда-нотации более удобоваримой. Введём следующее обозначение:
s
△
= s′.

Будем говорить, что «s = s′ по определению»; другая общепринятая форма записи этого отношения - s =def s′. При желании, мы можем всегда считать, что вводим некоторое константное выражение, определяющее семантику операции, которая затем применяется к своим аргументам в обычном стиле лямбдаисчисления, абстрагируясь тем самым от конкретных обозначений. Например, выражение if E then E1else E2 возможно трактовать как COND *E E*1 E2, где COND —
некоторая константа. В подобном случае все переменные в левой части определения должны быть связаны операцией абстракции, т. е. вместо

$$\mathrm{{fst}}\ p\ {\stackrel{\triangle}{=}}\ p\ \mathrm{{true}}$$
(см. ниже) мы можем написать

$$\mathrm{{fst}}\ {\stackrel{\triangle}{=}}\ \lambda p.\ p\ \mathrm{{true}}.$$

## 3.1.1 Логические Значения И Условия

Для представления логических значений true («истина») и false («ложь») годятся любые два различных лямбда-выражения, но наиболее удобно использовать следующие:

true
△
=
λx y. x
false
△
=
λx y. y

Глава 3. Лямбда-исчисление как язык программирования

Herohnzysz 37th oipiecjechenia, jerko immert honstrie vorkombiot zbipiachenia, coorterryuiopterno konstypkuhl 7 : zunka C. Overma, tyo sov.comboie _eigndzeichenia_, a me _onezampon_ (korobacht ne immert aucha auszuumod konstrecire), noyomt hanque anhrep-naturabh ob63atelicho.

if $E$ then $E_{1}$ else $E_{2}\stackrel{{\triangle}}{{=}}E\ E_{1}\ E_{2}$
В самом деле, мы имеем:

if true then $E_{1}$ else $E_{2}$ = true $E_{1}$$E_{2}$

= ($\lambda x$$y.$$x$) $E_{1}$$E_{2}$

= $E_{1}$
и
if false then $E_{1}$ else $E_{2}$ = false $E_{1}$$E_{2}$

= ($\lambda x$$y.$$y$) $E_{1}$$E_{2}$

= $E_{2}$
Определив условное выражение, на его базе легко построить весь традиционный набор логических операций:
not p
△
=
if p then false else true p and q
△
=
if p then q else false p or q
△
=
if p then true else q

## 3.1.2 Пары И Кортежи

Определим представление упорядоченных пар следующим образом:

$$(E_{1},E_{2})\stackrel{\triangle}{=}\lambda f.\;f\;E_{1}\;E_{2}$$
Использование скобок не обязательно, хотя мы часто будем использовать их для удобства восприятия либо подчёркивания ассоциативности. На самом деле, мы можем трактовать запятую как инфиксную операцию наподобие +. Определив пару, как указано выше, зададим соответствующие операции извлечения компонент пары как:

$$\begin{array}{r l}{\operatorname{fst}\,p}&{{}\triangleq\quad p{\mathrm{~true}}}\\ {\operatorname{snd}\,p}&{{}\triangleq\quad p{\mathrm{~false}}}\end{array}$$
Легко убедиться, что эти определения работают, как требуется:

$$\begin{array}{r c l}{{\mathrm{fst}\;(p,q)}}&{{=}}&{{(p,q)\;\mathrm{true}}}\\ {{}}&{{=}}&{{(\lambda f.\;f\;p\;q)\;\mathrm{true}}}\\ {{}}&{{=}}&{{\mathrm{true}\;p\;q}}\\ {{}}&{{=}}&{{(\lambda x\;y.\;x)\;p\;q}}\\ {{}}&{{=}}&{{p}}\end{array}$$
Глава 3. Лямбда-исчисление как язык программирования
3.1. Представление данных в лямбда-исчислении и

$$\begin{array}{r c l}{{\mathrm{snd}\;(p,q)}}&{{=}}&{{(p,q)\;\mathrm{false}}}\\ {{}}&{{=}}&{{(\lambda f.\;f\;p\;q)\;\mathrm{false}}}\\ {{}}&{{=}}&{{\mathrm{false}\;p\;q}}\\ {{}}&{{=}}&{{(\lambda x\;y.\;y)\;p\;q}}\\ {{}}&{{=}}&{{q}}\end{array}$$
Построение троек, четвёрок, пятёрок и так далее вплоть до кортежей произвольной длины n производится композицией пар:

$$(E_{1},E_{2},\ldots,E_{n})=(E_{1},(E_{2},\ldots E_{n}))$$
Всё, что нам при этом потребуется - определение, что инфиксный оператор запятая правоассоциативен. Дальнейшее понятно без введения дополнительных соглашений. Например:

$$\begin{array}{r c l}{{(p,q,r,s)}}&{{=}}&{{(p,(q,(r,s)))}}\\ {{}}&{{=}}&{{\lambda f.\;f\;p\;(q,(r,s))}}\\ {{}}&{{=}}&{{\lambda f.\;f\;p\;(\lambda f.\;f\;q\;(r,s))}}\\ {{}}&{{=}}&{{\lambda f.\;f\;p\;(\lambda f.\;f\;q\;(\lambda f.\;f\;r\;s))}}\\ {{}}&{{=}}&{{\lambda f.\;f\;p\;(\lambda g.\;g\;q\;(\lambda h.\;h\;r\;s))}}\end{array}$$
В последнем выражении для удобства восприятия было произведено альфапреобразование. Несмотря на то, что кортежи представляют собой «плоскую» структуру данных, путём последовательной их композиции возможно представить произвольную конечную древовидную структуру. Наконец, если кто-то предпочитает традиционные функции, заданные на декартовом произведении, нашим каррированным функциям, преобразовать их друг в друга нетрудно:

$$\begin{array}{r l}{\mathrm{CURRY}\ f}&{{}\ \stackrel{\triangle}{=}\ \ \lambda x\ y.\ f(x,y)}\\ {\mathrm{UNCURY}\ g}&{{}\ \stackrel{\triangle}{=}\ \ \lambda p.\ g\ (\mathrm{fst}\ p)\ (\mathrm{snd}\ p)}\end{array}$$
Эти специальные операции над парами нетрудно обобщить на случай кортежей произвольной длины n. Например, мы можем задать функцию-селектор выборки i-го компонента из кортежа p. Обозначим эту операцию (p)i, и определим её как (p)1 = fst p, (p)i = fst (sndi−1 p). Аналогичным образом возможно обобщение CURRY и UNCURRY:

$\begin{array}{ccccc}\mbox{CURRY}_{n}&f&\stackrel{{\triangle}}{{=}}&\lambda x_{1}&\cdots&x_{n}.&f(x_{1},\ldots,x_{n})\\ \mbox{UNCURRY}_{n}&g&\stackrel{{\triangle}}{{=}}&\lambda p.&g&(p)_{1}&\cdots&(p)_{n}\end{array}$
Воспользуемся обозначением λ(x1, . . . , xn). t как сокращённой формой записи для UNCURRYn (λx1 · · · xn. t), обеспечив тем самым естественную нотацию для функций над декартовыми произведениями.

3.1. Представление данных в лямбда-исчислении Глава 3. Лямбда-исчисление как язык программирования

## 3.1.3 Натуральные Числа

Представим натуральное число n в виде3

$$n\ {\stackrel{\triangle}{=}}\ \lambda f\ x.\ f^{n}\ x,$$
то есть, 0 = *λf x. x*, 1 = *λf x. f x*, 2 = λf x. f (f x) и т. д. Такое представление получило название *нумералов Чёрча,* хотя его базовая идея была опубликована ранее Витгенштейном [64].4 Это представление не слишком эффективно, так как фактически представляет собой запись чисел в системе счисления по основанию 1: 1, 11, 111,
1111, 11111, 111111, *. . .*. С точки зрения эффективности можно разработать гораздо лучшие формы представления, к примеру, кортеж логических значений, который интерпретируется как двоичная запись числа. Впрочем, в данный момент нас интересует лишь принципиальная вычислимость, а нумералы Чёрча имеют различные удобные формальные свойства. Например, легко привести лямбда-выражения такой общеизвестной арифметической операции, как получение числа, следующего в натуральном ряду за данным, то есть, прибавление единицы к аргументу операции:

$${\mathrm{SUC}}\ {\stackrel{\triangle}{=}}\ \lambda n\ f\ x.\ n\ f\ (f\ x)$$
В самом деле,

$$\begin{array}{l l l}{{\mathrm{SUC}\;n}}&{{=}}&{{(\lambda n\;f\;x.\;n\;f\;(f\;x))(\lambda f\;x.\;f^{n}\;x)}}\\ {{}}&{{=}}&{{\lambda f\;x.\;(\lambda f\;x.\;f^{n}\;x)f\;(f\;x)}}\\ {{}}&{{=}}&{{\lambda f\;x.\;(\lambda x.\;f^{n}\;x)(f\;x)}}\\ {{}}&{{=}}&{{\lambda f\;x.\;f^{n}\;(f\;x)}}\\ {{}}&{{=}}&{{\lambda f\;x.\;f^{n+1}\;x}}\\ {{}}&{{=}}&{{n+1}}\end{array}$$
Аналогично, легко реализуется проверка числа на равенство нулю:

ISZERO $n\stackrel{{\triangle}}{{=}}n$ ($\lambda x.$ false) true

IIOCKOJbKy

ISZERO $0=(\lambda f\ x.\ x)(\lambda x.$ false) true = true
и

$$\begin{array}{rcl}\mbox{ISZERO}(n+1)&=&(\lambda f\ x.\ f^{n+1}x)(\lambda x.\ \mbox{false})\mbox{true}\\ &=&(\lambda x.\ \mbox{false})^{n+1}\ \mbox{true}\\ &=&(\lambda x.\ \mbox{false})((\lambda x.\ \mbox{false})^{n}\ \mbox{true})\\ &=&\mbox{false}\end{array}$$
Сумма и произведение двух нумералов Чёрча:

$$m+n\ \ \stackrel{{\triangle}}{{=}}\ \ \ \lambda f\ x.\ m\ f\ (n\ f\ x)$$

$$m*n\ \ \stackrel{{\triangle}}{{=}}\ \ \ \lambda f\ x.\ m\ (n\ f)\ x$$

${}^{3}$Jamce, nupaxeniorn $f^{n}$ x c napaxenprox n pimaxelnerenz nachar xazu yazu6c7na acima, a ne n curly erro luz.nucr.

${}^{4}$Cot. ${}^{4}$Cot. ${}^{4}$Cot.

Глава 3. Лямбда-исчисление как язык программирования
3.1. Представление данных в лямбда-исчислении В справедливости этих определений легко убедиться:

$$\begin{array}{l l l}{{m+n}}&{{=}}&{{\lambda f\ x.\,m\ f\ (n\ f\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(\lambda f\ x.\,f^{m}\ x)\ f\ (n\ f\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(\lambda x.\,f^{m}\ x)\ (n\ f\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m}\ (n\ f\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m}\ ((\lambda f\ x.\,f^{n}\ x)\ f\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m}\ ((\lambda x.\,f^{n}\ x)\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m}\ (f^{n}\ x)}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m+n}x}}\end{array}$$
и

$$\begin{array}{l l l}{{m*n}}&{{=}}&{{\lambda f\ x.\,m\ (n\ f)\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(\lambda f\ x.\,f^{m}\ x)\ (n\ f)\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(\lambda x.\,(n\ f)^{m}\ x)\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(n\ f)^{m}\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,((\lambda f\ x.\,f^{n}\ x)\ f)^{m}\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,((\lambda x.\,f^{n}\ x)^{m}\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,(f^{n})^{m}\ x}}\\ {{}}&{{=}}&{{\lambda f\ x.\,f^{m n}x}}\end{array}$$
Несмотря на то, что эти операции на натуральных числах были определены достаточно легко, вычисление числа, предшествующего данному, гораздо сложнее. Нам требуется выражение PRE такое, что PRE 0 = 0 и PRE (n + 1) = n. Оригинальное решение этой задачи было предложено Клини [33]. Пусть для заданного λf x. f n x требуется «отбросить» одно из применений f. В качестве первого шага введём на множестве пар функцию PREFN такую, что PREFN f (true, x) = (false, x)
и PREFN f (false, x) = (false*, f x*)
Предположив, что подобная функция существует, можно показать, что (PREFN f)n+1(true, x) = (false, f n x). В свою очередь, этого достаточно, чтобы задать функцию PRE, не испытывая особых затруднений. Определение PREFN, удовлетворяющее нашим нуждам, таково:
PREFN
△
= *λf p.* (false, if fst p then snd p else f(snd p)
В свою очередь, PRE n
△
= *λf x.* snd(n (PREFN f) (true, x))
3.2. Рекурсивные функции Глава 3. Лямбда-исчисление как язык программирования

## 3.2 Рекурсивные Функции

Возможность определения рекурсивных функций является краеугольным камнем функционального программирования, поскольку в его рамках это единственный общий способ реализовать итерацию. На первый взгляд, сделать подобное средствами лямбда-исчисления невозможно. В самом деле, *именование* функций представляется непременной частью рекурсивных определений, так как в противном случае неясно, как можно сослаться на функцию в её собственном определении, не зацикливаясь. Тем не менее, существует решение и этой проблемы, которое, однако, удалось найти лишь ценой значительных усилий, подобно построению функции PRE.

Ключом к решению оказалось существование так называемых комбинаторов неподвижной точки. Замкнутый терм Y называется комбинатором неподвижной точки, если для произвольного терма f выполняется равенство f(Y f) = *Y f*. Другими словами, комбинатор неподвижной точки определяет по заданному терму f его фиксированную точку, т. е. находит такой терм x, что f(x) = x. Первый пример такого комбинатора, найденный Карри, принято обозначать Y . Своим появлением он обязан парадоксу Рассела, чем объясняется его другое популярное название - «парадоксальный комбинатор». Мы определили

$$R=\lambda x.\;\lnot(x\;x),$$
после чего обнаружили справедливость

$$R\;R=\lnot(R\;R)$$
Таким образом, *R R* представляет собой неподвижную точку операции отрицания. Отсюда, чтобы построить универсальный комбинатор неподвижной точки, нам потребуется лишь обобщить данное выражение, заменив ¬ произвольной функцией, заданной аргументом f. В результате мы получаем

$$Y\stackrel{\triangle}{=}\lambda f.\;(\lambda x.\;f(x\;x))(\lambda x.\;f(x\;x))$$
Убедиться в справедливости этого определения несложно:

$$\begin{array}{r c l}{{Y f}}&{{=}}&{{(\lambda f.\;(\lambda x.\;f(x\;x))(\lambda x.\;f(x\;x)))\;f}}\\ {{}}&{{=}}&{{(\lambda x.\;f(x\;x))(\lambda x.\;f(x\;x))}}\\ {{}}&{{=}}&{{f((\lambda x.\;f(x\;x))(\lambda x.\;f(x\;x)))}}\\ {{}}&{{=}}&{{f(Y\;f)}}\end{array}$$ $$T\triangleq(\lambda x\;y.\;y\;(x\;x\;y))\;(\lambda x\;y.\;y\;(x\;x\;y))$$
(Доказательство справедливости T f −
→f(T f) предоставляется читателю в качестве упражнения.) Однако, мы можем без особого ущерба для строгости изложения считать, что *Y f* может подвергаться бета-редукции в соответствии с последовательностью редукции для рекурсивных функций. Рассмотрим, как комбинатор Глава 3. Лямбда-исчисление как язык программирования
3.3. LET-выражения неподвижной точки (например, Y ) может применяться для реализации рекурсии.

Воспользуемся в качестве примера вычислением факториала. Мы хотим определить функцию fact следующим образом:
fact(n) = if ISZERO n then 1 else n ∗fact(PRE n)
Прежде всего, преобразуем эту функцию в эквивалентную:
fact = *λn.* if ISZERO n then 1 else n ∗fact(PRE n)
которая, в свою очередь, эквивалентна fact = (*λf n.* if ISZERO n then 1 else n ∗f(PRE n)) fact Отсюда следует, что fact представляет собой неподвижную точку такой функции F:

## F = *Λf N.* If Iszero N Then 1 Else N ∗F(Pre N)

В результате всё, что нам потребуется, это положить fact = *Y F*. Аналогичным способом можно воспользоваться и в случае взаимно рекурсивных функций, т. е. множества функций, определения которых зависят друг от друга. Такие определения, как

f1
    =
       F1 f1 · · · fn
f2
    =
       F2 f1 · · · fn
. . .
    =
       . . .
fn
    =
       Fn f1 · · · fn

могут быть при помощи кортежей преобразованы в одно:

(f1, f2, . . . , fn) = (F1 f1 · · · fn, F2 f1 · · · fn, . . . , Fn f1 · · · fn)

  Положив t = (f1, f2, . . . , fn), видим, что каждая из функций в правой части равен-
ства может быть вычислена по заданному t применением соответствующей функции-
селектора: fi = (t)i. Применив абстракцию по переменной t, получаем уравнение в
канонической форме t = F t, решением которого является t = Y F, откуда в свою
очередь находятся значения отдельных функций.

## 3.3 Let-Выражения

Возможность использования безымянных функций была нами ранее преподнесена как одно из достоинств лямбда-исчисления. Более того, имена оказались необязательными даже при определении рекурсивных функций. Однако, зачастую всё же удобно иметь возможность давать выражениям имена с тем, чтобы избежать утомительного повторения больших термов. Простая форма такого именования может быть реализована как ещё один вид синтаксической глазури поверх чистого лямбдаисчисления:
let x = s in t
△
= (λx. t) s Глава 3. Лямбда-исчисление как язык программирования Простой пример применения этой конструкции работает, как и ожидается:

$$(\mathrm{let}\,\,z=2+3\,\,\mathrm{in}\,\,z+z)=(\lambda z.\,z+z)\,\,(2+3)=(2+3)+(2+3)$$
Мы можем добиться как последовательного, так и параллельного связывания множества имён с выражениями. Первый случай реализуется простым многократным применением конструкции связывания, приведённой выше. Во втором случае введём возможность одновременного задания множества связываний, отделяемых друг от друга служебным словом and:
let x1 = s1 and *· · ·* and xn = sn in t Будем рассматривать эту конструкцию как синтаксическую глазурь для
(λ(x1, . . . , xn). t) (s1*, . . . , s*n)
Продемонстрируем различия в семантике последовательного и параллельного связывания на примере:
let x = 1 in let x = 2 in let y = x in x + y и let x = 1 in let x = 2 and y = x in x + y дают в результате 4 и 3 соответственно.

В дополнение к этому разрешим связывать выражения с именами, за которыми следует список параметров; такая форма конструкции let представляет собой ещё
одну разновидность синтаксической глазури, позволяющую трактовать f x1 *· · ·* xn =
t как f = λx1 · · · xn. t. Наконец, помимо префиксной формы связывания let x =
s in t введём постфиксную, которая в некоторых случаях оказывается удобнее для восприятия:
t where x = s Например, мы можем написать так: *y < y*2 where y = 1 + x.

Обычно конструкции let и where интерпретируются, как показано выше, без привлечения рекурсии. Например, let x = x −1 in · · ·
связывает x с уменьшенным на единицу значением, которое уже было связано с именем x в охватывающем контексте, а не пытается найти неподвижную точку выражения x = x −1.5 В случае, когда нам требуется рекурсивная интерпретация, это может быть указано добавлением служебного слова rec в конструкции связывания (т. е. использованием let rec и where rec соответственно). Например, let rec fact(n) = if ISZERO n then 1 else n ∗fact(PRE n)
Это выражение может считаться сокращённой формой записи let fact = *Y F*, где F = *λf n.* if ISZERO n then 1 else n ∗f(PRE n), как было показано выше.

рассматривается в работах Барендрегта [5] и Абрамски [2].

Глава 3. Лямбда-исчисление как язык программирования
3.4. Достижение уровня полноценного языка программирования

## 3.4 Достижение Уровня Полноценного Языка Программирования

На данный момент мы ввели достаточно обширный набор средств «синтаксической глазировки», реализующих удобочитаемый синтаксис поверх чистого лямбдаисчисления. Примечательно, что этих средств достаточно для определения функции факториала в форме, очень близкой к языку ML. В связи с этим возникает вопрос, уместно ли считать лямбда-исчисление, расширенное предложенными обозначениями, практически пригодным языком программирования?

В конечном счёте, программа представляет собой единственное выражение. Однако, использование let для именования различных важных подвыражений, делает вполне естественной трактовку программы как множества *определений* различных вспомогательных функций, за которыми следует итоговое выражение, например:
let rec fact(n) = if ISZERO n then 1 else n ∗fact(PRE n) in
· · ·
fact(6)
Эти определения вспомогательных функций могут трактоваться с математической точки зрения как уравнения. Подобная интерпретация не задаёт никаких ограничений ни на способ вычисления выражений, ни даже направление, в котором уравнения будут использоваться. Благодаря этому, функциональный подход к программированию часто называют *декларативным* наряду с логическим (примером последнего служит язык PROLOG).6 В рамках такого подхода программа не содержит явных инструкций, а лишь объявляет некоторые свойства соответствующих понятий, оставляя подробности своего выполнения компьютеру.

В то же время, программа бесполезна или, по крайней мере, неоднозначна, если для неё не определены некоторые содержательные действия компьютера. Следовательно, требуется понимание того, что внешне полностью декларативная программа должна быть выполнена неким определённым образом. В самом деле, вычисление выражения начинается с раскрытия всех входящих в него имён определений (т. е. уравнения интерпретируются слева направо), после чего производится последовательность β-преобразований. Это значит, что несмотря на отсутствие процедурной информации в программе, неявно подразумевается наличие некоторой конкретной стратегии выполнения. Таким образом, понятие «декларативности» относится в большей степени к восприятию программ человеком.

Кроме того, должны существовать определённые правила, касающиеся стратегии редукции, поскольку выбор различных β-редексов, как мы знаем, может оказать решающее влияние на завершимость. Как следствие, полностью определённый язык программирования из лямбда-исчисления получается лишь тогда, когда мы зададим эту стратегию. В дальнейшем мы увидим, какие решения были приняты в ходе проектирования различных функциональных языков, но перед этим нам придётся
3.5. Дополнительная литература Глава 3. Лямбда-исчисление как язык программирования

## 3.5 Дополнительная Литература

Многие из упомянутых стандартных работ включают в себя подробный анализ вопросов, затронутых в этом разделе. В частности, М. Гордоном даётся строгое доказательство Тьюринг-полноты лямбда-исчисления, а также того, что задача проверки существования нормальной формы терма (аналог «проблемы останова» в лямбдаисчислении) алгоритмически неразрешима [27]. Влияние лямбда-исчисления на полноценные языки программирования, а также на эволюцию функциональных языков в частности обсуждается в работе Худака [31].

## Упражнения

1. Дайте обоснование «обобщённого β-преобразования», т. е. докажите, что
(λ(x1, . . . , xn). t[x1*, . . . , x*n])(t1*, . . . , t*n) = t[t1*, . . . , t*n]

2. Пусть f ◦g
△
= λx. f(g x). Приняв во внимание, что I = *λx. x*, докажите,
что CURRY ◦UNCURRY = I. Верно ли также, что UNCURRY ◦CURRY = I?
3. Какие арифметические операции соответствуют заданным на множестве нумералов Чёрча функциям λn f x. f(n f x) и *λm n. n m*?
4. (Клоп) Докажите, что следующее выражение представляет собой комбинатор
неподвижной точки:
££££££££££££££££££££££££££, где
£
△
= λabcdefghijklmnopqstuvwxyzr. r(*thisisafixedpointcombinator*)

5. Дайте рекурсивное определение операции вычитания натуральных чисел. 6. Пусть задано следующее представление списков [38]:

nil
=
λc n. n
cons
=
λx l c n. c x (*l c n*)
head
=
λl. l(*λx y. x*) nil
tail
=
λl. snd (l(*λx p.* (cons x (fst p), fst p)) (nil, nil))
append
=
λl1 l2. l1 cons l2
append_lists
=
λL. L append nil
map
=
λf l. l (λx. cons (f x)) nil
length
=
λl. l(λx. SUC)0
tack
=
λx l. l cons (cons x nil)
reverse
=
λl. l tack nil
filter
=
λl test. l (λx. (*test x*)(cons x)(*λy. y*)) nil

## Глава 4 Типы

Типы представляют собой удобное средство определения различных разновидностей данных, наподобие логических и целочисленных значений либо функций. Благодаря типизации оказывается возможным гарантировать соблюдение ограничений, порождаемых этими различиями (например, что функция не должна применяться к аргументам с неподходящими типами). Что побуждает нас ввести понятие типа в лямбда-исчисление и языки программирования на его основе? Основания для такого решения можно найти как в логике, так и в программировании.

С точки зрения логики, требуется преодолеть парадокс Рассела, который препятствует попыткам построить непротиворечивое расширение лямбда-исчисления теорией множеств. Источником противоречий служит необычная циклическая природа используемого при этом приёма - применение функции к самой себе. Более того, если бы даже и не требовалось избежать парадокса, всё равно возникает интуитивное ощущение неясности формальной системы, в рамках которой разрешены подобные действия. Безусловно, самоприменение таких функций, как тождественная функция (*λx. x*) и функция-константа (*λx. y*), выглядит безобидно. В то же время, очевидна и потребность в более ясном описании того, какие именно семейства функций представимы в терминах лямбда-исчисления при условии, что нам точно известны области определения и значений этих функций, а также то, что мы их применяем лишь к аргументам, принадлежащим соответствующим областям определения. Введение Расселом типов в своей работе *Principia Mathematica* было продиктовано приведёнными соображениями.

Ещё одной причиной, которая побуждает нас подробно рассмотреть возможность расширения лямбда-исчисления понятием типа, является применение типизации в других языках программирования. Понятие типов данных встречается уже в языке FORTRAN, в котором различаются целые числа и числа с плавающей точкой. Причины появления типов в данном контексте не были связаны с изложенными ранее аргументами из области логики. Одной из таких причин была, очевидно, эффективность порождаемого компилятором кода. Наличие информации о допустимых способах использования той или иной переменной позволяет как генерировать более эффективный код, так и рациональнее распределять память. Например, реализация адресной арифметики в духе языка C должна учитывать размер объектов, к которым происходит обращение. Если p представляет собой указатель на объект размером 4 байта, то выражение p + 1 при трансляции в машинный код на архитектурах с побайтовой адресацией памяти превращается в p + 4. Предшественник C, язык BCPL, был бестиповым, и в нём не делалось различий между целыми числами и указателями. Как следствие, соответствующие масштабирующие множители в каждой операции адресной арифметики задавались в программе явным образом, создавая тем самым существенные неудобства.

Дальнейшее развитие привело к тому, что типизация, оставаясь важным средством повышения эффективности, стала приобретать всё большее значение как инструмент ограниченной статической проверки корректности программ. Существенная доля ошибок, от очевидных опечаток до серьёзных концептуальных просчётов, проявляет себя нарушением правил типизации, благодаря чему эти ошибки могут быть выявлены непосредственно в ходе компиляции без запуска программы на исполнение. Более того, в ходе чтения исходных текстов типы зачастую играют роль документации. Наконец, типы данных могут применяться для улучшения модульности программ и скрытия информации при помощи таких определений различных структур данных, которые явно разделены на интерфейс и подробности реализации.

В то же время некоторые программисты выступают против использования типов, полагая, что для их стиля программирования ограничения, накладываемые типизацией, являются излишне утомительными. Как следствие, различается и уровень её поддержки языками программирования. Существуют бестиповые языки, как императивные (BCPL), так и функциональные (ISWIM, SASL и Erlang).1 Другие, подобно PL/I, имеют лишь *слабую типизацию,* которая допускает некоторые варианты совместного использования данных различных типов при помощи автоматических преобразований, реализуемых компилятором. Наконец, некоторые языки, такие как Lisp, осуществляют *динамический* контроль типов во время исполнения программы. Этот подход может, в принципе, существенно ухудшить производительность, поскольку требует дополнительных вычислительных ресурсов, подобно тому, как это происходит с другим известным источником накладных расходов - проверкой корректности обращений к массивам. Статическая же типизация, напротив, может заметно снизить издержки.2
На практике важность тех или иных ограничений типизации существенно зависит от характера решаемых задач и стиля программирования. Разработка системы типов, обеспечивающей как возможность содержательного статического контроля, так и достаточный уровень гибкости, остаётся предметом активных исследований. Типизация, реализованная в языке ML, представляет собой важное достижение, поскольку в ней допускается *полиморфизм*, благодаря которому одна и та же функция может применяться к аргументам различных типов. Такой подход сохраняет все выгоды сильной статической типизации, дополняя их некоторыми возможностями, присущими слабому или динамическому контролю типов.3 Более того, программист как правило не обязан указывать типы явно - транслятор ML способен самостоятельно вывести наиболее общий тип каждого выражения, отвергая те из них, которые не поддаются типизации. Роль полиморфизма в процессе вывода типов будет рассмотрена далее. Таким образом, несомненно, что система типов языка ML делает его подходящим инструментом для широкого класса задач. Тем не менее, мы не хотели бы создать у читателя ложного впечатления, что этот язык служит универсальным средством от всех проблем программирования.

## 4.1 Типизированное Лямбда-Исчисление

В первом приближении расширение лямбда-исчисления понятием типа не представляет особого труда, но в итоге, как будет показано, потребуется куда больше усилий. Основная идея состоит в том, что каждому терму назначается *тип*, после чего выражение *s t*, т. е. применение терма s к терму t, допустимо исключительно для совместимых типов, то есть в случае, когда типы s и t имеют вид σ →τ и σ соответственно. Результирующий терм будет иметь при этом тип τ. Такую типизацию принято называть *сильной.*4 Терм t *обязан* иметь тип σ, подтипы и преобразования не допускаются. Такой подход составляет резкий контраст с некоторыми языками программирования, например, с языком C, в котором функция, ожидающая аргумент типа float либо double, принимает также значения типа int, выполняя автоматическое преобразование. Аналогичные понятия подтипов и преобразований возможно задать и в рамках лямбда-исчисления, но их освещение завело бы нас слишком далеко.

Введём для отношения «t имеет тип σ» обозначение t : σ. Подобная запись традиционно используется математиками при работе с функциональными пространствами, поскольку f : σ →τ обозначает функцию f, отображающую множество σ во множество τ. Будем считать типы множествами, которые содержат соответствующие объекты, и трактовать t : σ как t ∈σ. Однако, несмотря на то, что мы предлагаем читателям также воспользоваться этой удобной аналогией, типизированное лямбдаисчисление будет в дальнейшем рассматриваться исключительно как формальная система, свободная от каких-либо интерпретаций.

## 4.1.1 Множество Допустимых Типов

Начнём формализацию строгим определением понятия типа. Предположим, что у нас имеется некоторое множество *примитивных типов,* в которое входят, например, типы bool и int. Составные типы могут быть определены при помощи конструктора типа функции. Формально, индуктивное определение множества типов TyC, основанного на множестве примитивных типов C, выглядит так:
σ ∈C
σ ∈TyC
σ ∈TyC
τ ∈TyC
σ →τ ∈TyC
Например, в рамках данного определения допустимы типы int, bool →*bool* либо (int →bool) →int →*bool*. Будем считать операцию «→» правоассоциативной, т. е. полагать выражение σ →τ →υ равным σ →(τ →υ). Такая трактовка естественно констант) так называемые *переменные типа,* которые впоследствии лягут в основу полиморфизма. Во-вторых, разрешим использование множества конструкторов других типов, помимо типа функции. Например, в дальнейшем нам понадобится конструктор × для типа декартова произведения. Как следствие, наше индуктивное определение должно быть дополнено ещё одним выражением:
σ ∈TyC
τ ∈TyC
σ × τ ∈TyC
Поскольку язык ML допускает определение пользователем новых типов и их конструкторов, нам потребуется нотация, пригодная для описания произвольного множества конструкторов с произвольным количеством аргументов. Обозначим через (α1, . . . , αn)con применение n-арного конструктора типа *con* к набору аргументов αi. (Инфиксная форма будет использоваться лишь в некоторых широко известных частных случаях наподобие →и ×.) Например, выражение (σ)*list* трактуется как тип-список, все элементы которого имеют тип σ.

Принимая во внимание *свободное* индуктивное порождение множества допустимых типов, можно доказать его важное свойство, а именно, что σ →τ ̸= σ. (В
действительности справедливо более общее утверждение: тип не может равняться произвольному собственному подвыражению.) Это свойство исключает возможность применения терма к самому себе, за исключением случая, когда оба экземпляра терма, о которых идёт речь, имеют различные типы.

## 4.1.2 Типизация По Чёрчу И Карри

Известны два основных подхода к определению типизированного лямбдаисчисления. Один из них, разработанный Чёрчем, подразумевает *явное* указание типов. Каждому терму при этом назначается единственный тип. Другими словами, в ходе построения термов каждому нетипизированному терму, которые были рассмотрены ранее, в дополнение указывается тип. Типы констант являются предопределёнными, но типы переменных могут быть произвольными. Точные правила построения типизированных термов приведены ниже:
v : σ
Константа c имеет тип σ
c : σ
s : σ →τ
t : σ
s t : τ
v : σ
t : τ
λv. t : σ →τ
Однако, для наших целей лучше подходит *неявная* типизация, предложенная Карри. Структура термов соответствует нетипизированному случаю, при этом терм может как иметь тип (причём не один), так и не иметь его.5 Например, тождественной функции *λx. x* может быть вполне обоснованно назначен произвольный тип вив пользу данного подхода к типизации. Во-первых, он позволяет удобнее выразить присущий ML полиморфизм, а во-вторых, хорошо согласуется с практикой программирования на этом языке, в ходе которого не требуется задавать типы явно.

В то же время, некоторые формальные аспекты назначения типов по Карри оказываются достаточно сложными. Отношение типизируемости не может быть задано в отрыве от некоторого *контекста,* представляющего собой конечное множество утверждений относительно типов переменных. Обозначим через

## Γ ⊢T : Σ

утверждение «в контексте Γ терму t может быть назначен тип σ». (Если это утверждение справедливо при пустом контексте, выражение сокращается до ⊢t : σ или даже до t : σ.) Элементы множества Γ имеют вид v : σ т. е. сами по себе являются утверждениями относительно типов отдельных переменных, обычно тех, которые входят в терм t. Будем полагать, что контекст Γ не содержит противоречивых утверждений о типе некоторой переменной; при желании, мы можем рассуждать о нём как о частичной функции, отображающей индексное множество переменных во множество типов. Использование нами символа ⊢соответствует его роли в традиционной логике, где Γ ⊢φ принято трактовать как «утверждение φ следует из множества посылок Γ».

## 4.1.3 Формальные Правила Типизации

Формулировка правил назначения типов выражениям достаточно естественна.

Прежде, чем мы приведём эти правила, напомним ещё раз, что t : σ следует интерпретировать как «t *может* иметь тип σ».

v : σ ∈Γ
Γ ⊢v : σ
Константа c имеет тип σ
c : σ
Γ ⊢s : σ →τ
Γ ⊢t : σ
Γ ⊢s t : τ
Γ ∪{v : σ} ⊢t : τ
Γ ⊢λv. t : σ →τ
Ещё раз повторим, что эти выражения следует понимать как индуктивное определение отношения типизируемости, так что терм может иметь тип лишь тогда, когда последний выводим при помощи упомянутых выше правил. В качестве примера рассмотрим процедуру вывода типа тождественной функции. Согласно правилу типизации переменных, мы имеем:

## {X : Σ} ⊢X : Σ

откуда, применив последнее правило, получаем:

## ∅⊢Λx. X : Σ →Σ

Применив установленное ранее соглашение о пустых контекстах, мы можем сократить это выражение до *λx. x* : σ →σ. На данном примере также хорошо видна как важная роль контекстов в типизации по Карри, так и их необязательность в рамках типизации по Чёрчу. Опуская контекст, мы можем вывести x : τ для произвольного типа τ, после чего, согласно последнему правилу, получаем *λx. x* : σ →τ —
налицо различие с интуитивной трактовкой тождественной функции! Эта проблема не возникает в ходе типизации по Чёрчу, поскольку в её рамках либо обе переменные имеют тип σ, откуда получаем *λx. x* : σ →σ, либо эти переменные на самом деле различны (поскольку различны их типы, которые считаются неотъемлемой частью терма). В последнем случае тип выражения в действительности будет равен λx : σ. (x : τ) : σ →τ, но это обосновано тем, что данное выражение альфаэквивалентно λx : σ. (y : τ) : σ →τ. Поскольку в ходе типизации по Карри термы не содержат в себе типов явно, нам требуется некоторый механизм связывания между собой одинаковых переменных.

## 4.1.4 Сохранение Типа

Очевидное сходство структуры термов типизированного и нетипизированного лямбда-исчисления порождает естественное желание применить в типизированном случае аппарат формальных преобразований, разработанный для нетипизированного. Однако, нам потребуется предварительно доказать, что тип выражения в ходе преобразований не изменяется (такое свойство называется *сохранением типа*). Убедиться в этом не представляет труда; мы рассмотрим краткое изложение доказательства для случая η-преобразования, предоставив остальные читателю в качестве упражнения. Прежде всего, докажем две леммы, которые весьма очевидны, но тем не менее, требуют формального обоснования. Во-первых, покажем, что добавление новых элементов в контекст не влияет на типизируемость:

Лемма 4.1 (О монотонности) Если Γ ⊢t : σ и Γ ⊆∆, то справедливо ∆⊢t : σ.
Доказательство: Применим индукцию по структуре t. Зафиксировав t, докажем
приведённое выше утверждение для всевозможных Γ и ∆, поскольку в ходе ша-
га индукции для абстракций эти множества изменяются. Если t - переменная,
справедливо t : σ ∈Γ, из чего следует и t : σ ∈∆, откуда получаем требуемое.
Если t - константа, желаемый вывод очевиден, поскольку множество констант
и их типов не зависит от контекста. В случае терма t, имеющего вид комбинации
термов s u, для некоторого типа τ выполняется Γ ⊢s : τ →σ и Γ ⊢u : τ. Согласно
индуктивному предположению, ∆⊢s : τ →σ и ∆⊢u : τ, откуда также полу-
чаем требуемое. Наконец, если терм t представляет собой абстракцию λx. s, то
согласно последнему правилу типизации σ имеет вид τ →τ ′, а также справедливо,
что Γ∪{x : τ} ⊢s : τ ′. Так как Γ ⊆∆, мы получаем Γ∪{x : τ} ⊆∆∪{x : τ}, откуда
по индуктивному предположению ∆∪{x : τ} ⊢s : τ ′. Применяя правило типизации
абстракций, получаем требуемое. □

Лемма 4.2 Если Γ ⊢t : σ, то справедливо также Γt ⊢t : σ, где Γt содержит исключительно свободные переменные терма t (Γt = {x : α | x : α ∈Γ и x ∈FV (t)}).

Доказательство: Аналогично предыдущей лемме, докажем наше утверждение для
произвольного контекста Γ и соответствующего ему Γt путём структурной ин-
дукции по t. Если t - переменная, то Γ ⊢t : σ требует наличия в контексте
элемента x : σ. Согласно первому правилу типизации {x : σ} ⊢x : σ, что и тре-
буется. Тип константы не зависит от контекста, так что лемма справедлива и
в этом случае. Если терм t представляет собой комбинацию термов вида s u, то
для некоторого τ справедливо Γ ⊢s : τ →σ и Γ ⊢u : τ. Согласно индуктивному
предположению, Γs ⊢s : τ →σ и Γu ⊢u : τ. Согласно лемме о монотонности,
получаем Γsu ⊢s : τ →σ и Γsu ⊢u : τ, поскольку FV (s u) = FV (s) ∪FV (u).
Применив правило вывода типа комбинации термов, получаем Γsu ⊢t : σ. Нако-
нец, если t имеет вид λx. s, это подразумевает Γ ∪{x : τ} ⊢s : τ ′, где σ имеет
форму τ →τ ′. Согласно индуктивному предположению, (Γ ∪{x : τ})s ⊢s : τ ′, от-
куда (Γ ∪{x : τ})s −{x : τ} ⊢(λx. s) : σ. Теперь нам требуется лишь отметить,
что (Γ ∪{x : τ})s −{x : τ} ⊆Γt и ещё раз применить лемму о монотонности. □

Приступим к доказательству основного результата этого раздела.

Теорема 4.3 (О сохранении типа) Если Γ ⊢t : σ и t −
                                               →
                                               η
                                                 t′, то из этого следует,

что Γ ⊢t′ : σ.
Доказательство: Поскольку по условию теоремы терм t является η-редексом, он
должен иметь структуру (λx. t x), причём x ̸∈FV (t). Следовательно, его тип
может быть выведен лишь из последнего правила типизации, при этом σ име-
ет вид τ →τ ′, и справедливо {x : τ} ⊢(t x) : τ ′. Дальнейший анализ требу-
ет применения правила вывода типа комбинаций. Поскольку контекст может
содержать не более одного утверждения о типе каждой переменной, справедли-
во {x : τ} ⊢t : τ →τ ′. Так как по условию x ̸∈FV (t), то применив лемму 4.2,
получаем ⊢t : τ →τ ′, что и требовалось. □

  Собрав воедино результаты аналогичных доказательств для других преобразо-
ваний, получаем, что если Γ ⊢t : σ и t −
                                       →t′, то выполняется также Γ ⊢t′ : σ.
Важность этого вывода в том, что если бы правила вычислений, применяемые в
ходе исполнения программы, могли изменять типы выражений, это подорвало бы
основы статической типизации.

## 4.2 Полиморфизм

Типизация по Карри предоставляет в наше распоряжение разновидность полиморфизма, позволяя назначить заданному терму различные типы. Следует различать схожие понятия полиморфизма и *перегрузки.* Оба они подразумевают, что выражение может иметь множество типов. Однако, в случае полиморфизма все эти типы структурно связаны друг с другом, так что допустимы любые из них, удовлетворяющие заданному образцу. Например, тождественной функции можно назначить тип σ →σ, или τ →τ, либо даже (σ →τ) →(σ →τ), но все они имеют одинаковую структуру. С другой стороны, суть перегрузки в том, что заданная функция может иметь различные типы, структура которых может различаться, либо же допустимо лишь ограниченное множество типов. Например функции + может быть позволено иметь тип int →int →int либо float →float →*float*, но не bool →bool →*bool*.6 Ещё
одним близким понятием являются подтипы, представляющие собой более жёсткую форму перегрузки. Введение подтипов позволяет трактовать некоторый тип как подмножество другого. Однако, этот подход на практике оказывается куда сложнее, чем кажется на первый взгляд.7

## 4.2.1 Проблемы Let-Полиморфизма

K cooksareunho, opredenimata baimo circelma Titiho hakelizkladarf hekotropie hekecelati-Teilho eopameneimata na mohimpoharm. Harnipar, chezyouve bekapazene afeondireito koppelvo:

$$\mbox{if}(\lambda x.\,x)\mbox{true then}(\lambda x.\,x)\mbox{1else}0$$
Докажем, что это выражение может быть типизировано согласно нашим правилам. Предположим, что константам можно назначить типы в пустом контексте, и что мы можем двукратно применить правило типизации комбинации термов для назначения типа if (принимая во внимание, что выражение вида if b then t1 else t2
является всего лишь сокращённой записью для COND *b t*1 t2).

{x : bool} ⊢x : bool

{x : int} ⊢x : int
⊢(*λx. x*) : bool →bool
⊢true : bool
⊢(*λx. x*) : int →int
⊢1 : int
⊢(*λx. x*) true : bool
⊢(*λx. x*) 1 : int
⊢0 : int
⊢if (*λx. x*) true then (*λx. x*) 1 else 0 : int

Два экземпляра тождественной функции получают типы bool →bool и int →int соответственно. Далее рассмотрим другое выражение:
let I = *λx. x* in if I true then I 1 else 0
Согласно нашим определениям, это всего лишь удобный способ записи для
(λI. if I true then I 1 else 0) (*λx. x*)
Нетрудно убедиться, что тип этого выражения не может быть выведен в рамках наших правил. Мы имеем *единственный* экземпляр тождественной функции, которому должны назначить единственный тип. Подобное ограничение на практике неприемлемо, поскольку функциональное программирование предполагает частое использование let. Если правила типизации не будут изменены, многие выгоды полиморфизма окажутся потерянными. Нашим решением будет отказ от трактовки конструкции let как сокращённой записи в пользу реализации её как примитива языка, после чего ко множеству правил типизации следует добавить новое правило:
Γ ⊢s : σ
Γ ⊢t[s/x] : τ
Γ ⊢let x = s in t : τ
или наоборот? В зависимости от конкретной ситуации, более предпочтительной оказывается либо первая, либо вторая интерпретация («ковариантность» либо «контравариантность» типов).

Это правило, которым вводится понятие let*-полиморфизма,* демонстрирует, что по крайней мере с точки зрения типизации, let-связанные переменные трактуются как простые подстановки соответствующих выражений вместо их имён. Дополнительная посылка Γ ⊢s : σ требуется исключительно для того, чтобы гарантировать существование корректного типа выражения s, причём точное значение этого типа нас не интересует. Цель данного ограничения в том, чтобы избежать ошибочных выводов о существовании корректных типов для таких термов, как let x = *λf. f f* in 0
Теперь мы в состоянии вывести тип нашего проблемного выражения, пользуясь приведёнными выше правилами:

$\begin{array}{c}\{x:\sigma\}\vdash x:\sigma\\ \vdash\lambda x.\ x:\sigma\rightarrow\sigma\end{array}$$\vdash$ if $(\lambda x.\ x)$ true then $(\lambda x.\ x)$ 1 else 0 : $int$

$\vdash$ let $I=\lambda x.\ x$ in if $I$ true then $I$ 1 else 0 : $int$

## 4.2.2 Наиболее Общий Тип

Как было сказано ранее, тип некоторых выражений, таких как *λf. f f* либо *λf.* (f true, f 1), вывести невозможно. Типизируемые выражения обычно имеют множество типов, хотя некоторые из них, например, *true* - в точности один.

Мы уже упоминали, что разновидность полиморфизма, доступная в языке ML, называется *параметрической,* т. е. всевозможные типы выражения должны обладать структурным подобием. Более того, для каждого типизируемого выражения существует так называемый *наиболее общий (главный) тип,* причём все возможные типы данного выражения представляют собой экземпляры наиболее общего типа. Прежде, чем изложить этот результат формально, введём некоторые термины.

Начнём с расширения определения типа, дополнив его понятием переменной типа. Это значит, что типы могут быть построены путём применения конструкторов типов как к типам-константам, так и к переменным. Будем использовать греческие буквы α и β для обозначения переменных типа, а σ и τ - произвольных типов. При помощи этой расширенной нотации мы в состоянии определить понятие подстановки типа в другой тип вместо переменной типа. Такая подстановка совершенно аналогична подстановке термов, так что мы даже будем использовать те же самые обозначения (например, (σ →*bool*)[(σ →τ)/σ] = (σ →τ) →*bool*). Однако, формальное определение подстановки типов проще, чем для термов, так как не требует учёта связывания переменных. Для удобства дальнейшего изложения расширим его на случай множественной параллельной подстановки:

$\alpha_{i}[\tau_{1}/\alpha_{1},\ldots,\tau_{n}/\alpha_{k}]=\tau_{i}$ if $\alpha_{i}\neq\beta$ for $1\leq i\leq k$

$\beta[\tau_{1}/\alpha_{1},\ldots,\tau_{n}/\alpha_{k}]=\beta$ if $\alpha_{i}\neq\beta$ for $1\leq i\leq k$

$(\sigma_{1},\ldots,\sigma_{n})con[\theta]=(\sigma_{1}[\theta],\ldots,\sigma_{n}[\theta])con$
Чтобы не загромождать определение, мы трактуем типы-константы как нульарные конструкторы типов, т. е. считаем ()int эквивалентным *int*; при желании можно легко вернуться к прежним обозначениям явным добавлением соответствующих частных случаев. Опираясь на приведённое определение подстановки, введём отношение «тип σ является *более общим,* чем тип σ′», обозначив его через σ ⪯σ′.8 Пара типов входит в данное отношение тогда и только тогда, когда найдётся множество подстановок θ такое, что σ′ = σθ. Например:

$$\begin{array}{r l}{\alpha}&{{}\preceq}&{\sigma}\\ {\alpha\to\alpha}&{{}\preceq}&{\beta\to\beta}\\ {\alpha\to b o o l}&{{}\preceq}&{(\beta\to\beta)\to b o o l}\\ {\beta\to\alpha}&{{}\preceq}&{\alpha\to\beta}\\ {\alpha\to\alpha}&{{}\not\preceq}&{(\beta\to\beta)\to\beta}\end{array}$$
С учётом изложенного выше, сформулируем основную теорему данного раздела:
Теорема 4.4 Каждый типизируемый терм имеет главный тип, т. е. для произвольного t : τ найдётся тип σ такой, что t : σ и для любого типа σ′ из t : σ′
следует σ ⪯σ′.

Легко убедиться, что отношение ⪯является отношением квазипорядка, то есть, рефлексивно и транзитивно. Главный тип не уникален, но при этом все его возможные формы равны с точностью до переименования входящих в них переменных типа. В более точной формулировке, если σ и τ являются одновременно главными типами выражения, то справедливо σ ∼τ, то есть σ ⪯τ и τ ⪯σ одновременно.

Доказательство теоремы о главном типе не требует особых усилий, но ввиду большого объёма в рамках данного курса не рассматривается. Следует лишь запомнить его основное свойство: процедура доказательства представляет собой конкретный алгоритм поиска такого типа. Этот алгоритм известен как *алгоритм Милнера,* либо, чаще, как алгоритм Хиндли-Милнера.9 Все реализации ML и некоторых других функциональных языков включают в себя некоторую разновидность этого алгоритма, благодаря чему для произвольных выражений автоматически выводится их главный тип либо устанавливается невозможность корректной типизации.

## 4.3 Сильная Нормализация

Обратимся вновь к нашим примерам термов, не имеющих нормальной формы, таким как

(($\lambda x.$$x$$x$$x$) ($\lambda x.$$x$$x$))

(($\lambda x.$$x$$x$$x$) ($\lambda x.$$x$$x$$x$))

($\cdots$)
на основании теоремы о *сильной нормализации,* доказательство которой слишком длинно, чтобы быть здесь приведённым.

Теорема 4.5 (О сильной нормализации) Любой типизируемый терм имеет нормальную форму, а любая возможная последовательность редукций, которая начинается с типизируемого терма, завершается.10
На первый взгляд преимущества очевидны - функциональная программа, удовлетворяющая нашей дисциплине типов, может вычисляться в произвольном порядке, при этом процесс редукции всегда конечен и приводит к единственной нормальной форме. (Единственность следует из теоремы Чёрча-Россера, которая остаётся справедливой и в случае типизированного лямбда-исчисления.) Однако, возможность реализации незавершимых функций необходима для обеспечения Тьюринг-полноты,11
в противном случае мы более не в состоянии определить произвольные вычислимые функции, более того - даже не всё множество всюду определённых функций.

Мы бы могли пренебречь этим ограничением, если бы оно позволяло нам использовать все функции, представляющие практический интерес. Однако, это не так - класс всевозможных функций, представимых в рамках типизированного лямбдаисчисления, оказывается весьма узким. Швихтенберг показал, что класс представимых функций на основе нумералов Чёрча ограничен всевозможными полиномами либо кусочными функциями на их основе [57]. Отметим, что этот результат имеет сугубо интенсиональную природу, то есть, определяется свойствами заданного представления чисел, а выбор другого представления ведет к другому классу функций. В любом случае, для универсального языка программирования этого недостаточно.

Поскольку все определимые функции являются всюду определёнными, мы, очевидно, не в состоянии давать произвольные рекурсивные определения. В самом деле, оказывается, что обычные комбинаторы неподвижной точки не поддаются типизации; очевидно, что тип Y = λf. (λx. f(x x))(λx. f(x x)) не существует, поскольку x применяется к самому себе, будучи связанным лямбда-абстракцией. Для восстановления Тьюринг-полноты введём альтернативный способ задания произвольных рекурсивных функций, не принося в жертву типизацию. Определим полиморфный оператор рекурсии, всевозможные типы которого имеют вид Rec : ((σ →τ) →(σ →τ)) →σ →τ
и дополнительное правило редукции, согласно которому для произвольной функции F : (σ →τ) →(σ →τ) мы имеем Rec F −
→F (*Rec F*)
Начиная с этого момента будем полагать, что рекурсивные определения вида let rec отображаются на эти операторы рекурсии.

## Дополнительная Литература

Типизированное лямбда-исчисление рассматривается, в числе прочего, Барендрегтом [5], Хиндли, Селдином [30]. Основополагающая работа Милнера [43] продолжает оставаться важным источником информации о полиморфной типизации в целом и алгоритме поиска главного типа в частности. Хорошее введение в типизированное лямбда-исчисление, включающее доказательство теоремы о сильной нормализации, а также обсуждение некоторых интересных взаимосвязей с логикой, даётся Жираром и др. [25]. В данной работе также обсуждается более развитая версия типизированного лямбда-исчисления под названием System F, в рамках которой возможно определение большинства требуемых на практике функций даже при сохранении свойства сильной нормализации.

## Упражнения

1. Справедливо ли, что из Γ ⊢t : σ для произвольной подстановки θ следует Γ ⊢
t : (σθ)?
2. Докажите формально теорему 4.3 о сохранении типа для α и β-преобразования.
3. Покажите, что свойство сохранения типа необратимо, т. е. что возможна ситуация, когда из справедливости t −
→t′ и Γ ⊢t′ : σ не следует, что Γ ⊢t : σ.
4. (*) Докажите, что каждый терм типизированного лямбда-исчисления, чей главный тип равен (α →α) →(α →α), редуцируется до нумерала Чёрча.
5. (*) В какой мере процесс проверки типов является обратимым, т. е. допускает
вывод терма по его типу? Например, справедливо ли, что в чистом типизированном лямбда-исчислении с переменными типа, но без констант и оператора
рекурсии, любое t : α →β →α на самом деле эквивалентно K = λx y. x
в традиционной трактовке лямбда-эквивалентности. Если это так, то каковы
дальнейшие возможности обобщения результата?12
6. (*) Будем говорить, что некоторое отношение редукции −
→обладает слабым
свойством Чёрча-Россера, если всякий раз, когда t −
→t1 и t −
→t2, найдётся u
такое, что t1 −
→∗u и t2 −
→∗u, где −
→∗представляет собой рефлексивное транзитивное замыкание −
→. Докажите *лемму Ньюмена*, в которой утверждается,
что если отношение обладает слабым свойством Чёрча-Россера и удовлетворяет
принципам сильной нормализации, то для −
→∗справедливо свойство Чёрча-
Россера. (Указание: воспользуйтесь трансфинитной индукцией.)13

## Глава 5 Знакомство С Ml

В предыдущих главах мы начали с чистого λ-исчисления, которое затем систематически расширяли новыми возможностями. Например, мы добавили примитивную конструкцию let, чтобы сделать полиморфную типизацию более полезной, а также оператор рекурсии для восстановления вычислительной полноты, потерянной после введения типов. Двигаясь дальше по этому пути, мы в конечном счёте приходим к ML, при этом сохранив простоту мировоззрения, сформированного в ходе изучения типизированного λ-исчисления.

Очередным этапом на этом пути будет отказ от представления данных (например, натуральных чисел и логических значений) в виде термов лямбда-исчисления и замена их примитивами, такими как типы bool (для логических значений) и int (для целых чисел). В дополнение, введём новые конструкторы типов, такие как ×, - желательность подобного шага уже упоминалась в предыдущей главе. С этими изменениями также связаны новые константы и новые правила преобразования. Например, выражение 2+2 будет вычисляться с использованием машинной арифметики вместо представления его в нумералах Чёрча и выполнения β-преобразований. Эти дополнительные преобразования, рассматриваемые как расширение обычных λ-операций, часто называются 'δ-преобразованиями'. В течение курса мы неоднократно увидим, чем язык ML отличается от чистого λ-исчисления. Первым делом обратимся к фундаментальному вопросу стратегии вычисления выражений в ML.

## 5.1 Энергичное Вычисление

Как уже было сказано ранее, с теоретической точки зрения нормальный порядок
(сверху вниз, слева направо) редукции выражений более предпочтителен, потому что если хоть какая-то стратегия завершается, то и эта тоже.1 Однако, такой подход имеет некоторые практические недостатки. Например, рассмотрим следующее выражение:

$$(\lambda x.\;x+x+x)\;(10+5)$$
При использовании нормального порядка редукции мы получаем (10 + 5) + (10 +
5)+(10+5), так что на следующих шагах мы должны вычислить одно и то же выра-
1Данная стратегия подобна некоторым, используемым в традиционных языках, таких как жение трижды. На практике это совершенно недопустимо. Существуют два основных решения данной проблемы, и эти решения делят мир функционального программирования на два лагеря.

Первое решение - придерживаться нормального порядка редукции, но при этом пытаться оптимизировать реализацию так, чтобы разнообразные подвыражения, возникающие при таком подходе, использовались совместно и никогда не вычислялись более одного раза. В самой реализации выражения представляются в виде ориентированных ациклических графов, а не в виде деревьев. Этот подход известен как ленивое (lazy) или *вызов по необходимости (call-by-need)* вычисление, поскольку выражения вычисляются только тогда, когда необходимо.

Вторым решением является попытка перевернуть с ног на голову теоретические размышления о стратегии редукции и вычислять аргументы функции до начала её собственного вычисления. Этот подход известен как *аппликативный порядок* или энергичное вычисление. Последнее имя возникло из-за того, что аргументы функции вычисляются даже тогда, когда они не нужны, например, t в (*λx. y*) t. Конечно, применение аппликативного порядка означает, что процесс вычисления некоторых выражений может зацикливаться, тогда как он завершается при работе в ленивом режиме. Но это считается допустимым, поскольку подобных ситуаций достаточно легко избежать на практике. В любом случае, стратегия энергичного вычисления является стандартной для многих языков программирования, таких как C, где её называют *вызов по значению (call by value)*.

ML использует энергичное вычисление по двум основным причинам. Управление редукцией и совместным использованием подвыражений, которое требуется при ленивом вычислении, является достаточно сложным, и реализация может быть относительно неэффективной и трудной. Если программист не проявит должной осторожности, то память может заполниться невычисленными выражениями, так что в общем случае оценить потребление памяти программой будет затруднительно. В действительности, многие реализации ленивого вычисления стараются оптимизировать его путём использования энергичного вычисления в тех местах, где семантика не отличается.2 В противоположность этому, в ML мы всегда сначала вычисляем аргументы функций, и только затем выполняем β-редукцию - это просто, эффективно и легко реализуется с использованием стандартных технологий построения компиляторов.

Второй причиной для выбора аппликативного порядка вычислений служит то, что ML не является *чистым* функциональным языком, а имеет императивные возможности (переменные, присваивание и т.п.). Следовательно, порядок вычисления подвыражений может изменить *семантику*, а не просто влияет на эффективность.

Если используется ленивое вычисление, то для программиста становится практически невозможным отчётливо представить (в нетривиальной программе) когда и какое подвыражение вычисляется. С другой стороны, в энергичной системе, подобной ML, достаточно лишь помнить соответствующие простые правила.

Однако, важно осознавать, что стратегия вычислений ML не просто редукция снизу вверх, в противоположность нормальному порядку. В действительности ML никогда не вычисляет содержимое λ*-абстракций*. (В частности, он никогда не редуцирует η-редексы, а только β-редексы.) При вычислении (*λx. s*[x]) t, сначала вычисляется t. Однако s[x] не затрагивается, поскольку оно является содержимым λ- абстракции. Кроме того, любое подвыражение t, которое является содержимым λ-
абстракции, также остаётся нетронутым. Вот точные правила вычисления:

- Константы вычисляются сами в себя. - Вычисления заканчиваются на λ-абстракциях, и не затрагивают их содержимого. В частности, не выполняется η-преобразование.
- При вычислении комбинации s t *сначала* вычисляются оба терма, s и t. Потом,
при условии что результатом вычисления s является λ-абстракция, производится самое внешнее β-преобразование, и процесс повторяется.
Порядок вычисления s и t отличается в зависимости от версии ML. В той версии, которую мы будем использовать, сначала всегда вычисляется t. Строго говоря, мы также должны задать правило для let-выражений, поскольку, как упоминалось, они теперь считаются примитивами. Однако, с точки зрения стратегии вычислений, они как и прежде могут рассматриваться как применение λ-абстракции к аргументу, который будет вычислен первым. Для того, чтобы сделать это явным, правило для let x = s in t гласит, что сначала вычисляются все s, а результат подставляется вместо x в t, после чего вычисляется новое значение t. Рассмотрим некоторые примеры вычисления выражений:

$(\lambda x.\ (\lambda y.\ y+y)\ x)(2+2)\ \ \longrightarrow\ \ (\lambda x.\ (\lambda y.\ y+y)\ x)4$

$\longrightarrow\ \ (\lambda y.\ y+y)4$

$\longrightarrow\ \ 4+4$

$\longrightarrow\ \ 8$
Заметим, что подтерм (λy. y + y) x *не редуцируется*, поскольку он находится в пределах λ-абстракции. Однако, редуцируемые термы, не находящиеся внутри λ- абстракций обоих функций, а также аргумент, редуцируются до того, как вычисляется применение функции, например, второй шаг будет следующим:

$\begin{array}{lll}\left(\left(\lambda f\ x.\ f\ x\right)\left(\lambda y.\ y+y\right)\right)\left(2+2\right)&\longrightarrow&\left(\left(\lambda f\ x.\ f\ x\right)\left(\lambda y.\ y+y\right)\right)\ 4\\ &\longrightarrow&\left(\lambda x.\left(\lambda y.\ y+y\right)\ x\right)\ 4\\ &\longrightarrow&\left(\lambda y.\ y+y\right)\ 4\\ &\longrightarrow&4+4\end{array}$
Тот факт, что ML не вычисляет содержимое λ-абстракций, является ключевым

## 5.2 Результаты Энергичного Вычисления

Использование энергичного вычисления заставляет нас объявить примитивами некоторые дополнительные языковые конструкции, определив для них специальные методы редукции, вместо того, чтобы реализовать их напрямую в терминах λ-исчисления. В частности, мы не можем больше рассматривать условную конструкцию

## If B Then E1 Else E2

как применение обычного трехкомпонентного (тернарного) оператора

## Cond *B E*1 E2

Причина заключается в том, что по правилам энергичного вычисления мы всегда должны вычислить все выражения, b, e1 и e2, до вычисления COND. Как правило, последствия этого фатальны. Например, заново рассмотрим наше определение функции вычисления факториала:

## Let Rec Fact(N) = If Iszero N Then 1 Else N ∗Fact(Pre N)

Если условное выражение будет вычислять все свои аргументы, то при вычислении fact(0), ветвь 'else' также должна быть вычислена, что в свою очередь вызывает вычисление fact(PRE 0). Но это также потребует вычисления fact(PRE (PRE 0)), и т.д. Соответственно, вычисление превратится в бесконечный цикл.

Таким образом, мы делаем условное выражение примитивной конструкцией и меняем обычную стратегию редукции так, что *сначала* вычисляется логическое выражение, а затем - *только одна* соответствующая ветвь условия.

А что происходит с самим процессом рекурсии? Мы предложили интерпретацию рекурсивных определений в терминах рекурсивного оператора *Rec* с его собственным правилом редукции:

## Rec F − →F(*Rec F*)

который также будет зацикливаться при использовании стратегии энергичного вычисления:

## Rec F − →F(Rec F) − →F(F(Rec F)) − →F(F(F(*Rec F*))) − →· · ·

Однако, достаточно лишь очень простого изменения правил редукции, чтобы решить эту проблему:

## Rec F − →F(*Λx. Rec F X*)

Теперь λ-абстракция в правой части правила означает, что *λx. Rec f x* вычисляется само в себя (то есть, не вычисляется вовсе), и только после того, как выражение было редуцировано в ходе подстановки этой λ-абстракции в терм f, вычисление продолжается.

## 5.3 Семейство Языков Ml

Мы говорили о 'ML' так, как будто это один язык. На самом деле существует много вариантов ML, в том числе и 'Lazy ML' - реализация университета Chalmers в Швеции, которая базируется на ленивых вычислениях. Наиболее популярная версия ML в образовании - это 'Standard ML', но мы будем использовать другую, которая называется CAML ('camel') Light.3 Мы выбрали CAML Light по следующим причинам:
- реализация имеет небольшой объём и хорошо переносима между платформами, так что она эффективно работает на Unix, PC, Mac, и других.

- Система очень проста синтаксически и семантически, что делает её достаточно
простой для изучения.
- Система хорошо подходит для практического использования. Например, она
имеет интерфейс к библиотекам на языке C и поддерживает стандартную раздельную компиляцию, совместимую с make.
Однако, мы будем изучать достаточно общие техники, так что любой написанный код может быть запущен (с небольшими синтаксическими изменениями) на любой версии ML, и часто, на других функциональных языках.

## 5.4 Запуск Ml

ML уже установлен на рабочий сервер (Thor). Для того, чтобы использовать его, вам необходимо добавить каталог с исполняемыми файлами CAML в переменную среды PATH. Это может быть сделано следующим образом (предполагая, что вы используете командный процессор bash или другой из его семейства):
PATH="$PATH:/home/jrh13/caml/bin"
export PATH
Чтобы не вводить эти команды при каждом входе на сервер, вы можете вставить их в конец вашего файла .bash_profile или его эквивалента для вашего командного процессора. Теперь, для использования CAML в интерактивном режиме, вам просто надо набрать camllight, и программа должна запуститься и выдать приглашение ('#'):
$ camllight >
Caml Light version 0.73
#
Для того, чтобы выйти из системы, просто наберите ctrl/d или quit();; в строке ввода. Если вы заинтересованы в установке CAML Light на ваш собственный компьютер, то вы должны прочитать следующую Web-страницу для получения подробной информации:
http://pauillac.inria.fr/caml/

## 5.5 Взаимодействие С Ml

Когда ML выдаст вам строку приглашения, вы можете вводить выражения, завершённые двумя последовательными знаками "точка с запятой". Принято говорить, что ML находится в режиме диалога (который также имеет жаргонное название REPL, read-eval-print loop): выражения считываются, вычисляются и выводятся результаты. Например, ML может быть использован как простой калькулятор:
#10 + 5;; - : int = 15
Система не только возвращает ответ, но также выдаёт *тип* выражения, который определяется автоматически. Система может сделать это, поскольку знает тип встроенного оператора сложения +. С другой стороны, если для выражения не может быть определён тип, то система отвергнет его и постарается выдать сообщение о том, почему произошла ошибка. В сложных случаях сообщения об ошибках достаточно тяжело понять.

#1 + true;;
Toplevel input:
>let it = 1 + true;;
>
             ^^^^
This expression has type bool,
but is used with type int.

Поскольку ML является функциональным языком, то выражения могут иметь функциональный тип. Для λ-абстракций *λx. t*[x] ML предоставляет следующий синтаксис - fun x -> t[x]. Например, мы можем определить функцию вычисления целого числа, следующего за данным:
#fun x -> x + 1;; - : int -> int = <fun>
Как и в предыдущем примере, тип выражения (сейчас это int -> int), выводится и выдаётся на экран. Однако сама функция не печатается; система лишь выдаёт
<fun>. Это сделано потому, что внутреннее представление функций не слишком читабельно.4 Функции применяются к следующим за ними аргументам, так же как и в
λ-исчислении. Например:
#(fun x -> x + 1) 4;; - : int = 5
Подобно λ-исчислению, применение функции левоассоциативно, так что вы можете определять каррированные функции, используя то же самое соглашение по сокращению повторяющихся λ-абстракций (т.е., fun-й). Например, все следующие выражения эквивалентны:

#((fun x -> (fun y -> x + y)) 1) 2;;
- : int = 3
#(fun x -> fun y -> x + y) 1 2;;
- : int = 3
#(fun x y -> x + y) 1 2;;
- : int = 3

## 5.6 Связывания И Объявления

Вводить большое выражение целиком утомительно, гораздо удобнее будет воспользоватся let для связывания осмысленных подвыражений с именами. Это может быть сделано следующим образом:
#let successor = fun x -> x + 1 in successor(successor(successor 0));;
- : int = 3
Для связывания функций существует более элегантная конструкция:
#let successor x = x + 1 in successor(successor(successor 0));; - : int = 3
в том числе для рекурсивных определений, дополненных ключевым словом rec:

#let rec fact n = if n = 0 then 1
                 else n * fact(n - 1) in
fact 6;;
- : int = 720

Используя and, мы можем сделать несколько связываний одновременно и задать взаимно рекурсивные функции. Вот пример двух простых, хотя и сильно неэффективных, функций, которые определяют, является ли натуральное число чётным или нечётным:

#let rec even n = if n = 0 then true else odd (n - 1)
    and odd n
               = if n = 0 then false else even (n - 1);;
even : int -> bool = <fun>
odd : int -> bool = <fun>
#even 12;;
- : bool = true
#odd 14;;
- : bool = false

В действительности, любое связывание может быть сделано отдельно от его применения. ML помнит набор связанных переменных, и пользователь может пополнять данный набор интерактивно. Просто уберите in и завершите выражение двойной точкой с запятой:
#let successor = fun x -> x + 1;; successor : int -> int = <fun>
После этого объявления, любое последующее выражение может использовать функцию successor, например:
#successor 11;; - : int = 12
Заметьте, что мы не делаем *присваивания* значений *переменным*. Каждое связывание выполняется только раз, когда система анализирует введённые данные; оно не может быть повторено или изменено. Оно может быть перезаписано новым определением с тем же именем, но это не присваивание, в своём обычном значении, поскольку последовательность событий связана только с процессом *компиляции*, а не с динамикой *выполнения* программы. Конечно, отходя от интерактивного получения ответа от системы, мы можем полностью заменить все двойные точки с запятой, записанные после объявлений, на in и вычислить всё сразу. С этой точки зрения видно, что переписывание объявления в действительности соответствует определению новой локальной переменной, которая скрывает предыдущую, в соответствии с обычными правилами λ-исчисления. Например:

#let x = 1;;
x : int = 1
#let y = 2;;
y : int = 2
#let x = 3;;
x : int = 3
#x + y;;
- : int = 5

является тем же самым, что и:

#let x = 1 in
let y = 2 in
let x = 3 in
x + y;;
- : int = 5

  Обратим внимание, что согласно принципам λ-исчисления связывание перемен-
ных является статическим, например, первое связывание x используется до того,
как будет сделано новое, но и после этого предыдущие вхождения данного имени не
изменятся. Например:

#let x = 1;;
x : int = 1
#let f w = w + x;;
f : int -> int = <fun>
#let x = 2;;
x : int = 2
#f 0;;
- : int = 1

  Первые версии LISP, однако, практиковали динамическое связывание, когда пе-
реопределение переменной также распространялось на предыдущие использования
этой переменной, так что аналогичная последовательность команд должна будет вер-
нуть число 2. В действительности это считалось ошибкой, но скоро программисты
начали использовать эту возможность. Как следствие, когда некоторая низкоуров-
невая функция изменялась, то изменения распространялись на все её применения в
других функциях без необходимости перекомпиляции. Такая возможность продол-
жала существовать долгое время во многих диалектах LISP, но в конечном счёте
победила идея, что статическое связывание лучше. В Common LISP по умолчанию
используется статическое связывание, но динамическое также можно разрешить, ес-
ли необходимо, используя ключевое слово special.

## 5.7 Полиморфные Функции

Мы можем определять полиморфные функции, например, тождественное отображение:
#let I = fun x -> x;; I : 'a -> 'a = <fun>
Внешнее представление в ASCII-кодировке типовых переменных α, β, . . . в ML
имеет вид 'a, 'b, . . . Пример использования полиморфной функции с разными типами:

#I true;;
- : bool = true
#I 1;;
- : int = 1
#I I I I 12;;
- : int = 12

  В данном примере все вхождения I имеют различные типы и интуитивно соот-
ветствуют разным функциям. Очередным этапом будет определение всех базовых
комбинаторов:

#let I x = x;;
I : 'a -> 'a = <fun>
#let K x y = x;;
K : 'a -> 'b -> 'a = <fun>
#let S f g x = (f x) (g x);;
S : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c = <fun>

   Заметьте, что система сама следит за типами, несмотря на то, что в последнем
случае они были довольно сложными. Теперь, вспомним, что I = S K K; давайте
попробуем сделать это на ML:5

#let I' = S K K;;
I' : '_a -> '_a = <fun>

Выражение имеет правильный тип6 и может быть легко проверено на конкретных
случаях, например:

#I' 3 = 3;;
- : bool = true

  В приведённых примерах полиморфных функций система очень быстро выво-
дит наиболее общий тип для каждого выражения, и этот тип достаточно прост. Так
обычно и происходит на практике, но существуют патологические случаи, например,
следующий пример, приведённый в [37]. Тип этого выражения выводится около 10
секунд и занимает более 4000 строк на 80-символьном терминале.

let
    pair x y = fun z −> z x y in
let x1 = fun y −> pair y y in
let x2 = fun y −> x1 ( x1 y) in
let x3 = fun y −> x2 ( x2 y) in
let x4 = fun y −> x3 ( x3 y) in
let x5 = fun y −> x4 ( x4 y) in
x5 (fun z −> z ) ; ;

  Мы уже упоминали, что программисты на ML никогда не задают типы. Это вер-
но в том смысле, что транслятор ML сам назначит выражению наиболее общий тип.
Однако, иногда бывает полезно ограничить вывод типа. Подобная мера не заставит
работать код, который до этого не работал, но может использоваться как докумен-
тация для понимания его предназначения; также возможно использовать более ко-
роткие синонимы для сложных типов. Ограничение типа может быть задано в ML
путём добавления аннотации типа после некоторого выражения. Аннотации типов
состоят из двоеточия, за которым указан тип. Обычно расположение аннотаций не
имеет значения; если они есть, то они заставляют использовать соответствующие
ограничения. Например, вот несколько альтернативных вариантов явного назначе-
ния тождественной функции типа int -> int:

#let I (x:int) = x;;
I : int -> int = <fun>
#let I x = (x:int);;
I : int -> int = <fun>
#let (I:int->int) = fun x -> x;;
I : int -> int = <fun>
#let I = fun (x:int) -> x;;
I : int -> int = <fun>
#let I = ((fun x -> x):int->int);;
I : int -> int = <fun>

## 5.8 Равенство Функций

Вместо проверки эквивалентности функций, таких как I и I′, сравнением результатов их применения к конкретным аргументам, например 3, может показаться, что мы можем разрешить данный вопрос путём сравнения самих функций. Однако, это не работает:
#I' = I;; Uncaught exception: Invalid_argument "equal: functional value"

#let f x = x + 1;;
f : int -> int = <fun>
#let g x = x + 1;;
g : int -> int = <fun>
#f = f;;
- : bool = true
#f = g;;
Uncaught exception: Invalid_argument "equal: functional value"
#let h = g;;
h : int -> int = <fun>
#h = f;;
Uncaught exception: Invalid_argument "equal: functional value"
#h = g;;
- : bool = true

Почему существуют эти ограничения? Разве в ML функции не равноправны с другими разновидностями данных? Да, но к сожалению, (экстенсиональное) равенство функций в общем случае невычислимо. Это следует из различных классических результатов теории алгоритмов, таких как неразрешимость проблемы останова и теорема Райса.7 Приведём конкретный пример, демонстрирующий эту неразрешимость.

На данный момент для функции, определённой ниже, так и не установлено, завершается ли её вычисление для произвольного аргумента. Предположение, что данная функция вычислима всюду, известно как *гипотеза Коллатца (Collatz conjecture)*:8

#let rec collatz n =
  if n <= 1 then 0
  else if even(n) then collatz(n / 2)
  else collatz(3 * n + 1);;
collatz : int -> int = <fun>

   С другой стороны, очевидно, что в случае завершения вычислений их результатом
всегда будет 0. Теперь рассмотрим следующую тривиальную функцию:

#let f (x:int) = 0;;
f : int -> int = <fun>

  Решив уравнение collatz = f, компьютер подтвердил бы гипотезу Коллатца.
Похожие примеры также легко построить на основе других математических задач,
решение которых пока не найдено.
  Процедура контроля типов может быть расширена таким образом, что позво-
лит выявлять без выполнения программы попытки сравнения как элементарных
объектов-функций, так и объектов-агрегатов, в состав которых входят объекты-
функции. Типы данных, в которые не входят подвыражения типа функция, известны
как сравнимые типы, поскольку всегда возможно проверить объекты таких типов
на равенство. В то же время, это делает систему типов более сложной. Однако, сто-
ронники такого подхода придерживаются мнения, что статическая проверка типов
должна быть настолько полной, насколько это возможно.

## Дополнительная Литература

Многие книги о функциональном программировании содержат информацию по общим для всех функциональных языков аспектам, которые мы тоже обсуждали, например, по стратегии вычислений. Хорошее элементарное введение в CAML Light и функциональное программирование можно найти в [40]. Учебник [47] также хорош, но в его основе лежит другой диалект - Standard ML.

## Примеры

1. Предположим, что 'функция-условие', определённая ite(b,x,y) = if b then
x else y является единственной функцией, которая может работать с аргументами типа bool. Существует ли способ написать функцию факториала?
2. Докажите при помощи правил типизации, приведённых в предыдущей главе,
что комбинатор S имеет в точности тот тип, который выводит для него ML.
3. Напишите простую рекурсивную функцию возведения в степень целых чисел, т.е. вычисляющую xn для n ≥0. Напишите на ML пару функций, из эквивалентности которых следовала бы справедливость Великой теоремы Ферма: не существует целых чисел x, y, z и натурального числа *n >* 2 таких, что xn + yn = zn, за исключением тривиального случая, когда x = 0 или y = 0.

## Глава 6 Более Подробно О Ml

В этой главе мы закрепим предыдущие примеры, уточним синтаксис и основные возможности ML, а затем рассмотрим некоторые дополнительные возможности, такие как рекурсивные типы. Удачным началом обсуждения может стать вопрос взаимодействия с системой.

До сих пор мы вводили команды в интерпретатор одну за другой, получая от него поочередно результат каждой из них. Однако, это не лучший способ писать нетривиальные программы. Общепринятой практикой является размещение всех выражений и объявлений в файле. Чтобы тестировать их по мере ввода, можно воспользоваться операцией «вырезать и вставить», которая доступна в X Window System и её аналогах, или в редакторе типа Emacs. Такой подход, однако, с ростом объема программ становится всё утомительнее и неэффективнее. Вместо этого возможно использовать функцию include для непосредственного чтения из файла. Например, если файл myprog.ml содержит:
let pythag x y z =
x ∗x + y ∗y = z ∗z ; ;
pythag 3 4
5 ; ;
pythag 5 12
1 3 ; ;
pythag 1 2
3 ; ;
то введя в интерпретатор include "myprog.ml";; получаем:

#include "myprog.ml";;
pythag : int -> int -> int -> bool = <fun>
- : bool = true
- : bool = true
- : bool = false
- : unit = ()

  Как видим, реакция ML-системы была точно такой же, как если бы мы ввели
содержимое файла с консоли. Последняя строка вывода - это результат вычисления
самого выражения include.
  Большие программы часто полезно снабжать комментариями. В ML они ограни-
чиваются символами (* и *), например:

6.1. Основные типы данных и операции Глава 6. Более подробно о ML

(∗−
     −
      −
        −
         −
           −
            −
              −
               −
                −
                  −
                   −
                     −
                      −
                        −
                         −
                           −
                            −
                              −
                               −
                                 −
                                  −
                                    −
                                     −
                                       −
                                        −
                                          −
                                           −
                                             −
                                              −
                                               −
                                                 −
                                                  −
                                                    −
                                                     −
                                                       −
                                                        −
                                                          −
                                                           −
                                                             −
                                                              −
                                                                −
                                                                 −
                                                                   −
                                                                    −
                                                                      −
                                                                       −
                                                                         −
                                                                          −
                                                                           −
                                                                             −
                                                                              −
                                                                                −
                                                                                 −∗)
(∗This
           function
                         t e s t s
                                  i f
                                      (x , y , z )
                                                  i s
                                                      a Pythagorean
                                                                           t r i p l e
                                                                                     ∗)
(∗−
     −
      −
        −
         −
           −
            −
              −
               −
                −
                  −
                   −
                     −
                      −
                        −
                         −
                           −
                            −
                              −
                               −
                                 −
                                  −
                                    −
                                     −
                                       −
                                        −
                                          −
                                           −
                                             −
                                              −
                                               −
                                                 −
                                                  −
                                                    −
                                                     −
                                                       −
                                                        −
                                                          −
                                                           −
                                                             −
                                                              −
                                                                −
                                                                 −
                                                                   −
                                                                    −
                                                                      −
                                                                       −
                                                                         −
                                                                          −
                                                                           −
                                                                             −
                                                                              −
                                                                                −
                                                                                 −∗)

let
    pythag x y z =
    x ∗x + y ∗y = z ∗z ; ;

(∗comments∗) pythag (∗can ∗) 3 (∗go ∗) 4 (∗almost ∗) 5 (∗anywhere ∗)
(∗and (∗can (∗be (∗
                                 nested
                                            ∗)
                                                q ui t e
                                                         ∗)
                                                             a r b i t r a r i l y
                                                                               ∗) ∗) ; ;

## 6.1 Основные Типы Данных И Операции

ML представляет несколько встроенных примитивных типов. Из них, с помощью конструкторов типов, могут быть построены составные типы. Пока мы будем использовать только конструктор функциональных типов -> и конструктор декартова произведения типов *. Впоследствии мы рассмотрим и другие конструкторы, а также узнаем как определять новые типы и конструкторы типов. Примитивные типы, которые нас интересуют:

- Тип unit, который также можно называть процедурным. Множество допустимых значений этого типа содержит единственный элемент, который обозначается (). Очевидно, использование типа unit не передаёт какой-либо информации, так что он часто используется как возвращаемый тип императивных
«функций», таких как include, результат которых - не вычисленное значение, а какой-либо побочный эффект. Он также может использоваться как тип функции, используемой для приостановки вычислений.
- Тип bool. Двухэлементный тип булевых значений (значений истинности). Элементы этого типа: true и false.
- Тип int. Содержит конечное подмножество отрицательных и неотрицательных чисел. Обычно значения варьируются от −230 (−1073741824) до 230 −1
(1073741823). 1 Элементы записываются обычным способом, например: 0, 32,
-25.
- Тип string содержит строки (т.е. конечные последовательности) символов. Они
записываются и печатаются в двойных кавычках, вот так: "hello". Для записи
специальных символов используется экранирование в стиле языка С. Например, \" - двойная кавычка, \n - символ перевода строки.
Значения, такие как (), false, 7 и "caml", с точки зрения лямбда-исчисления считаются константами. Другие константы соответствуют *операциям* над основными типами. Некоторые из них традиционно записываются в инфиксной форме. Для операций определено понятие приоритета, поэтому выражения группируются ожидаемым образом. Например, мы пишем x + y вместо + x y и x < 2 * y + z вместо < x
(+ (* 2 y) z). Логический оператор not отличается особым правилом разбора, в силу чего не обладает обычным свойством левой ассоциативности: not not p означает not (not p). Функцию, определённую пользователем, можно задать как инфиксную с помощью директивы #infix. Например, вот определение функции, выполняющей композицию функций:

#let
   successor x = x + 1 ; ;
successor
       :
         int −> int = <fun>
#let o f g = fun x −> f ( g x ) ; ;
o
 :
   ( ' a −> 'b) −> ( ' c −> ' a ) −> ' c −> 'b = <fun>
#let add3 = o successor
                 ( o successor
                           successor ) ; ;
add3
   :
     int −> int = <fun>
#add3
    0 ; ;
−:
   int = 3
#
#infix "o" ; ;
#let add3 ' = successor o successor o successor ; ;
add3 '
    :
      int −> int = <fun>
#add3 '
     0 ; ;
−:
   int = 3

  В ML отсутствует возможность задавать приоритеты пользовательских инфикс-
ных операций, а также менять порядок применения обычных пользовательских
функций на правоассоциативный. Отметим, что неявная операция «применение
функции» имеет приоритет выше, чем у любой другой бинарной операции, так что
successor 1 * 2 разбирается как (successor 1) * 2. Если хотите использовать
функцию с особым статусом как обычную константу, вам потребуется предварить
её имя словом prefix:

#o successor successor;;
Toplevel input:
>o successor successor;;
>^
Syntax error.
#prefix o successor successor;;
- : int -> int = <fun>
#(prefix o) successor successor;;
- : int -> int = <fun>

  Разобравшись с этими деталями синтаксиса, рассмотрим список операций над
основными типами. Унарные операции:

| Оператор             | Тип          |
|----------------------|--------------|
| -                    | int -> int   |
| Смена знака числа    |              |
| not                  | bool -> bool |
| Логическое отрицание |              |
| Оператор              | Тип                        |
|-----------------------|----------------------------|
| mod                   | int -> int -> int          |
| Остаток от деления    |                            |
| *                     | int -> int -> int          |
| Произведение          |                            |
| /                     | int -> int -> int          |
| Целочисленное деление |                            |
| +                     | int -> int -> int          |
| Сложение              |                            |
| -                     | int -> int -> int          |
| Вычитание             |                            |
| ^                     | string -> string -> string |
| Конкатенация строк    |                            |
| =                     | 'a -> 'a -> bool           |
| Равенство             |                            |
| <>                    | 'a -> 'a -> bool           |
| Неравенство           |                            |
| <                     | 'a -> 'a -> bool           |
| Меньше чем            |                            |
| <=                    | 'a -> 'a -> bool           |
| Меньше или равно      |                            |
| >                     | 'a -> 'a -> bool           |
| Больше чем            |                            |
| >=                    | 'a -> 'a -> bool           |
| Больше или равно      |                            |
| &                     | bool -> bool -> bool       |
| Логическое «и»        |                            |
| or                    | bool -> bool -> bool       |
| Логическое «или»      |                            |

Например, x > 0 & x < 1 соответствует & (> x 0) (< x 1). Заметим, что не только равенство, но и все прочие отношения полиморфны. Они упорядочивают должным образом не только числа и строки, но также и остальные примитивные и составные типы. Однако, они в общем случае не применимы к функциям.

Две логические операции, & и or, имеют особую стратегию вычисления. В сущности, их можно рассматривать как синонимы условных выражений:
p & q
△
=
if p then q else false p or q
△
=
if p then true else q Следовательно, операция «and» вычисляет первый аргумент, и только если его значение true, вычисляет следующий. Напротив, «or» вычисляет первый аргумент, и только если это false, вычисляет второй.

Выражения в ML строятся из констант и переменных; любой идентификатор, не связанный в данном месте программы, рассматривается как переменная. Объявления связывают значения выражений с именами, при этом в состав выражений могут входить другие объявления. Следовательно, синтаксические классы выражений и объявлений взаимно рекурсивны. Мы можем выразить это следующей БНФ-
грамматикой:2

| expression                  |
|-----------------------------|
| |                           |
| constant                    |
| |                           |
| expression expression       |
| |                           |
| expression infix expression |
| |                           |
| not                         |
| expression                  |
| |                           |
| if                          |
| expression                  |
| then                        |
| expression                  |
| else                        |
| expression                  |
| |                           |
| fun                         |
| pattern                     |
| →                           |
| expression                  |
|
(*expression*)
|
declaration in expression
declaration
::=
let let_bindings
|
let rec let_bindings
let_bindings
::=
let_binding
|
let_*binding* and let_bindings
let_binding
::=
pattern = expression
pattern
::=
variables
variables
::=
variable
|
variable variables

Позднее мы уточним определение и подробнее обсудим синтаксический класс *pattern*, а на данный момент нам будет достаточно лишь конструкций вида *variable* или variable variable · · · *variable*. В первом случае мы просто связываем выражение с именем, тогда как во втором для объявления функций используется специальный синтаксический сахар. Аргументы функции записываются вслед за её
именем, слева от знака равенства. Например, объявление функции add4, которая может использоваться для прибавления 4 к своему аргументу, имеет вид:

#let add4 x =
 let y = successor x in
 let z = let w = successor y in
         successor w in
 successor z;;
add4 : int -> int = <fun>
#add4 1;;
- : int = 5

Полезно будет в качестве упражнения провести разбор этого объявления в соответствии с приведённой выше грамматикой, к которой для определённости требуется добавить начальное правило (аксиому). Будем считать, что последовательность символов, завершающаяся двойной точкой с запятой, может быть как выражением, так и объявлением.

## 6.2 Дальнейшие Примеры

Несложно задать рекурсивную функцию, принимающую в качестве аргументов целое число n и функцию f, а возвращающую f n, т.е. f *◦· · · ◦*f (n раз):

#let rec funpow n f x =
  if n = 0 then x
  else funpow (n - 1) f (f x);;
funpow : int -> ('a -> 'a) -> 'a -> 'a = <fun>

Нетрудно убедиться в том, что функция funpow принимает машинное целое n и возвращает нумерал (число) Чёрча, который его представляет. Поскольку функции не выводятся на печать, мы не сможем увидеть, как на самом деле выглядят лямбдавыражения, соответствующие числам Чёрча:
#funpow 6;; - : ('_a -> '_a) -> '_a -> '_a = <fun>
Так же просто задаётся функция, обратная к funpow, которая принимает число Чёрча и возвращает машинное целое:

#let defrock n = n (fun x -> x + 1) 0;;
defrock : ((int -> int) -> int -> 'a) -> 'a = <fun>
#defrock(funpow 32);;
- : int = 32

Проверим некоторые из арифметических операций на числах Чёрча:

#let add m n f x = m f (n f x);;
add : ('a -> 'b -> 'c) -> ('a -> 'd -> 'b) -> 'a -> 'd -> 'c = <fun>
#let mul m n f x = m (n f) x;;
mul : ('a -> 'b -> 'c) -> ('d -> 'a) -> 'd -> 'b -> 'c = <fun>
#let exp m n f x = n m f x;;
exp : 'a -> ('a -> 'b -> 'c -> 'd) -> 'b -> 'c -> 'd = <fun>
#let test bop x y = defrock (bop (funpow x) (funpow y));;
test :
((('a -> 'a) -> 'a -> 'a) ->
 (('b -> 'b) -> 'b -> 'b) -> (int -> int) -> int -> 'c) ->
 int -> int -> 'c = <fun>
#test add 2 10;;
- : int = 12
#test mul 2 10;;
- : int = 20
#test exp 2 10;;
- : int = 1024

Подобная реализация арифметики, очевидно, не отличается эффективностью.

Рассмотрим в качестве очередного примера операцию возведения в степень. Она отсутствует в ML по умолчанию, но её просто определить рекурсивно:

#let rec exp x n =
 if n = 0 then 1
 else x * exp x (n - 1);;
exp : int -> int -> int = <fun>

  Эта реализация требует для вычисления xn выполнения n операций умножения.
Более эффективный алгоритм использует тот факт, что x2n = (xn)2 и x2n+1 = x(xn)2:

#let square x = x * x;;
square : int -> int = <fun>
#let rec exp x n =
 if n = 0 then 1
 else if n mod 2 = 0 then square(exp x (n / 2))
 else x * square(exp x (n / 2));;
exp : int -> int -> int = <fun>
#infix "exp";;
#2 exp 10;;
- : int = 1024
#2 exp 20;;
- : int = 1048576

Другая классическая операция над натуральными числами - поиск наибольшего общего делителя при помощи алгоритма Евклида:

#let rec gcd x y =
    if y = 0 then x else gcd y (x mod y);;
gcd : int -> int -> int = <fun>
#gcd 100 52;;
- : int = 4
#gcd 7 159;;
- : int = 1
#gcd 24 60;;
- : int = 12

  Мы применяли воображаемый оператор рекурсии Rec при объяснении рекурсив-
ных определений. Его можно реализовать и на практике:

#let rec Rec f = f(fun x -> Rec f x);;
Rec : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
#let fact = Rec (fun f n -> if n = 0 then 1 else n * f(n - 1));;
fact : int -> int = <fun>
#fact 3;;
it : int = 6

  Обратите внимание на необходимость анонимной функции, в противном случае
выражение Rec f уходит в бесконечную последовательность рекурсивных вызовов,
прежде чем функция будет применена к своему аргументу:

#let rec Rec f = f(Rec f);;
Rec : ('a -> 'a) -> 'a = <fun>
#let fact = Rec (fun f n -> if n = 0 then 1 else n * f(n - 1));;
Uncaught exception: Out_of_memory

## 6.3 Определения Типов

Мы уже говорили о том, что ML имеет возможность объявления новых конструкторов типов, так что составные типы могут быть построены на базе существующих. В действительности, ML позволяет еще больше: определение составного типа может также включать сам этот тип. Подобные типы называются *рекурсивными*. Они объявляются с помощью ключевого слова type, за которым следует выражение, определяющее тип на основе уже заданных типов, включая его самого. Продемонстрируем применение этой конструкции на нескольких примерах. Первым из них будет определение типа *sum*, которые должен соответствовать несвязному объединению (⊔) двух существующих типов.

#type ('a,'b)sum = inl of 'a | inr of 'b;; Type sum defined.

Грубо говоря, объект типа ('a,'b)sum является *либо* чем-то типа 'a, *либо* чемто типа 'b. Однако, говоря более формально, все эти объекты имеют разные типы.

Объявление типа также определяет так называемые *конструкторы* inl и inr. Это функции, реализующие инъективные отображения множеств значений типов компонентов во множество значений нового типа. В этом нетрудно убедиться на практике, рассмотрев тип этих функций, выведенный ML-системой, и результаты их применения к различным объектам:

#inl;;
- : 'a -> ('a, 'b) sum = <fun>
#inr;;
- : 'a -> ('b, 'a) sum = <fun>
#inl 5;;
- : (int, 'a) sum = inl 5
#inr false;;
- : ('a, bool) sum = inr false

  Мы можем продемонстрировать данную ситуацию с помощью следующей диа-
граммы. Тип (α, β)sum создаётся на основе существующих типов α и β, а принад-
лежащие этому типу значения представляют собой ни что иное, как пару значений
типа α и β соответственно. Конструкторы типа sum отображают в него значения
исходных типов, помещая их в нужный элемент пары.

$$(\alpha,\beta)sum$$
Этот тип данных аналогичен конструкции union языка C, но в ML компоненты различных типов хранятся отдельно, причём всегда можно точно установить, какой именно из них определяет тип конкретного экземпляра объединения. В противоположность этому, в языке C элементы объединения перекрываются в памяти, а обеспечение корректной работы с ними возлагается всецело на программиста.

## 6.3.1 Сопоставление С Образцом

Приведённое определение конструкторов наделяет их тремя очень важными качествами:

- Множество конструкторов является исчерпывающим, т.е. каждый элемент нового типа может быть получен либо из некоторого x при помощи конструктора inl x, либо из некоторого y при помощи inr y. Таким образом, экземпляр
нового типа не содержит ничего, кроме экземпляров типов компонент.
- Они являются инъективными, т.е. равенство inl x = inl y справедливо если,
и только если x = y (то же свойство имеет место и для inr). Таким образом,
экземпляр нового типа содержит точные копии экземпляров типа каждого компонента, не нарушая определённого для них понятия эквивалентности.
- Они индивидуальны, т.е. их диапазоны несвязны. Это означает, что в предыдущем примере равенство inl x = inr y будет ложным независимо от того, чем
являются x и y. Таким образом, компоненты различных типов в составе нового
Второе и третье свойство конструкторов лежат в основе техники сопоставления с образцом. Аргументы λ-выражений при этом имеют более сложный вид, соответствующий их структуре, например:
#fun (inl n) -> n > 6
| (inr b) -> b;;
- : (int, bool) sum -> bool = <fun>
Эта функция имеет вполне ожидаемое свойство: когда она применяется к inl n она возвращает n > 6, а когда она применяется к inr b, то она возвращает b. Именно благодаря второму и третьему свойствам конструкторов такое определение функции будет корректным. Поскольку конструкторы являются инъективными, мы можем точно восстановить n из inl n и b из inr b, а их индивидуальность обеспечивает непротиворечивость выбора из двух альтернатив, поскольку никакое значение не может соответствовать обоим образцам одновременно.

Наконец, исчерпывающее множество конструкторов гарантирует, что каждое значение аргумента соответствует одному из образцов, а функция будет всюду определённой. На практике разрешается ослабить это свойство, опустив некоторые образцы, но при этом ML-система выдаст предупреждение:

#fun (inr b) -> b;;
Toplevel input:
>fun (inr b) -> b;;
>^^^^^^^^^^^^^^^^
Warning: this matching is not exhaustive.
- : ('a, 'b) sum -> 'b = <fun>

Если эта функция применяется к значению вида inl x, то она не будет работать:

#let f = fun (inr b) -> b;;
Toplevel input:
>let f = fun (inr b) -> b;;
>
        ^^^^^^^^^^^^^^^^
Warning: this matching is not exhaustive.
f : ('a, 'b) sum -> 'b = <fun>
#f (inl 3);;
Uncaught exception: Match_failure ("", 452, 468)

  Хотя логический тип уже доступен в ML по умолчанию, его можно с тем же
успехом определить при помощи достаточно простого рекурсивного типа, часто на-
зываемого перечислимым типом, конструкторы которого не имеют аргументов:

#type bool = false | true;;

   В самом деле, вполне допустимо использовать в образцах логические значения.
Следующие два выражения полностью эквивалентны:

#if 4 < 3 then 1 else 0;;
- : int = 0
#(fun true -> 1 | false -> 0) (4 < 3);;
- : int = 0

Однако, сопоставление с образцом, которое оказывается очень удобным средством определения действий над вариантами рекурсивных типов, этим не ограничивается.

Например, мы можем задать функцию, которая сообщает нам, является ли число нулём, следующим образом:

#fun 0 -> true | n -> false;;
- : int -> bool = <fun>
#(fun 0 -> true | n -> false) 0;;
- : bool = true
#(fun 0 -> true | n -> false) 1;;
- : bool = false

В этом случае мы не имеем взаимной исключительности образцов, поскольку 0
соответствует им обоим. Образцы проверяются по порядку, один за другим, и используется первый подходящий. Заметим, что пока соответствие не является взаимно исключающим, нет гарантии, что каждое выражение содержит математическое уравнение. Так, в предыдущем примере функция не возвращает false для любого n, поэтому второе выражение не всюду корректно.

Отметим, что только *конструкторы* могут использоваться в приведённых выше выражениях как компоненты образцов. Обычные константы будут рассматриваться как новые переменные, связанные внутри образца. Например, рассмотрим следующий код:

#let true_1 = true;;
true_1 : bool = true
#let false_1 = false;;
false_1 : bool = false
#(fun true_1 -> 1 | false_1 -> 0) (4 < 3);;
Toplevel input:
>(fun true_1 -> 1 | false_1 -> 0) (4 < 3);;
>
                   ^^^^^^^
Warning: this matching case is unused.
- : int = 1

В общем, элемент типа unit (), логические значения, целые числа, строковые константы и операция образования пар (infix comma) имеют статус конструкторов, также как и другие конструкторы из предопределённых рекурсивных типов. Когда они встречаются в образце, сопоставляемое значение должно иметь соответствующий тип. Все другие идентификаторы соответствуют любому выражению и становятся связанными в процессе обработки.

Помимо указания образцов в λ-выражениях, существуют другие способы выполнения сопоставления с ними. Вместо определения функции, включающего сопоставление, и применения её к выражению, мы можем выполнять сопоставление с образцом напрямую, используя следующую конструкцию:
match *expression* with pattern1−>E1 | · · · | patternn−>En В простейшем случае достаточно ограничиться let pattern = expression

## 6.3.2 Рекурсивные Типы

Предыдущие примеры рекурсивных типов не слишком оправдывали своё название, поскольку их определения не ссылались на себя. В качестве более интересного примера рассмотрим тип списков 3 элементов типа 'a.

#type ('a)list = Nil | Cons of 'a * ('a)list;; Type list defined.

Проверим типы конструкторов:

#Nil;;
- : 'a list = Nil
#Cons;;
- : 'a * 'a list -> 'a list = <fun>

  Конструктор Nil, не принимающий никаких аргументов, просто создаёт неко-
торый объект типа ('a)list, который рассматривается как пустой список. Другой
конструктор, Cons, принимает аргументы типа 'a и ('a)list, а возвращает новый
список, который образован из предыдущего добавлением в начало первого элемента.
Например:

#Nil;;
- : 'a list = Nil
#Cons(1,Nil);;
- : int list = Cons (1, Nil)
#Cons(1,Cons(2,Nil));;
- : int list = Cons (1, Cons (2, Nil))
#Cons(1,Cons(2,Cons(3,Nil)));;
- : int list = Cons (1, Cons (2, Cons (3, Nil)))

  Поскольку конструкторы по определению инъективны и индивидуальны, легко
понять, что все значения, которые мы рассматривали как списки [], [1], [1; 2] и [1; 2; 3],
различны. Также из этих свойств конструкторов следует, что списки произвольной
длины могут быть представлены значениями нашего типа. Фактически, ML уже име-
ет тип list, точно такой, как только что был определён. Единственная разница в
синтаксисе: пустой список обозначается [], а рекурсивный конструктор :: - инфикс-
ный. Следовательно, все упомянутые списки в действительности записываются:

#[];;
- : 'a list = []
#1::[];;
- : int list = [1]
#1::2::[];;
- : int list = [1; 2]
#1::2::3::[];;
- : int list = [1; 2; 3]

#let hd (h::t) = h;;
Toplevel input:
>let hd (h::t) = h;;
>
    ^^^^^^^^^^^^^
Warning: this matching is not exhaustive.
hd : 'a list -> 'a = <fun>
#let tl (h::t) = t;;
Toplevel input:
>let tl (h::t) = t;;
>
    ^^^^^^^^^^^^^
Warning: this matching is not exhaustive.
tl : 'a list -> 'a list = <fun>

  Компилятор предупреждает нас, что применение этих функций к пустым спискам
приведёт к ошибкам. Посмотрим на них в действии:

#hd [1;2;3];;
- : int = 1
#tl [1;2;3];;
- : int list = [2; 3]
#hd [];;
Uncaught exception: Match_failure

Обратите внимание, следующее определение hd не является корректным. В действительности, функция принимает в качестве аргумента список ровно из двух аргументов, а на списках иной длины не определена:

#let hd [x;y] = x;;
Toplevel input:
>let hd [x;y] = x;;
>
    ^^^^^^^^^^^^
Warning: this matching is not exhaustive.
hd : 'a list -> 'a = <fun>
#hd [5;6];;
- : int = 5
#hd [5;6;7];;
Uncaught exception: Match_failure

   Сопоставление с образцом может комбинироваться с рекурсией. Например, функ-
ция, возвращающая длину списка, выглядит так:

#let rec length =
  fun [] -> 0
    | (h::t) -> 1 + length t;;
length : 'a list -> int = <fun>
#length [];;
- : int = 0
#length [5;3;1];;
- : int = 3

В качестве альтернативы можно задать её с помощью функций hd и tl:

#let rec length l =
  if l = [] then 0
  else 1 + length(tl l);;

  Последний стиль определения функции весьма распространён во многих языках,
особенно в LISP, но применение сопоставления с образцом часто бывает более эле-
гантно.

## 6.3.3 Древовидные Структуры

Нередко полезно наглядное представление значений рекурсивных типов в виде деревьев с узлами, образованными применением рекурсивных конструкторов, и с листьями, в которых хранятся значения других типов. Рекурсия в данном случае отображает принцип построения дерева: агрегацией поддеревьев. В случае списков
«деревья» оказываются весьма глубокими и односторонними. Так, список [1;2;3;4]
представляется в следующем виде:

Рекурсивные типы, допускающие построение более сбалансированных деревьев, задаются также просто, например:
#type ('a)btree = Leaf of 'a
| Branch of ('a)btree * ('a)btree;;
В общем, может быть доступно несколько различных рекурсивных конструкторов с различным числом потомков. Это даёт очень простой способ представления синтаксических деревьев языков программирования (и других формальных языков). Например, следующий тип представляет арифметические выражения, построенные из целых чисел при помощи операций сложения и умножения.

#type expression = Integer of int
| Sum of expression * expression | Product of expression * expression;;
А рекурсивная функция вычисления значения таких выражений имеет вид:

#let rec eval =
  fun (Integer i) -> i
    | (Sum(e1,e2)) -> eval e1 + eval e2
    | (Product(e1,e2)) -> eval e1 * eval e2;;
eval : expression -> int = <fun>
#eval (Product(Sum(Integer 1,Integer 2),Integer 5));;
- : int = 15

первое действие компиляторов заключается в переводе, согласно правилам синтаксического разбора, текста на входе в «абстрактное синтаксическое дерево». Обратим внимание, что после этого условности, вроде приоритета или использования скобок, уже не требуются. Как только мы достигаем уровня абстрактного синтаксиса, всё выражается явно за счёт структуры дерева. Мы будем использовать подобную технику при написании ML-версий формальных правил лямбда-исчисления. Начнём с типа, используемого для представления лямбда-термов.

#type term = Var of string
          | Const of string
          | Comb of term * term
          | Abs of string * term;;
Type term defined.

  Отметим, что вместо двух термов Abs принимает имя переменной и терм. Это
сделано для запрета некорректных термов. В качестве примера представим терм
λx y. y (x x y) с в виде:

Abs("x",Abs("y",Comb(Var "y",Comb(Comb(Var "x",Var "x"),Var "y"))))

Рекурсивная функция free_in, определяющая, является ли переменная в терме свободной, имеет вид:

#let rec free_in x =
   fun (Var v) -> x = v
     | (Const c) -> false
     | (Comb(s,t)) -> free_in x s or free_in x t
     | (Abs(v,t)) -> not x = v & free_in x t;;
free_in : string -> term -> bool = <fun>
#free_in "x" (Comb(Var "f",Var "x"));;
- : bool = true
#free_in "x" (Abs("x",Comb(Var "x",Var "y")));;
- : bool = false

  Точно так же мы можем рекурсивно определить подстановку. Сначала, во избе-
жание конфликта имён, нам потребуется функция для переименования переменных.
Мы хотим преобразовывать существующие имена переменных в новые, не свободные
в заданном выражении. Переименование производится путём добавления апостро-
фа (') в конец имени.

#let rec variant x t =
  if free_in x t then variant (x^"'") t
  else x;;
variant : string -> term -> string = <fun>
#variant "x" (Comb(Var "f",Var "x"));;
- : string = "x'"
#variant "x" (Abs("x",Comb(Var "x",Var "y")));;
- : string = "x"
#variant "x" (Comb(Var "f",Comb(Var "x",Var "x'")));;
- : string = "x''"

Теперь мы можем определить подстановку так, как мы это сделали для абстрактных
термов:

#let rec subst u (t,x) =
 match u with
   Var y -> if x = y then t else Var y
 | Const c -> Const c
 | Comb(s1,s2) -> Comb(subst s1 (t,x),subst s2 (t,x))
 | Abs(y,s) -> if x = y then Abs(y,s)
               else if free_in x s & free_in y t then
                 let z = variant y (Comb(s,t)) in
                 Abs(z,subst (subst s (Var y,z)) (t,x))
               else Abs(y,subst s (t,x));;
subst : term -> term * string -> term = <fun>

  Обратим внимание на очень близкие параллели между стандартным математиче-
ским представлением лямбда-исчисления, которое обсуждалось ранее, и ML-версией.
Всё что нам действительно надо для завершения аналогии, это вместо явного вызова
конструкторов читать и записывать термы в более удобной форме. Мы вернёмся к
этой проблеме позже и обсудим, как можно добавить такие возможности.

## 6.3.4 Тонкости Рекурсивных Типов

Рекурсивный тип может содержать вложенные конструкторы других типов, включая конструктор типа функций. Например, рассмотрим следующее определение:
#type ('a)embedding = K of ('a)embedding->'a;; Type embedding defined.

Если мы задумаемся о его семантике, то столкнёмся с определёнными сложностями. Рассмотрим, к примеру, специальный случай, когда 'a является bool. Конструктор K:((bool)embedding->bool)->(bool)embedding по определению считается инъективной функцией. Это прямо противоречит теореме Кантора о том, что множество всех подмножеств множества X не может быть инъективно ему.4 Следовательно, рассуждая о семантике типов, нам следует быть осторожнее. В действительности,
α →β не может рассматриваться как полное функциональное пространство, иначе конструкции рекурсивных типов, подобные приведённой выше, будут противоречивыми. Поскольку все функции, которые мы можем задать, в действительности являются вычислимыми, есть смысл ограничиться только ними. С таким ограничением возможно построение непротиворечивой, хотя и сложной, семантики.

Рассмотренное определение также имеет интересные последствия для системы типов. Например, мы можем теперь определить Y комбинатор, используя K для приведения типа. Отметим, что удалив все вхождения K, мы получим, в сущности, обычное определение Y комбинатора в нетипизированном лямбда-исчислении. Конструкция let используется исключительно для эффективности, но мы нуждаемся в η-редексе, включающем z, чтобы предупредить зацикливание, имеющее место в стратегии вычислений, принятой в ML.

4Доказательство: рассмотрим C = {i(s) | s ∈℘(X) и i(s) ̸∈s}. Если i : ℘(X) →X инъективно, то справедливо i(C) ∈C ⇔i(C) ̸∈C, получили противоречие. Эта конструкция напоминает парадокс Рассела, и, возможно, в действительности вдохновлена им. Аналогия будет ещё более близкой, если мы рассмотрим равнозначное утверждение о невозможности сюръективного отображения j : X → ℘(X), и докажем его, рассматривая {s | s ̸∈j(s)}.

#let Y h =
 let g (K x) z = h (x (K x)) z in
 g (K g);;
Y : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
#let fact = Y (fun f n -> if n = 0 then 1 else n * f(n - 1));;
fact : int -> int = <fun>
#fact 6;;
- : int = 720

Таким образом, рекурсивные типы представляют собой значительный вклад в язык и позволяют обойтись без введения в него оператора рекурсии как отдельной примитивной конструкции.

## Упражнения

1. Что
будет
неверно
в
нашем
определении
subst,
если
мы
заменим
Var y -> if x = y then t else Var y сопоставлением с двумя образцами: Var x -> t | Var y -> Var y?
2. Натуральные числа возможно представить (хотя и неэффективно) при помощи
такого рекурсивного типа:
#type num = Zero | Suc of num;;
Определите функции, выполняющие арифметические действия над числами в этой форме.

3. Пользуясь представлением синтаксиса лямбда-термов, данным выше, напишите функцию, конвертирующую произвольный лямбда-терм в эквивалентный, записанный с помощью S, K и I комбинаторов, при помощи техники, рассмотренной нами ранее. В качестве представления комбинаторов используйте
Const "S" и т.п.
4. Расширьте синтаксис лямбда-термов, включив типизацию в стиле Чёрча. Реализуйте функции, выполняющие проверку правил типизации в ходе построения термов и представление последних в виде композиции примитивных конструкторов.
5. Рассмотрим тип бинарных деревьев со строками в узлах:
#type stree = Leaf | Branch of stree * string * stree;;
Напишите функцию strings, возвращающую список строк, полученный при обходе дерева в порядке слева направо, т.е. такую, которая для каждого узла дерева добавляет в конец списка, полученного при обходе левого поддерева, одноэлементный список со строкой, расположенной в данном узле, а затем - список строк, полученный при обходе правого поддерева, сохраняя их порядок. Напишите функцию, которая принимает строку и дерево, для которого соответствующий список отсортирован в алфавитном порядке, а возвращает другое

6. (*) Улучшите эти функции так, чтобы на каждом шагу дерево оставалось почти сбалансированным, т.е. для каждого узла максимальная глубина левого и
правого поддерева отличалась бы не более чем на единицу.5
7. (*) Можете ли вы описать типы выражений, которые могут быть представлены
в типизированном лямбда-исчислении без применения оператора рекурсии?6
Каков тип следующей рекурсивной функции?

let rec
        f
          i = ( i
                 o f )
                       ( i
                          o
                            i ) ; ;

Покажите, как это может использоваться для записи ML выражений с полностью полиморфным типом α. Можете ли вы написать завершённое выражение с таким свойством? Как насчёт произвольной функции типа α →β?

## Глава 7 Доказательство Корректности Программ

Программисты не раз убеждались на своём горьком опыте как бывает сложно написать *корректную* программу, то есть такую, которая делает в точности то, что требуется. В большинстве объёмных программ есть ошибки, последствия которых могут быть самыми различными. Некоторые ошибки безобидны, другие - раздражают, а некоторые - смертельно опасны. К примеру, программное обеспечение электрокардиостимуляторов, автопилотов, систем управления двигателями, антиблокировочных тормозных систем, приборов радиационной терапии, систем управления ядерных реакторов *критично к наличию ошибок*. Ошибки, допущенные при разработке таких программ, могут повлечь за собой массовые человеческие жертвы. Чем глубже проникновение компьютеров во все сферы жизни человечества, тем серьёзнее возможная угроза жизни людей, порождаемая ошибками в программах.1
Каким образом мы можем убедиться в корректной работе программы? Одним из полезных методов будет тестирование программы на обширном наборе планируемых сценариев её использования. При этом входные данные для тестов подбираются так, чтобы проверить различные составляющие программы в поисках возможных ошибок. В реальности оказывается, что потенциальных вариантов использования слишком много, чтобы полностью проверить все из них, так что некоторые ошибки могут быть пропущены в ходе тестирования. Как неоднократно подчёркивают многие авторы, в частности, Дейкстра, тестирование программ может быть полезным для демонстрации наличия ошибок, но показать их отсутствие оно в состоянии лишь в отдельных редких случаях.

Альтернативой тестированию программ служит возможность их математической верификации. Программа, реализованная на достаточно точно определённом языке программирования, имеет однозначное математическое толкование. Аналогично, требования к программе могут быть выражены на языке математики и логики как точная *спецификация*. Такая формализация открывает возможность строгого докарим следующее простое отношение:

$$\Sigma_{n=0}^{N}n={\frac{N(N+1)}{2}}$$
Утверждается, что оно справедливо для произвольных значений N. Мы, очевидно, в состоянии проверить его для любого количества избранных N. Такая проверка может привести нас к интуитивной уверенности в корректности формулы, поскольку выглядит маловероятным, что она когда-либо окажется ложной. Однако, в общем случае попытки сделать выводы по свойствам эмпирических данных могут ввести в заблуждение. В теории чисел известно немало примеров утверждений, которые в итоге опровергались, несмотря на множество положительных частных случаев.2 Более надёжный подход - математическое *доказательство* справедливости приведённого утверждения, что легко достигается путём индукции по переменной N. Аналогично, мы можем надеяться заменить тестирование программы на некотором конечном множестве входных данных формальным доказательством корректности её функционирования в общем случае. В то же время, следует признать, что верификация имеет свои границы применимости.

но, присущи любым попыткам применения математики в естественных науках. К примеру, предположение точного соответствия между машинной реализацией арифметических операций и их математическими прообразами является естественным упрощением моделей, подобно тому, как при анализе простых динамических систем пренебрегают сопротивлением воздуха. В то же время, оба эти предположения могут оказаться неверными в некоторых случаях.

- Верификация программы опирается на её математическую спецификацию. Возможна ситуация, когда спецификация не соответствует в точности тем требованиям, которые в действительности предъявляются к программе. На самом деле, зачастую оказывается особенно трудно сформулировать математически корректную версию неформальных требований. Имеется достаточное количество свидетельств того, что существенные проблемы компьютерных систем вызваны не ошибками в их реализации, а неверным пониманием ожиданий пользователей. Попытка формализации требований часто бывает полезной сама по себе.
Глава 7. Доказательство корректности программ
7.1. Функциональные программы как математические объекты Требования к системе
6
Математическая спецификация требований
6
Математическая модель системы
6
Реализация системы Мы пытаемся установить связь между верхним и нижним элементами диаграммы, т. е. между требованиями к системе и её реализацией. Чтобы добиться этой цели, нам придётся формализовать и то, и другое. Лишь одна связь на диаграмме, между математическими моделями, обладает математической же точностью, прочие связи остаются неформальными. Всё, что мы можем сделать, это постараться сохранять максимальную простоту и прозрачность правил перехода от неформальных требований (моделей) к формальным и обратно, используя прагматичную модель системы и высокоуровневую достаточно читабельную математическую спецификацию.

Однако, несмотря на эти ограничения, верификация обладает существенными достоинствами. В отличие от тестирования, она устанавливает корректность раз и навсегда, причём, возможно, для целого класса программ одновременно (к примеру, различающихся некоторыми параметрами). Более того, аналитический характер процесса верификации может привести (даже в случае неудачи) к более глубокому пониманию не только программы, но и задачи в целом.

7.1
Функциональные программы как математические объекты Во введении было отмечено, что (чистые) функциональные программы напрямую соответствуют математическому понятию функции. Из этого факта зачастую делается вывод, что функциональные программы легче поддаются формальному доказательству корректности, чем императивные. Если даже это и справедливо (с чем многие не согласятся), не следует забывать, что разрыв между математической абстракцией и выполнением программы аппаратным обеспечением в случае функционального подхода гораздо больше, чем для типичных императивных языков. В частности, может оказаться, что в глубинах реализации скрываются неприемлемые требования к объёму доступной памяти. Таким образом лёгкость доказательства может достигаться исключением из рассмотрения существенно важных аспектов. Мы не будем обсуждать этот вопрос в данной работе, а сосредоточимся на демонстрации того, что рассуждения о простых функциональных программах зачастую оказываются тривиальными.

В предыдущем разделе был приведён пример, который демонстрирует неточность наивного отождествления функциональных пространств ML с математическими. Однако, если мы не будем углубляться в подробности теории рекурсивных типов и не рассматриваем пространство *произвольных* функций, а ограничимся лишь некоторыми из них, то в этом случае возможно обращаться с понятиями языка ML, как с

## Математическими.3

Сопоставим функциональным программам математические функции. Располагая уравнениями (обычно рекурсивными), которые определяют функции на языке ML, мы хотим интерпретировать их как аксиоматику соответствующих математических объектов. Например, из определения функции факториала
#let rec fact = fun 0 -> 1
| n -> n * fact(n - 1);;
следует, что fact(0) = 1 и что для произвольных n ̸= 0 мы имеем fact(n) =
n∗fact(n−1). Эти утверждения верны, но в дополнение к ним мы должны проявить особое внимание к проблеме завершимости. Для отрицательных значений n программа зацикливается, поэтому второе равенство можно полагать истинным лишь в том смысле, что обе его части будут неопределёнными. Анализ всюду определённых функций менее трудоёмок; в противном случае требуется отдельное доказательство завершимости вычислений. В примерах, которые приводятся ниже, это делается параллельно с доказательством корректности, т. е. для каждого аргумента мы должны показать, что вычисления завершаются, причём результат удовлетворяет спецификации.

В общем случае процесс доказательства может потребовать применения самых различных математических приёмов. Однако, очень часто свойства функций (включая завершимость), определённых рекурсивно, можно доказать по индукции в силу двойственности этих двух понятий. Более того, различные формы индукции (арифметическая, структурная, трансфинитная) обычно прямо соответствуют видам рекурсии, применённой в определении. Ниже будут изложены примеры, поясняющие это утверждение.

## 7.2 Вычисление Степени

Напомним нашу простую реализацию вычисления степени:
#let rec exp x n =
if n = 0 then 1 else x * exp x (n - 1);;
Докажем, что exp обладает следующим свойством:

Теорема 7.1 Для любого n ≥0 и произвольного x функция exp x n определена и
принимает значение xn.
Доказательство: Функция exp была определена при помощи примитивной пошаго-
вой рекурсии. Как следствие, для доказательства уместно будет воспользоваться
пошаговой индукцией. Покажем, что наше утверждение справедливо для n = 0,
а затем, предположив его справедливость для произвольных n ≥0, докажем его
также и для n + 1.

1. При n = 0 наша реализация даёт exp *x n* = 1. По определению, для произ-
Заметим, что мы неявно предполагаем справедливость 00 = 1 - хороший пример того, как тщательно нужно составлять спецификации, разрешая неоднозначности (каково значение xn в общем случае?), при этом учитывая, что некоторые люди могут быть немало удивлены нашим выбором.

2. Предположим, что при n ≥0 мы имеем exp x n = xn. Из n ≥0 следует,
что n + 1 ̸= 0 *и, по определению, exp* x (n + 1) = x ∗exp x ((n + 1) −1). Отсюда
$exp\ x\ (n+1)\ =\ x*exp\ x\ ((n+1)-1)$

$=\ x*exp\ x\ n$

$=\ x*x^{n}$

$=\ x^{n+1}$
□

## 7.3 Вычисление Нод

Рассмотрим нашу реализацию вычисления наибольшего общего делителя gcd(*m, n*) двух натуральных чисел m и n:
#let rec gcd x y =
if y = 0 then x else gcd y (x mod y);;
делителем v', в которое входят всевозможные пары целых чисел u и v, для которых
'v кратно u', т. е. найдётся такое целое число d, что v = du. Например, 0|0, 1|11, −2|4, но 0 ̸ |1, 3 *̸ |*5. Будем говорить, что d *является наибольшим общим делителем* x и y, если:
- d|x и d|y
- Для любых других целых d′, если d′|x и d′|y, то d′|d.

Отметим, что мы используем в определении d′|d, а не d′ ≤d. Тем самым понятие
«наибольший» делитель лишается смысла, но именно так вводится его определение в алгебре. Также заметим, что любая пара чисел (за исключением 0 и 0) имеет два наибольших делителя, поскольку из определения следует, что если число d является НОД x и y, то это же справедливо и для −d.

С учётом сказанного выше, наша спецификация примет такой вид: для произвольных целых чисел x и y, d = gcd x y является наибольшим общим делителем x и y. На её примере можно ещё раз убедиться, что разработка спецификации даже такой простой функции зачастую оказывается сложнее, чем ожидалось. Кроме того, данная спецификация типична ещё и в том, что не определяет однозначно результат вычислений, а лишь задаёт определённые ограничения. Если мы определим функцию ngcd как
#let rec ngcd x y = -(gcd x y);;
то она будет точно так же удовлетворять спецификации, как и gcd. Безусловно, мы можем при необходимости сделать спецификацию более строгой. Например, если мы ограничимся положительными значениями x и y, функция будет в полной мере соответствовать понятию наибольшего общего делителя.

Функция gcd не определяется исключительно посредством примитивной рекурсии. На шаге алгоритма Евклида gcd x y выражается через gcd y (x mod y). Соответственно, вместо пошаговой индукции будет уместно применить трансфинитную. Нам потребуется определить подходящее для этого вида индукции отношение, причём такое, что результаты последующих рекурсивных вызовов предшествуют предыдущим; это гарантирует завершимость алгоритма. В общем случае, для этого могут понадобиться сложные отношения, заданные на аргументах, но часто бывает достаточно придумать *меру*, которая отображает аргументы на натуральные числа и убывает в ходе рекурсии. В данном случае такой мерой может служить |y|.

Теорема 7.2 Для произвольных целых x и y, вычисление gcd x y завершается с результатом, равным НОД x и y.

Доказательство: Предположим для некоторого n, что для произвольного значения x и y такого, что |y| < n теорема справедлива. Основываясь на этом предположении, попробуем доказать, что она справедлива также для произвольного x при |y| = n. Этого будет достаточно, чтобы считать теорему доказанной, поскольку для любого y *найдётся* некоторое n такое, что |y| = n. Согласно определению функции, доказательство разбивается на два частных случая.

- *Предположим, что* y = 0. В этом случае по определению функции gcd x y = x.
Очевидно, x|x и x|0, т. е. является общим делителем. Предположим, что
найдётся ещё один общий делитель d, для которого справедливо d|x и d|0.
Отсюда немедленно следует d|x, из чего, в свою очередь, вытекает то, что x
является НОД.
- *Рассмотрим случай* y ̸= 0. Мы хотим применить индуктивное предположение к gcd y (x mod y). Введём сокращённое обозначение r = x mod y. Основным
свойством функции mod *является то, что при* y ̸= 0 найдётся такое целое q, что x = qy +r и |r| < |y|. Поскольку |r| < |y|, из индуктивного предположения
следует, что d = gcd y (x mod y) является НОД y и r. Остаётся показать,
что он является НОД также и для x и y. Очевидно, это также справедливо, поскольку при d|y и d|r мы имеем d|x, так как x = qy + r. Предположим,
что d′|x и d′|y. Аналогично сказанному выше, обнаруживаем, что d′|r. Таким
образом, d′ является общим делителем y и r, а по индуктивному предположению d′|d, что и требовалось.

## □

вычисления остатка. Её реализация (функция mod) в конкретных CAML-системах требует тщательной проверки соответствия теоретическому определению. Хорошо известно, что различные языки программирования (и даже реализации одного и того же языка) зачастую различаются в трактовке операции вычисления остатка в случае отрицательных аргументов. Если отсутствует уверенность в надёжности неявных предположений, их можно добавить в теорему в явной форме.

Глава 7. Доказательство корректности программ
7.4. Конкатенация списков

## 7.4 Конкатенация Списков

Рассмотрим пример верификации функции, оперирующей списками. Функция append предназначена, как это следует из её названия, для конкатенации (сцепления) двух списков. Например, результатом применения этой операции к спискам [3; 2; 5] и [6; 3; 1] будет [3; 2; 5; 6; 3; 1].

#let rec append l1 l2 =
  match l1 with
    [] -> l2
  | (h::t) -> h::(append t l2);;

Данная функция вводится при помощи примитивной рекурсии в соответствии с определением списочного типа. Она определяется для случая пустого списка и, затем, для списка вида h :: t, причём в последнем случае используется значение этой же функции для аргумента t. Следовательно, доказательства теорем о её свойствах удобно строить на соответствующем принципе структурной индукции для списков: если некоторое утверждение справедливо для пустого списка и, если из предположения, что оно выполняется для t следует, что данное утверждение справедливо и для h :: t, то мы можем заключить, что оно справедливо для любого списка. Однако, такой подход не обязателен - при желании можно воспользоваться математической индукцией по длине списка. Докажем с учётом сказанного выше, что операция конкатенации ассоциативна.

Теорема 7.3 Для трёх произвольных списков l1, l2 и l3 справедливо:
append l1 (*append* l2 l3) = append (*append* l1 l2) l3
Доказательство: Применяя структурную индукцию к l1, докажем, что требуемое свойство выполняется для произвольных l2 и l3.

- *Если* l1 = [], то:

append l1 (*append* l2 l3)
=
append [] (*append* l2 l3)
=
append l2 l3
=
append (*append* [] l2) l3
=
append (*append* l1 l2) l3

- Рассмотрим случай l1 = h :: t. Предположим, что для l2 и l3 мы имеем
append t (*append* l2 l3) = append (append *t l*2) l3
Отсюда следует

append l1 (*append* l2 l3)
=
append (h :: t) (*append* l2 l3)
=
h :: (append t (*append* l2 l3))
=
h :: (append (append *t l*2) l3)
=
append (h :: (append *t l*2)) l3)
=
append (*append* (h :: t) l2) l3)
=
append (*append* l1 l2) l3)

## □ 7.5 Обращение Списков

Определить функцию обращения списков несложно:

#let rec rev =
  fun [] -> []
    | (h::t) -> append (rev t) [h];;
rev : 'a list -> 'a list = <fun>
#rev [1;2;3];;
- : int list = [3; 2; 1]

Докажем, что функция rev является инволюцией, т. е. что rev(rev l) = l Однако, если мы попытаемся напрямую применить структурную индукцию, оказывается, что нам понадобится сперва доказать пару дополнительных лемм.

Лемма 7.4 Для произвольного списка l *справедливо append* l [] = l.

Доказательство: Воспользуемся структурной индукцией по l.

- *Для* l = [] имеем:

append l []
          =
             append [] []
          =
             []
          =
             l

- Пусть l = h :: t*. Предполагая, что append* t [] = t, получим

append l []
          =
             append (h :: t) []
          =
             h :: (append t [])
          =
             h :: t
          =
             l

□

Лемма 7.5 Для произвольных списков l1 и l2 справедливо

rev(append l1 l2) = append (rev l2) (rev l1)

Доказательство: Для доказательства этой леммы также воспользуемся струк-
турной индукцией по l1.

- *При* l1 = [] получаем

rev(append l1 l2)
                  =
                      rev(append [] l2)
                  =
                      rev l2
                  =
                      append (rev l2)[]
                  =
                      append (rev l2) (rev [])

- Если l1 = h :: t и мы знаем, что
rev(append *t l*2) = append (rev l2) (rev t)
то из этого следует

rev(*append* l1 l2)
=
rev(*append* (h :: t) l2)
=
rev(h :: (append *t l*2))
=
append (rev(append *t l*2)) [h]
=
append (append (rev l2) (rev t)) [h]
=
append (rev l2) (append (rev t) [h])
=
append (rev l2) (rev (h :: t))
=
append (rev l2) (rev l1)

□
- *При* l = [] имеем:

rev(rev l)
=
rev(rev [])
=
rev []
=
[]
=
l

- Пусть l = h :: t и справедливо, что

rev(rev t) = t

в этом случае мы получим:

rev(rev l)
=
rev(rev (h :: t))
=
rev(append (rev t) [h])
=
append (rev [h]) (rev(rev t))
=
append (rev [h]) t
=
append (rev (h :: [])) t
=
append (append (rev []) [h]) t
=
append (*append* [] [h]) t
=
append [h] t
=
append (h :: []) t
=
h :: (*append* [] t)
=
h :: t
=
l

## □

Большое количество теорем о свойствах операций над списками может быть доказано в аналогичном стиле. Доказательство в целом базируется на структурной индукции, применяемой к списку. В некоторых случаях может оказаться удобным выделить части рассуждений в отдельные леммы, которые также доказываются индуктивно, кроме того, задача может потребовать обобщения, прежде чем индукция окажется применимой. Некоторые примеры таких задач приведены в упражнениях.

## Дополнительная Литература

Нойман даёт в работе [45] обзор рисков, связанных как с распространением компьютеров в обществе в целом, так и с последствиями программных ошибок в частности. Очень интересная дискуссия с примерами на эту же тему приведена Питерсоном [50]. Применимость верификации являлась в своё время предметом споров; некоторые аргументы против этого подхода изложены в [21]. Также заслуживает внимания обоснованное обсуждение [6]. На данный момент количество публикаций по верификации велико, но в большинстве своём они рассматривают императивные программы. Некоторые учебники функционального программирования для начинающих, такие как [47] и [53], включают базовые примеры наподобие рассмотренных в данной книге. Представляет интерес работа [10], авторы которой провели верификацию свойств определений чистых функций на языке LISP при помощи своей системы автоматизированного доказательства теорем. Одним из самых масштабных опытов по верификации, наподобие рассмотренных здесь, служит применение данной методики к программе упрощения логических выражений, которая используется в синтезе СБИС [1].

## Упражнения

1. Докажите корректность более эффективного алгоритма возведения в степень:

#let square x = x * x;;
#let rec exp x n =
 if n = 0 then 1
 else if n mod 2 = 0 then square(exp x (n / 2))
 else x * square(exp x (n / 2));;

2. Пусть функция length определена как
#let rec length =
fun [] -> 0
| (h::t) -> 1 + length t;;
Докажите, что length(rev l) = length l и что length(append l1 l2) = length l1 +
length l2.

3. Определим функцию map, которая применяет заданную функцию к каждому
элементу списка, следующим образом:
#let rec map f =
fun [] -> []
| (h::t) -> (f h)::(map f t);;
Докажите, что если l ̸= [] то hd(map *f l*) = f(hd l) и map f (rev l) =
rev (map *f l*). Далее, используя следующее определение композиции функций,
#let o f g = fun x -> f(g x);; #infix "o";;
докажите, что map f (map *g l*) = map (f ◦g) l.

4. Функция «91» Мак-Карти может быть определена так:
#let rec f x = if x > 100 then x - 10
else f(f(x + 11));;
Докажите, что для n ≤101 справедливо f(n) = 91. Особое внимание следует уделить доказательству завершимости. (Указание: возможно использовать меру 101 −x.)

5. Задача о голландском флаге состоит в сортировке списка «цветов» (красный,
белый, синий) так, чтобы цвета расположились в данном порядке. Требуется решить задачу, используя исключительно перестановку соседних элементов. Пример решения на языке ML приводится ниже. Функция dnf возвращает значение
true тогда и только тогда, когда порядок следования элементов изменился; её вычисление повторяется, пока на некотором этапе не окажется, что изменений не обнаружено.

type colour = Red |
                    White
                           |
                            Blue ; ;

let rec dnf =
   fun
       [ ] −> [ ] , f a l s e
     |
       ( White : : Red : : r e s t ) −> Red : : White : : rest , true
     |
       ( Blue : : Red : : r e s t ) −> Red : : Blue : : rest , true
     |
       ( Blue : : White : : r e s t ) −> White : : Blue : : rest , true
     |
       (x : : r e s t ) −> let
                         f l , ch = dnf
                                     r e s t
                                          in x : : f l , ch ; ;

let rec
        f l a g
             l =
  let
      l ' , changed = dnf
                        l
                          in
  i f
     changed then f l a g
                        l '
                           else
                                l ' ; ;

Например,
#flag [White; Red; Blue; Blue; Red; White; White; Blue; Red];; - : colour list =
[Red; Red; Red; White; White; White; Blue; Blue; Blue]
Докажите, что функция flag всегда завершается, и её результатом будет корректно упорядоченный список.

6. (*) Определите следующие функции:

#let rec sorted =
  fun [] -> true
    | [h] -> true
    | (h1::h2::t) -> h1 <= h2 & sorted(h2::t);;

#let rec filter p =
  fun [] -> []
    | (h::t) -> let t' = filter p t in
                if p h then h::t' else t';;

#let sameprop p l1 l2 =
  length(filter p l1) = length(filter p l2);;

#let rec permutes l1 l2 =
  fun [] -> true
    | (h::t) -> sameprop (fun x -> x = h) l1 l2 &
                permutes l1 l2 t;;

#let permuted l1 l2 = permutes l1 l2 l1;;

Определите назначение этих функций. Реализуйте функцию сортировки sort и докажите, что для произвольных списков l справедливо, что sorted(sort l) =
true and permuted l (sort l) = true.

## Глава 8 Эффективный Ml

В этой главе мы обсудим некоторые техники и уловки, при помощи которых ML-
программисты делают свои программы более элегантными и эффективными. Затем рассмотрим дополнительные *императивные* возможности, которые могут быть задействованы, когда чистый функциональный подход представляется неподходящим.

## 8.1 Полезные Комбинаторы

Гибкость функций высшего порядка означает, что можно написать небольшие, но весьма полезные функции, а затем многократно использовать их во многих сходных задачах. Такие функции часто называют *комбинаторами*, но не только потому, что они являются лямбда-термами без свободных переменных. Эти функции зачастую оказываются настолько гибкими, что путём их комбинации друг с другом возможно реализовать практически всё что угодно, не прибегая к явным рекурсивным определениям. В данном смысле они близки к изначальной трактовке комбинаторов как универсальных блоков, из которых строятся математические выражения.

Например, очень полезный комбинатор для операций над списками, часто называемый itlist или fold, выполняет следующие действия:
itlist f [x1; x2; . . . ; xn] b = f x1 (f x2 (f x3 (· · · (f xn b))))
Его определение средствами ML очевидно:

#let rec itlist f =
  fun [] b -> b
    | (h::t) b -> f h (itlist f t b);;
itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>

  Довольно часто рекурсивные функции обработки списков заключаются просто в
повторном применении некоторой функции к каждому элементу списка. Используя
itlist с подходящим аргументом, такие функции можно очень легко реализовать
без явного использования рекурсии. Типичный пример - подсчёт суммы всех чисел
в списке.

#let sum l = itlist (fun x sum -> x + sum) l 0;;
sum : int list -> int = <fun>
#sum [1;2;3;4;5];;
- : int = 15
#sum [];;
- : int = 0
#sum [1;1;1;1];;
- : int = 4

Ценители краткости могут предпочесть следующий вариант реализации:
#let sum l = itlist (prefix +) l 0;;
Легко изменить эту функцию для вычисления произведения вместо суммы.

#let prod l = itlist (prefix *) l 1;;
Многие полезные действия со списками могут быть реализованы подобным образом. Например, функция, отбирающая только те элементы списка, которые удовлетворяют заданному предикату:

#let forall p l = itlist (fun h a -> p(h) & a) l true;;
forall : ('a -> bool) -> 'a list -> bool = <fun>
#let exists p l = itlist (fun h a -> p(h) or a) l false;;
exists : ('a -> bool) -> 'a list -> bool = <fun>
#forall (fun x -> x < 3) [1;2];;
- : bool = true
#forall (fun x -> x < 3) [1;2;3];;
- : bool = false

Эти функции проверяют наличие в списке элементов, удовлетворяющих предикату:

#let forall p l = itlist (fun h a -> p(h) & a) l true;;
forall : ('a -> bool) -> 'a list -> bool = <fun>
#let exists p l = itlist (fun h a -> p(h) or a) l false;;
exists : ('a -> bool) -> 'a list -> bool = <fun>
#forall (fun x -> x < 3) [1;2];;
- : bool = true
#forall (fun x -> x < 3) [1;2;3];;
- : bool = false

А вот альтернативные версии length, append и map:.

#let length l = itlist (fun x s -> s + 1) l 0;;
length : 'a list -> int = <fun>
#let append l m = itlist (fun h t -> h::t) l m;;
append : 'a list -> 'a list -> 'a list = <fun>
#let map f l = itlist (fun x s -> (f x)::s) l [];;
map : ('a -> 'b) -> 'a list -> 'b list = <fun>

Некоторые из этих функций сами по себе являются полезными комбинаторами.

Например, если мы хотим трактовать списки как множества, т.е. исключаем кратные элементы, то многие стандартные операции над множествами очень просто выражаются в терминах только что рассмотренных комбинаторов:

#let mem x l = exists (fun y -> y = x) l;;
mem : 'a -> 'a list -> bool = <fun>
#let insert x l =
 if mem x l then l else x::l;;
insert : 'a -> 'a list -> 'a list = <fun>
#let union l1 l2 = itlist insert l1 l2;;
union : 'a list -> 'a list -> 'a list = <fun>
#let setify l = union l [];;
setify : 'a list -> 'a list = <fun>
#let Union l = itlist union l [];;
Union : 'a list list -> 'a list = <fun>
#let intersect l1 l2 = filter (fun x -> mem x l2) l1;;
intersect : 'a list -> 'a list -> 'a list = <fun>
#let subtract l1 l2 = filter (fun x -> not mem x l2) l1;;
subtract : 'a list -> 'a list -> 'a list = <fun>
#let subset l1 l2 = forall (fun t -> mem t l2) l1;;
subset : 'a list -> 'a list -> bool = <fun>

Функция setify предназначена для преобразования списка произвольного вида во
множество посредством исключения кратных элементов.

## 8.2 Создание Эффективного Кода

В этом разделе мы собрали несколько общих приёмов, с помощью которых можно сделать ML-программы существенно более эффективными. Для того, чтобы обосновать некоторые из них, необходимо обрисовать в общих чертах процесс выполнения аппаратным обеспечением тех или иных конструкций языка.

## 8.2.1 Хвостовая Рекурсия И Аккумуляторы

Основной механизм управления в функциональных программах - рекурсия. Если мы заинтересованы в эффективности программ, нам следует учитывать особенности реализации рекурсии на стандартном оборудовании. В сущности, нет или, по крайней мере, мало отличий между реализацией ML и многими другими языками с динамическими переменными, такими как С.

В языках, не допускающих рекурсивных вызовов, можно без опаски сохранять все локальные переменные (включая и значения аргументов функции) в фиксированной области памяти, как, например, сделано в FORTRAN. Тем не менее, в общем случае, когда функция может вызываться рекурсивно, это недопустимо: вызов функции f с одним набором аргументов может содержать вызов f с другими аргументами.

Это значит, что старые значения аргументов будут переписаны, даже если они могут потребоваться в дальнейшем, после завершения вложенного вызова f. Поясним сказанное на примере. Рассмотрим ещё раз функцию вычисления факториала:
#let rec fact n = if n = 0 then 1
else n * fact(n - 1);;
Вызов fact 6 приводит к последующему вызову fact 5 (и далее), но когда вычисление fact 5 закончено, и получен его результат, нам всё ещё требуется исходное значение n, а именно 6, для вычисления произведения, дающего окончательный ответ. Обычно реализация этого процесса выглядит следующим образом: для каждого вызова функции выделяется новый *стековый фрейм*. Указатель стека при этом продвигается вниз,1 выделяя пространство под новые переменные. В стековый фрейм и копируются значения аргументов функции, её локальных переменных, иначе - состояние выполнения. После того, как выполнение вызова функции завершается, указатель стека перемещается обратно, таким образом, ненужные локальные переменные автоматически отбрасываются. Проясним сказанное при помощи схемы:

| n   |  = 6   |
|-----|--------|
| n   | = 5    |
| n   | = 4    |
| n   | = 3    |
| n   | = 2    |
| n   | = 1    |
| SP  |        |
| -   |        |
| n   | = 0    |

Здесь изображено воображаемое состояние стека во время последнего рекурсивного вызова, т.е. вычисления fact 0. Все локальные переменные предыдущих вызовов собраны в стеке, в отдельном фрейме для каждого экземпляра функции. По завершению вызовов указатель стека SP перемещается обратно вверх.

Следовательно, наша реализация fact требует n фреймов стека для применения к аргументу n. Напротив, рассмотрим следующую реализацию функции, вычисляющей факториал:

#let rec tfact x n =
  if n = 0 then x
  else tfact (x * n) (n - 1);;
tfact : int -> int -> int = <fun>
#let fact n = tfact 1 n;;
fact : int -> int = <fun>
#fact 6;;
- : int = 720

  Хотя tfact также рекурсивна, здесь рекурсивный вызов - итоговое выражение,
после него никаких вычислений не происходит; оно не входит в виде подвыражения в
какое-либо другое выражение. Подобные вызовы называются хвостовыми вызовами
(потому что их выполнение - последнее действие, совершаемое в ходе вычисления
охватывающей функции), а функция, в которой все рекурсивные вызовы суть хво-
стовые, называется функцией с хвостовой рекурсией.
  Чем примечательны хвостовые вызовы? При рекурсивном вызове tfact нет необ-
ходимости сохранять предыдущие значения локальных переменных, так что можно
использовать для их размещения одну и ту же фиксированную область памяти. Бу-
дет ли это происходить на самом деле, разумеется, зависит от того, способен ли
компилятор обнаружить наличие хвостовой рекурсии в коде. Большинство извест-
ных компиляторов, включая CAML, обладают требуемым качеством. Следовательно,

оформление функции таким образом, чтобы рекурсивный вызов являлся хвостовым, может существенно сократить использование памяти. Для таких функций как факториал, едва ли возможен вызов для столь больших значений аргумента n, что переполнится стек. Однако, наивная реализация многих действий над списками может привести к подобным последствиям, когда списки длинны.

Дополнительный аргумент x функции tfact называется *аккумулятором*, потому что он накапливает промежуточные результаты по ходу рекурсивных вызовов и, в конце концов, возвращается как значение функции. Такая схема, применяемая вместо вычисления результата по мере возврата из рекурсии, служит стандартным способом построения функций с хвостовой рекурсией.

Мы отметили, что в функциях с хвостовой рекурсией для аргументов может использоваться фиксированная область памяти. С этой точки зрения допустимо рассматривать рекурсию как завуалированную реализацию императивного цикла. Примером служит очевидная параллель с итеративной реализацией факториала на языке C:

int fact(int n)
{ int x = 1;
 while (n > 0)
  { x = x * n;
    n = n - 1;
  }
 return x;
}

  Инициализация x = 1 соответствует связыванию значения 1 с параметром x во
внешней функции-обертке fact. Основной цикл соответствует рекурсивным вызовам
с тем лишь отличием, что в функцию с хвостовой рекурсией мы явно передаём состо-
яние2 через аргументы. Вместо модификации переменных и выполнения очередной
итерации мы делаем рекурсивный вызов с обновлёнными параметрами. Используя
похожие приёмы и выражая состояние явно, можно легко писать, в сущности, импе-
ративные программы в якобы функциональном стиле. Обоснованием равноценности
такой замены служит тот факт, что порождаемый машинный код после применения
стандартных методов оптимизации будет одним и тем же в обоих случаях.

## 8.2.2 Минимизация Операций Cons

Мы рассмотрели, как используется пространство стековой памяти. Но различные конструкции в функциональных программах могут использовать память и другого типа, которая обычно выделяется в области, называемой *кучей*. Тогда как стек последовательным образом растёт и сокращается в соответствии с порядком вычисления функций, прочая память не может быть освобождена таким же простым способом. Вместо этого исполняющей системе, время от времени, требуется проверять, какая часть выделенной памяти больше не используется, и освобождать её для дальнейших вычислений; такой процесс известен как *сборка мусора*. Особенно важный случай —
это память, используемая конструкторами рекурсивных типов, такими, как ::. Например, в ходе выполнения следующего фрагмента

let
    l = 1 : : [ ]
                in
                   t l
                       l ; ;

для хранения результата работы конструктора :: выделяется новый блок памяти,
который принято называть «cons-ячейкой». Как правило, он содержит три слова па-
мяти: одно является идентификатором конструктора, а два других - указателями
на голову и хвост списка. В целом, решение по поводу того, когда память может
быть освобождена, представляет собой сложную задачу. В нашем примере мы сразу
возвращаем хвост списка, так что, очевидно, cons-ячейка может быть освобождена
немедленно. Но, в общем случае, из текста программы столь явные выводы сделать
затруднительно, поскольку l может быть, например, передан различным функциям,
которые, в свою очередь, могут как обратиться к элементам списка, так и нет. Сле-
довательно, необходимо динамически анализировать использование памяти и выпол-
нять сборку мусора. В противном случае мы рискуем исчерпать память даже тогда,
когда реально нам требуется лишь её небольшое количество.
  Разработчики функциональных языков усердно работают над алгоритмами более
эффективной сборки мусора. Известно мнение, что автоматическое выделение памя-
ти и сборка мусора работают быстрее, чем при традиционном явном управлении
памятью в языках, подобных C (malloc и пр.). Хотя мы не пойдём в своих утвер-
ждениях так далеко, но все же сочтём очевидным, что полностью автоматическое
распределение памяти очень удобно, поскольку позволяет избежать в ходе програм-
мирования многих утомительных деталей, которые к тому же зачастую оказываются
источником ошибок.
  Многие конструкции, популярные в среде функциональных программистов, ак-
тивно используют память, которая в дальнейшем должна освобождаться сборщиком
мусора. Хотя чрезмерное беспокойство по этому поводу может повредить функци-
ональному стилю программ, есть некоторые простые соображения, которые стоит
учитывать во избежание неуместного расходования памяти. Одно из простых эмпи-
рических правил заключается в том, что следует избегать по возможности приме-
нения append. Как видим, эта функция при развёртывании рекурсивных вызовов
согласно определению

#let rec append l1 l2 =
  match l1 with
    [] -> l2
  | (h::t) -> h::(append t l2);;

порождает n cons-ячеек, где n длина первого списка. Существует множество спосо-
бов заменить append, например, при помощи введения дополнительных аргументов
функций - аккумуляторов, которые будут обновляться явным конструированием
списков. Замечательный пример - функция обращения списка, которую мы раньше
определили как:

#let rec rev =
  fun [] -> []
    | (h::t) -> append (rev t) [h];;

#let rev =
  let rec reverse acc =
    fun [] -> acc
      | (h::t) -> reverse (h::acc) t in
  reverse [];;

Более того, рекурсия во вложенной функции reverse - хвостовая, так что мы также сохраняем стековую память и, таким образом, дважды в выигрыше.

Как пример другой типичной ситуации, когда посредством разумного использования аккумуляторов мы можем избежать вызовов append, рассмотрим задачу построения списка терминальных элементов бинарного дерева. Если мы зададим тип бинарных деревьев следующим образом:
#type btree = Leaf of string
| Branch of btree * btree;;
то решением задачи будет:
#let rec fringe =
fun (Leaf s) -> [s]
| (Branch(l,r)) -> append (fringe l) (fringe r);;
Однако, следующая улучшенная версия выполняется с меньшими затратами:

#let fringe =
  let rec fr t acc =
    match t with
      (Leaf s) -> s::acc
    | (Branch(l,r)) -> fr l (fr r acc) in
  fun t -> fr t [];;

Отметим, что мы поставили аккумулятор вторым аргументом, так что теперь рекурсивный вызов более понятен при чтении слева направо. Вот простой пример, как может использоваться каждая из версий fringe:
#fringe (Branch(Branch(Leaf "a",Leaf "b"), Branch(Leaf "c",Leaf "d")));;
- : string list = ["a"; "b"; "c"; "d"]
Первая версия создаёт 6 cons-ячеек, вторая - только 4. На б´
ольших деревьях эффект будет более впечатляющим. Ещё одним типичным случаем неуместного использования конструкторов типа может оказаться сопоставление с образцом. Например, рассмотрим такой фрагмент кода:

fun
    [ ] −> [ ]
  |
    (h : : t ) −> i f h < 0 then t
                               else h : : t ; ;

Ветка, соответствующая 'else', создаёт cons-ячейку, несмотря на то, что эта же конструкция уже передавалась как аргумент функции. То есть, аргумент берётся и повторно реконструируется. Чтобы подобных издержек не было, изменим определение функции следующим образом:

fun l −>
  match
        l with
    [ ] −> [ ]
  |
    (h : : t ) −> i f h < 0 then t
                               else
                                    l ; ;

  Тем не менее, ML предлагает более гибкую альтернативу: применение ключево-
го слова as. С его помощью мы можем именовать определённые части образцов,
так что впоследствии возможно их использование без повторного конструирования.
Например:

fun
    [ ] −> [ ]
  |
    (h : : t as
             l ) −> i f h < 0 then t
                                    else
                                          l ; ;

## 8.2.3 Принудительное Вычисление

Мы отмечали, что лямбда-абстракция может использоваться для приостановки вычислений, поскольку в ML выражения, связанные абстракцией, не вычисляются. Некоторые интересные примеры будут рассматриваться позже. С другой стороны, кому-то может потребоваться принудительное вычисление выражений. Например:

#let rec tfact x n =
  if n = 0 then x
  else tfact (x * n) (n - 1);;
#let fact n = tfact 1 n;;

   Поскольку мы в действительности никогда непосредственно tfact не используем,
имеет смысл не связывать глобальное имя с этой функцией, а сделать её локальной:

#let fact1 n =
  let rec tfact x n =
    if n = 0 then x
    else tfact (x * n) (n - 1) in
  tfact 1 n;;

Такое решение, однако, имеет существенный недостаток: локальное рекурсивное определение вычисляется только после того, как fact1 получает свой аргумент, поскольку до этого оно находится в области действия лямбда-абстракции. Более того, оно вычисляется каждый раз при вызове fact. Мы можем поправить это так:

#let fact2 =
  let rec tfact x n =
    if n = 0 then x
    else tfact (x * n) (n - 1) in
  tfact 1;;

  Теперь локальное связывание вычисляется лишь однажды, во время объявления
fact2. Согласно нашим измерениям, вторая версия fact для аргумента, равного 6,
оказывается примерно на 20% быстрее. В тех случаях, когда при локальном свя-
зывании требуется больше вычислений, отличие может быть более впечатляющим.

На самом деле, как эта оптимизация, так и другие, более изощрённые, являются предметом исследований в рамках сложного научного направления - теории «частичных вычислений», цель которых - автоматизация их выполнения. В известном смысле, подобные преобразования можно считать обобщением стандартных оптимизаций, таких как «сворачивание констант», в компиляторах обычных языков. Однако ML-системы, применяемые на практике, требуют, чтобы пользователь задавал их явно, как продемонстрировано выше.

Мимоходом заметим, что для функций, определяемых композицией комбинаторов с минимальным использованием лямбда-абстракции, выше вероятность того, что эффект от реализации вычислений на этапе анализа определений окажется максимальным. Например, для выражения f ◦g могут быть выполнены все вычисления, возможные в f и g, тогда как для эквивалентного ему λx. f(g x) ничто не будет вычислено до момента применения к конкретному аргументу. С другой стороны, когда мы действительно *хотим* отложить вычисление, нам в самом деле потребуется лямбда-абстракция, так что исключительно комбинаторная реализация в этом случае окажется невозможной.

## 8.3 Императивные Возможности

ML обладает довольно широкими возможностями для программирования в императивном стиле. Мы не будем тратить время на подробное изложение связанных с этим вопросов, поскольку они далеки от целей данного пособия, а также потому, что предполагаем наличие у читателей достаточного опыта. Следовательно, мы ограничимся кратким обзором, проиллюстрировав его несколькими примерами. Тем не менее, некоторые императивные возможности будут применяться в дальнейших примерах, и некоторое знание того, что можно использовать, будет хорошим подспорьем в практическом программировании на языке ML.

## 8.3.1 Исключения

Мы знаем, что иногда вычисления завершаются отказом, например при неудачной попытке сопоставления с образцом. Существуют и другие причины критических ошибок, например, попытка деления на нуль.

#1 / 0;; Uncaught exception: Division_by_zero Во всех этих случаях компилятор сообщает о «необработанном исключении». Исключение сигнализирует об ошибке, но при этом не всегда требуется реагировать на неё возвратом в диалоговый режим. Считается, что исключительным ситуациям соответствует тип exn, который по своей сути считается рекурсивным, хотя на практике это его свойство обычно значения не имеет. В отличие от обычных типов, для типа exn допустимо вводить новые конструкторы в любом месте программы, используя объявления исключений, например:

#exception Died;;
Exception Died defined.
#exception Failed of string;;
Exception Failed defined.

В то время как обычно исключения генерируются (также используется термин
«возбуждаются») некоторым набором встроенных операций, этого же можно добиться прямым использованием специальной конструкции raise, например:
#raise (Failed "I don't know why");; Uncaught exception: Failed "I don't know why"
Мы можем создать своё собственное исключение, сигнализирующее о попытке извлечения первого элемента из пустого списка:

#exception Head_of_empty;;
Exception Head_of_empty defined.
#let hd = fun [] -> raise Head_of_empty
           | (h::t) -> h;;
hd : 'a list -> 'a = <fun>
#hd [];;
Uncaught exception: Head_of_empty

Обычно исключения последовательно передаются «наверх»3, но они также могут быть «перехвачены» и обработаны в одном из охватывающих вызовов с помощью конструкции try ...with; в её состав входит набор образцов, с которыми сопоставляются исключения:

#let headstring sl =
  try hd sl
  with Head_of_empty -> ""
     | Failed s -> "Failure because "^s;;
headstring : string list -> string = <fun>
#headstring ["hi"; "there"];;
- : string = "hi"
#headstring [];;
- : string = ""

Считать ли исключения императивной конструкцией - это, в действительности, вопрос убеждений. С одной стороны, можно сказать, что функции возвращают элементы типа объединение, которое включает собственно их возвращаемый тип, выводимый из определения, и тип-исключение. При этом также полагается, что все операции неявно передают значения-исключения в составе своего результата. С другой стороны, есть мнение, что исключения представляют собой существенно нелокальное вмешательство в порядок исполнения программы, подобное goto. 4 Тем не менее, какой бы смысл в них ни вкладывался, исключения часто могут принести ощутимую пользу.

## 8.3.2 Ссылки И Массивы

Также в ML имеются и традиционные модифицируемые переменные, значения которых могут изменяться в качестве побочного эффекта при вычислении выражений. Доступ к таким переменным осуществляется явно, с помощью *ссылок* (указателей, говоря языком C), которые, в свою очередь, рассматриваются в ML как обычные значения. Действительно, этот подход довольно похож на использование указателей в C. Например, в C, когда требуется реализовать «выходные параметры», эффект от изменения которых в ходе выполнения функции сохраняется и после её завершения, применяется передача параметров по указателю. Подобная техника часто используется, когда функция должна возвращать сложные составные данные.

В ML запись ref x означает объявление и инициализацию ячейки памяти значением x. Инициализация обязательна. Это выражение выдаёт ссылку (указатель)
на ячейку в памяти. Последующий доступ к содержимому памяти требует явного разыменования указателя с помощью оператора !, сходного с унарным * в C. Присваивание ячейке нового значения делается при помощи оператора присваивания традиционного вида. Например:

#let x = ref 1;;
x : int ref = ref 1
#!x;;
- : int = 1
#x := 2;;
- : unit = ()
#!x;;
- : int = 2
#x := !x + !x;;
- : unit = ()
#x;;
- : int ref = ref 4
#!x;;
- : int = 4

  Заметим, что во многих отношениях ref ведёт себя подобно конструктору типа, а
значит, может использоваться в сопоставлении с образцом. Следовательно, оператор
разыменования ! можно было бы определить как:

#let contents_of (ref x) = x;;
contents_of : 'a ref -> 'a = <fun>
#contents_of x;;
- : int = 4

Возможность модифицировать ссылки может оказаться полезной при создании совместно используемых структур данных. Так, можно легко реализовать представление графов, в котором множество узлов содержит ссылки на один и тот же подграф.

Кроме отдельных ячеек, в ML также можно использовать массивы. В CAML они называются *векторами*. Массив элементов типа α имеет тип *α vect*. Новый вектор размера n, где каждый элемент проинициализирован значением x (инициализация и в этом случае обязательна) создаётся с помощью следующего вызова:
#make_vect n x;;
Можно прочесть элемент m вектора v с помощью:
#vect_item v m;;
и записать значение y в m-й элемент v:
#vect_assign v m y;;
Эти операции соответствуют выражениям v[m] и v[m] = y в языке C. Элементы массива нумеруются с нуля. Например:

#let v = make_vect 5 0;;
v : int vect = [|0; 0; 0; 0; 0|]
#vect_item v 1;;
- : int = 0
#vect_assign v 1 10;;
- : unit = ()
#v;;
- : int vect = [|0; 10; 0; 0; 0|]
#vect_item v 1;;
- : int = 10

Все операции чтения и записи элементов сопровождаются проверкой значений ин-
декса на допустимость, например:

#vect_item v 5;;
Uncaught exception: Invalid_argument "vect_item"

## 8.3.3 Последовательность Вычислений

В ML нет необходимости указывать последовательность действий, поскольку обычные правила вычисления предполагают порядок. Например, в выражении

#let _ =
         x := !x + 1 in
let _ =
         x := !x + 1 in
let _ =
         x := !x + 1 in
let _ =
         x := !x + 1 in
();;

подвыражения вычисляются в ожидаемом порядке. Здесь мы используем особый образец _, который предписывает игнорировать соответствующее значение, но вместо него также допустимо имя переменной. Тем не менее, более привлекательной представляется возможность задать последовательность вычислений при помощи специальных обозначений. В языке ML в качестве такого обозначения применяется точка с запятой:

#x := !x + 1;
x := !x + 1;
x := !x + 1;
x := !x + 1;;

## 8.3.4 Работа С Системой Типов

Хотя полиморфизм очень хорошо сочетается с чисто функциональными базовыми конструкциями ML, возникают определённые проблемы его согласования с некоторыми императивными возможностями. Рассмотрим следующий пример:
#let l = ref [];;
Может показаться, что l имеет полиморфный тип *α list ref*. В соответствии со стандартными правилами let-полиморфизма, мы могли бы использовать l в выражениях, где требуются значения различных типов, например, сначала как
#l := [1];;
и затем как
#hd(!l) = true;;
Но это неприемлемо, поскольку фактически мы могли бы присвоить объекту l значение типа int, а затем использовать его как объект типа bool. Следовательно, для корректной работы со ссылками потребуются некоторые ограничения на привычные правила let-полиморфизма. Было предложено немало вариантов подобных ограничений, которые были бы одновременно и строгими, и удобными; некоторые из них оказались также и весьма сложными. В последнее время развитие различных реализаций ML, похоже, пришло к одному и тому же относительно простому методу *ограничения значения* [65]. В CAML также реализован этот подход с учётом особенностей определений верхнего уровня. В самом деле, вышеупомянутая последовательность не выполняется, но рассмотреть поведение системы в ходе вычисления промежуточных результатов будет интересно. После ввода первого выражения получим:
#let l = ref [];; l : '_a list ref = ref []
Подчёркивание в имени переменной типа обозначает, что переменная l не полиморфна в привычном смысле; правильнее сказать, что она имеет один фиксированный тип, который в данный момент еще не определён. Второе выражение также выполняется благополучно:
#l := [1];; - : unit = ()
но если посмотреть на тип l, то мы увидим:
#l;; - : int list ref = ref [1]
В данный момент значение нашего псевдо-полиморфного типа уже зафиксировано. Благодаря этому становится очевидно, что попытка вычислить следующее выражение потерпит неудачу:

#hd(!l) = true;;
Toplevel input:
>hd(!l) = true;;
>
         ^^^^
This expression has type bool,
but is used with type int.

Изложенное выше представляется вполне обоснованным, но мы всё ещё не раскрыли причин появления таких особых типовых переменных в очевидно невинных чисто функциональных выражениях, а также их частого исчезновения в ходе η-
преобразований, например:

#let I x = x;;
I : 'a -> 'a = <fun>
#I o I;;
it : '_a -> '_a = <fun>
#let I2 = I o I in fun x -> I2 x;;
- : '_a -> '_a = <fun>
#fun x -> (I o I) x;;
it : 'a -> 'a = <fun>

  Другие методы формализации понятия полиморфных ссылок зачастую основа-
ны на включении в тип выражения информации о том, что оно может содержать
ссылки. Это кажется вполне естественным, но подобный подход может привести к
тому, что типы функций будут чрезмерно загромождаться такой специальной ин-
формацией. Необходимость отражать в типе функции подробности её реализации
(функциональной либо императивной) также нельзя назвать привлекательной.
  Подход Райта, с другой стороны, использует только основной синтаксис let-
связанного выражения и перед обобщением типа утверждает, что оно является так
называемым значением. Безусловно необходимой является лишь информация, мо-
жет ли вычисление выражения привести к побочным эффектам. Но, поскольку в
общем случае эта задача неразрешима, то чтобы выяснить, является ли выражение
значением или нет, используется простой синтаксический критерий. Неформально,
выражение является значением, если оно не допускает дальнейших вычислений по
правилам ML - вот почему выражение часто может быть обращено в значение по-
средством обратного η-преобразования. К сожалению, это создаёт затруднения ме-
тодам оптимизации на основе принудительных вычислений.

## Упражнения

1. Определим комбинатор C следующим образом:
#let C f x y = f y x;;
Что делает эта функция?

#fun f l1 l2 -> itlist (union o C map l2 o f) l1 [];;

2. Что делает эта функция? Напишите более эффективную версию.
#let rec upto n = if n < 1 then [] else append (upto (n-1)) [n];;

3. Определим функцию вычисления чисел Фибоначчи:

#let rec fib =
  fun 0 -> 0
    | 1 -> 1
    | n -> fib(n - 2) + fib(n - 1);;

Почему эта функция неэффективна? Предложите лучшую реализацию.

4. Приведите пример использования данного или подобного рекурсивного исключения.
#exception Recurse of exn;;

5. Напишите простую версию быстрой сортировки массивов. Сначала массив разделяется на две части относительно некоторого ведущего элемента, а затем для левой и правой частей также рекурсивно вызывается sort. Какой рекурсивный вызов является хвостовым? Сколько требуется памяти в худшем случае? Как с помощью небольшого изменения в коде добиться значительной оптимизации?
6. Докажите, что обе упомянутые нами версии rev, неэффективная и эффективная, всегда выдают одинаковый результат.

## Глава 9 Примеры

Как уже было сказано ранее, ML изначально был спроектирован как метаязык системы автоматизированного доказательства теорем. Однако, он пригоден и для многих других приложений, взятых преимущественно из области «символьных вычислений». В этой главе мы дадим несколько характерных примеров использования ML. От читателя не требуется понимания всех деталей, например, анализа свойств приближённого представления вещественных чисел, который приводится ниже. Однако, всё же стоит опробовать эти программы на практике (в том числе и для решения других схожих задач), а также выполнить упражнения, поскольку нет лучшего способа получить представление о практическом применении ML.

## 9.1 Символьное Дифференцирование

Термин «символьные вычисления» не отличается особой строгостью; в первом приближении он охватывает приложения, в которых манипуляции с математическими *выражениями*, в общем случае содержащими переменные, преобладают над традиционными расчётами. Получили распространение различные успешные «системы компьютерной алгебры», такие как Axiom, Maple и Mathematica. Они могут выполнять полезные математические операции, например, разложение полиномов на множители, интегрирование и дифференцирование выражений, а также пригодны и для обычных вычислений. Мы покажем, как аналогичные задачи могут быть решены с помощью ML.

Символьное дифференцирование было выбрано в качестве примера потому, что алгоритм решения этой задачи прост и хорошо известен. Читатель, возможно, знаком с производными основных функций, например d dx sin(x) = cos(x), а также с правилами дифференцирования произведения и композиции функций. Каждый может систематически применить эти правила для получения производных вручную, аналогичные действия возможно реализовать и на ML в виде очевидного алгоритма.

## 9.1.1 Термы Первого Порядка

Рассмотрим математические выражения достаточно общего вида, построенные из переменных и констант, связанных операциями. Операции, в свою очередь, могут быть унарными, бинарными, тернарными, или, в общем случае, арности n. Для представления таких выражений определим следующий рекурсивный тип данных:

## 9.1. Символьное Дифференцирование Глава 9. Примеры

#type term = Var of string
          | Const of string
          | Fn of string * (term list);;
Type term defined.

Например, выражение:

$$\sin(x+y)/\cos(x-\exp(y))-\ln(1+x)$$
представляется:
Fn("-",[Fn("/",[Fn("sin",[Fn("+",[Var "x"; Var "y"])]);
Fn("cos",[Fn("-",[Var "x"; Fn("exp",[Var "y"])])])]);
Fn("ln",[Fn("+",[Const "1"; Var "x"])])]);;

## 9.1.2 Печать

Непосредственное чтение и запись выражений в виде композиции конструкторов довольно неудобны. Подобная проблема характерна для всех систем символьных вычислений, так что их интерфейс обычно содержит синтаксический анализатор (парсер) и *систему структурной печати*,1 позволяющие вводить и выводить данные в удобной для восприятия форме. Отложим пока подробное обсуждение синтаксического разбора, поскольку эта, сама по себе важная тема, будет рассматриваться далее, и ограничимся тем, что реализуем простую систему печати для наших выражений, которая позволит нам, по крайней мере, видеть происходящее. Мы хотим, чтобы эта система поддерживала традиционные соглашения о записи формул:

- Переменные и константы представляются своими именами. - Обычные n-арные функции отображаются в виде f(x1*, . . . , x*n), т. е. печатается
имя функции, за которым в скобках следует список аргументов.
- Имена инфиксных бинарных функций, таких как +, размещаются между своими аргументами.
- Скобки используются по необходимости. - Чтобы уменьшить количество скобок, для инфиксных операций определены
приоритеты.
Сначала мы объявим список инфиксных операций - список пар из имени операции и её приоритета.

#let infixes = ["+",10; "-",10; "*",20; "/",20];;
Использование списков для представления конечных частичных функций является стандартной практикой. Такие списки обычно называются ассоциативными и весьма распространены в функциональном программировании.2 Для того, чтобы конвертировать список в частичную функцию, мы воспользуемся assoc:

#let rec assoc a ((x,y)::rest) = if a = x then y else assoc a rest;;
Toplevel input:
>let rec assoc a ((x,y)::rest) = if a = x then y else assoc a rest;;
>
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning: this matching is not exhaustive.
assoc : 'a -> ('a * 'b) list -> 'b = <fun>

Компилятор предупреждает нас - вычисление функции может прерваться, если подходящие данные не будут найдены в списке. Теперь мы можем определить функцию, возвращающую приоритет операции:

#let get_precedence s = assoc s infixes;;
get_precedence : string -> int = <fun>
#get_precedence "+";;
- : int = 10
#get_precedence "/";;
- : int = 20
#get_precedence "%";;
Uncaught exception: Match_failure ("", 6544, 6601)

Обратите внимание, что если мы когда-либо изменим этот список операций, потребуется также переопределить все функции, которые его используют (такие, как get_precedence). Это является основной причиной, по которой многие программисты на языке LISP предпочитают динамическое связывание. Множество инфиксных операций можно сделать произвольно расширяемым, используя ссылки:

#let infixes = ref ["+",10; "-",10; "*",20; "/",20];;
infixes : (string * int) list ref =
 ref ["+", 10; "-", 10; "*", 20; "/", 20]
#let get_precedence s = assoc s (!infixes);;
get_precedence : string -> int = <fun>
#get_precedence "^";;
Uncaught exception: Match_failure ("", 6544, 6601)
#infixes := ("^",30)::(!infixes);;
- : unit = ()
#get_precedence "^";;
- : int = 30

Отметим, что по правилам вычисления ML разыменование указателя применяется только после того, как get_precedence получает свои аргументы, и, следовательно, её результат будет зависеть от содержимого множества операций на момент вычисления. Мы также можем задать функцию, определяющую, является ли некоторая функция инфиксной операцией. Одним из простых способов её реализации будет вычисление get_precedence с проверкой его успешного завершения:
2Для более тяжеловесных приложений лучше подойдут альтернативы, такие как хеш-таблицы,
#let is_infix s =
try get_precedence s; true with _ -> false;;
Аналогичного эффекта можно добиться при помощи универсальной функции can, которая проверяет успешность вычисления другой функции:

#let can f x = try f x; true with _ -> false;;
can : ('a -> 'b) -> 'a -> bool = <fun>
#let is_infix = can get_precedence;;
is_infix : string -> bool = <fun>

Воспользуемся некоторыми функциями, которые были рассмотрены ранее:

#let hd(h::t) = h;;
#let tl(h::t) = t;;
#let rec length l = if l = [] then 0 else 1 + length(tl l);;

и перейдём непосредственно к определению функции, преобразующей терм в строку:

#let rec string_of_term prec =
  fun (Var s) -> s
    | (Const c) -> c
    | (Fn(f,args)) ->
        if length args = 2 & is_infix f then
          let prec' = get_precedence f in
          let s1 = string_of_term prec' (hd args)
          and s2 = string_of_term prec' (hd(tl args)) in
          let ss = s1^" "^f^" "^s2 in
          if prec' <= prec then "("^ss^")" else ss
        else
          f^"("^(string_of_terms args)^")"

and string_of_terms t =
 match t with
     [] -> ""
   | [t] -> string_of_term 0 t
   | (h::t) -> (string_of_term 0 h)^","^(string_of_terms t);;

  Значением первого аргумента prec является уровень приоритета операции, для
которой текущее рассматриваемое выражение является непосредственным подтер-
мом. Если это выражение представляет собой инфиксную операцию, то скобки необ-
ходимы, если её приоритет ниже prec, например, как это происходит для право-
го подвыражения в выражении x ∗(y + z). На самом деле, мы используем скоб-
ки для более наглядной группировки даже тогда, когда prec и приоритет текущей
операции равны. В случае ассоциативных операций, вроде +, это не важно, но мы
должны различать x −(y −z) и (x −y) −z. (Более изощрённая реализация могла
бы учитывать ассоциативность каждого оператора.) Вторая, взаимно рекурсивная,
функция string_of_terms используется для печати списка термов, разделённых за-
пятыми, как это требуется для представления аргументов неинфиксных функций
вида f(t1, . . . , tn). Продемонстрируем применение наших функций печати:

#let t =
 Fn("-",[Fn("/",[Fn("sin",[Fn("+",[Var "x"; Var "y"])]);
                 Fn("cos",[Fn("-",[Var "x";
                                   Fn("exp",[Var "y"])])])]);
         Fn("ln",[Fn("+",[Const "1"; Var "x"])])]);;
t : term =
Fn
 ("-",
  [Fn
    ("/",
     [Fn ("sin", [Fn ("+", [Var "x"; Var "y"])]);
      Fn ("cos", [Fn ("-", [Var "x"; Fn ("exp", [Var "y"])])])]);
   Fn ("ln", [Fn ("+", [Const "1"; Var "x"])])])
#string_of_term 0 t;;
- : string = "sin(x + y) / cos(x - exp(y)) - ln(1 + x)"

На самом деле, от нас даже не требуется самостоятельно конвертировать терм в строку. CAML Light позволяет использовать нашу собственную процедуру для автоматической печати произвольных значений типа term в ходе диалога. Для корректного взаимодействия такой процедуры с контекстом её вызова потребуется несколько специальных команд:

##open "format";;
#let print_term s =
  open_hvbox 0;
  print_string("'"^(string_of_term 0 s)^"'");
  close_box();;
print_term : term -> unit = <fun>
#install_printer "print_term";;
- : unit = ()

Почувствуйте разницу:

#let t =
   Fn("-",[Fn("/",[Fn("sin",[Fn("+",[Var "x"; Var "y"])]);
                   Fn("cos",[Fn("-",[Var "x";
                                     Fn("exp",[Var "y"])])])]);
           Fn("ln",[Fn("+",[Const "1"; Var "x"])])]);;
t : term = 'sin(x + y) / cos(x - exp(y)) - ln(1 + x)'
#let x = t
x : term = 'sin(x + y) / cos(x - exp(y)) - ln(1 + x)'

После того, как новая процедура печати установлена, она будет использоваться всякий раз при печати значения типа term, даже если оно входит в элемент составного типа данных, например, кортежа:

#(x,t);;
- : term * term =
'sin(x + y) / cos(x - exp(y)) - ln(1 + x)',
'sin(x + y) / cos(x - exp(y)) - ln(1 + x)'

или списка:

#[x; t; x];;
- : term list =
['sin(x + y) / cos(x - exp(y)) - ln(1 + x)';
 'sin(x + y) / cos(x - exp(y)) - ln(1 + x)';
 'sin(x + y) / cos(x - exp(y)) - ln(1 + x)']

Однако, она всё же несовершенна, поскольку не в состоянии разбивать большие выражения на несколько строк. Библиотека format, которой мы воспользовались ранее, предлагает лучшее решение. Вместо преобразования терма в строку, которая будет напечатана целиком, мы можем выполнить то же самое для каждой из его составляющих, указывая при этом системе печати возможные точки разбиения на строки при помощи вызова специальных функций. Многие из принципов, использующиеся в этой и подобных системах форматированной печати, обсуждаются в работе [46]. Мы не будем рассматривать их в данном пособии, желающие могут обратиться к документации по CAML.3

## 9.1.3 Дифференцирование

Перейдём теперь к довольно простой задаче поиска производной функции. Сначала давайте вспомним, чему нас обучали в школе:

- Если выражение является суммой вида f(x) + g(x), то по правилу её дифференцирования результатом будет f ′(x) + g′(x). Аналогично для разности.
- Если выражение задано в форме f(x) ∗g(x), применяется *правило Лейбница*,
т.е. возвращается f ′(x) ∗g(x) + f(x) ∗g′(x).
- Если выражение имеет вид f(g(x)), т. е. является применением одной из стандартных функций f к некоторому подвыражению g(x), то применяется «цепное
правило» дифференцирования, результат которого: g′(x) ∗f ′(g(x)).
нах ML практически дословно:

#let rec differentiate x tm = match tm with
    Var y -> if y = x then Const "1" else Const "0"
  | Const c -> Const "0"
  | Fn("-",[t]) -> Fn("-",[differentiate x t])
  | Fn("+",[t1;t2]) -> Fn("+",[differentiate x t1;
                                differentiate x t2])
  | Fn("-",[t1;t2]) -> Fn("-",[differentiate x t1;
                                differentiate x t2])
  | Fn("*",[t1;t2]) ->
     Fn("+",[Fn("*",[differentiate x t1; t2]);
             Fn("*",[t1; differentiate x t2])])
  | Fn("inv",[t]) -> chain x t
     (Fn("-",[Fn("inv",[Fn("^",[t;Const "2"])])]))
  | Fn("^",[t;n]) -> chain x t
    (Fn("*",[n; Fn("^",[t; Fn("-",[n; Const "1"])])]))
  | Fn("exp",[t]) -> chain x t tm
  | Fn("ln",[t]) -> chain x t (Fn("inv",[t]))
  | Fn("sin",[t]) -> chain x t (Fn("cos",[t]))
  | Fn("cos",[t]) -> chain x t
     (Fn("-",[Fn("sin",[t])]))
  | Fn("/",[t1;t2]) -> differentiate x
     (Fn("*",[t1; Fn("inv",[t2])]))
  | Fn("tan",[t]) -> differentiate x
     (Fn("/",[Fn("sin",[t]); Fn("cos",[t])]))
and chain x t u =
                   Fn("*",[differentiate x t; u]);;

Вспомогательная функция chain была введена исключительно для того, чтобы избежать многократного повторения одних и тех же выражений, реализующих цепное правило, которое встречается во многих других определениях. Не считая этого дополнения, мы просто систематически применяем правила для сумм, произведений, известные производные стандартных функций и т. д. Конечно, мы могли бы, по желанию, добавить и другие функции, например, гиперболические или обратные тригонометрические. В паре случаев (для операции деления и функции tan) мы можем избежать громоздких выражений, применив правила дифференцирования к альтернативным определениям этих функций.

## 9.1.4 Упрощение

Если мы опробуем функцию differentiate на нашем текущем примере, она будет работать довольно хорошо:

#t;;
- : term = 'sin(x + y) / cos(x - exp(y)) - ln(1 + x)'
#differentiate "x" t;;
- : term =
'(((1 + 0) * cos(x + y)) * inv(cos(x - exp(y))) +
 sin(x + y) * (((1 - 0 * exp(y)) * -(sin(x - exp(y)))) *
 -(inv(cos(x - exp(y)) ^ 2)))) - (0 + 1) * inv(1 + x)'
#differentiate "y" t;;
- : term =
'(((0 + 1) * cos(x + y)) * inv(cos(x - exp(y))) +
 sin(x + y) * (((0 - 1 * exp(y)) * -(sin(x - exp(y)))) *
 -(inv(cos(x - exp(y)) ^ 2)))) - (0 + 0) * inv(1 + x)'
#differentiate "z" t;;
- : term =
'(((0 + 0) * cos(x + y)) * inv(cos(x - exp(y))) +
 sin(x + y) * (((0 - 0 * exp(y)) * -(sin(x - exp(y)))) *
 -(inv(cos(x - exp(y)) ^ 2)))) - (0 + 0) * inv(1 + x)'

В то же время, она не выполняет различные очевидные упрощения, такие как
0∗x = 0 и x+0 = x. Некоторые из этих избыточных выражений являются следствием нашей прямолинейной стратегии дифференцирования, которая, например, применяет цепное правило к f(t) даже тогда, когда t - сама переменная дифференцирования.

Вместо дальнейшего усложнения функции дифференцирования, реализуем алгоритм упрощения отдельно от неё:

#let simp =
  fun (Fn("+",[Const "0"; t])) -> t
    | (Fn("+",[t; Const "0"])) -> t
    | (Fn("-",[t; Const "0"])) -> t
    | (Fn("-",[Const "0"; t])) -> Fn("-",[t])
    | (Fn("+",[t1; Fn("-",[t2])])) -> Fn("-",[t1; t2])
    | (Fn("*",[Const "0"; t])) -> Const "0"
    | (Fn("*",[t; Const "0"])) -> Const "0"
    | (Fn("*",[Const "1"; t])) -> t
    | (Fn("*",[t; Const "1"])) -> t
    | (Fn("*",[Fn("-",[t1]); Fn("-",[t2])])) -> Fn("*",[t1; t2])
    | (Fn("*",[Fn("-",[t1]); t2])) -> Fn("-",[Fn("*",[t1; t2])])
    | (Fn("*",[t1; Fn("-",[t2])])) -> Fn("-",[Fn("*",[t1; t2])])
    | (Fn("-",[Fn("-",[t])])) -> t
    | t -> t;;

  Эта функция упрощает корневой терм выражения, а чтобы обработать его цели-
ком, нам придется выполнить обход дерева в направлении от вершин к корню. Кроме
упомянутых выше правил, касающихся констант 0 и 1, мы также выносим операцию
смены знака из произведений (выполняем преобразование (−x)∗y = −(x∗y) и т. п.).
В некоторых случаях упрощение было бы более эффективным при обходе дерева
сверху-вниз, например, для 0 ∗t и сложного выражения t, но это потребует повтор-
ного анализа подвыражений в случае термов, подобных (0 + 0) ∗2. Решение, какую
из этих двух стратегий применить, напоминает выбор между нормальным и аппли-
кативным порядком редукции в лямбда-исчислении.

#let rec dsimp =
  fun (Fn(fn,args)) -> simp(Fn(fn,map dsimp args))
    | t -> simp t;;

Упрощение результата дифференцирования существенно его улучшает:

#dsimp(differentiate "x" t);;
- : term =
'(cos(x + y) * inv(cos(x - exp(y))) +
 sin(x + y) * (sin(x - exp(y)) *
 inv(cos(x - exp(y)) ^ 2))) - inv(1 + x)'
#dsimp(differentiate "y" t);;
- : term =
'cos(x + y) * inv(cos(x - exp(y))) -
 sin(x + y) * ((exp(y) * sin(x - exp(y))) *
 inv(cos(x - exp(y)) ^ 2))'
#dsimp(differentiate "z" t);;
- : term = '0'

Вообще говоря, всегда можно добавить более изощрённые правила упрощения.

Например, рассмотрим:

#let t2 = Fn("tan",[Var "x"]);;
t2 : term = 'tan(x)'
#differentiate "x" t2;;
- : term =
'(1 * cos(x)) * inv(cos(x)) +
 sin(x) * ((1 * -(sin(x))) * -(inv(cos(x) ^ 2)))'
#dsimp(differentiate "x" t2);;
- : term = 'cos(x) * inv(cos(x)) +
           sin(x) * (sin(x) * inv(cos(x) ^ 2))'

Мы могли бы упростить cos(x) * inv(cos(x)) до 1, пренебрегая, как это делает большинство коммерческих систем компьютерной алгебры, возможностью обращения cos(x) в нуль. Чтобы добиться этого, добавим очевидные правила. Аналогично, также возможно было бы сгруппировать множители во втором слагаемом. Однако, в этом случае мы сталкиваемся с необходимостью учитывать человеческий фактор.

Какой из возможных вариантов упрощения предпочтительней? Автоматическое принятие решения может оказаться затруднительным. В нашем случае, упростив второе слагаемое, получаем:
sin(x) * (sin(x) * inv(cos(x) ^ 2)) sin(x) ^ 2 * inv(cos(x) ^ 2) sin(x) ^ 2 / cos(x) ^ 2 (sin(x) / cos(x)) ^ 2 tan(x) ^ 2
Выражение в целом примет вид:
1 + tan(x) ^ 2
Следует ли оставить его как есть, либо продолжить преобразования, заменив на sec(x) ^ 2
Такая запись и короче, и привычнее. Тем не менее, такое решение основывается на том, что мы знаем определения довольно редко используемых тригонометрических функций, вроде sec. Какое бы решение ни было принято машиной, вероятнее всего найдётся пользователь, которого оно не устроит.

## 9.2 Синтаксический Анализ

Недостатком предыдущего примера является необходимость задавать входные данные в виде композиции конструкторов типов. В этом разделе мы рассмотрим задачу построения формального языка описания выражений и разработки его синтаксического анализатора. Изложенный подход будет при этом достаточно общим, чтобы впоследствие легко применяться к аналогичным языкам.

Сформулируем задачу синтаксического анализа в общем виде. Формальный язык определяется своей *грамматикой*, которая задаёт множество продукций (правил вывода) для каждой синтаксической категории. Для языка термов, включающих лишь две инфиксные операции, + и *, а также числовые константы (0, 1, . . . ) и переменные с алфавитно-цифровыми именами, грамматика может выглядеть так:

term
−
→
name(*termlist*)
|
name
|
(*term*)
|
numeral
|
-term
|
term + term
|
term * term
termlist
−
→
term,termlist
|
term

На данный момент будем предполагать, что нам заранее известны множества допустимых имён и числовых констант, но мы могли бы также определить их при помощи аналогичных правил на основе символов входного алфавита. Заданное множество продукций предоставляет нам способ порождения конкретного линейного представления всевозможных термов. Отметим, что имена вида name, numeral, term и *termlist* обозначают синтаксические *метапеременные*, а набранные полужирным шрифтом символы «+», «(» и так далее - принадлежат входному языку. Рассмотрим пример применения правил вывода:

term
     −
      →
          term * term
     −
      →
          term * (term)
     −
      →
          term * (term + term)
     −
      →
          term * (term + term * term)
     −
      →
          numeral * (name + name * name)

откуда, подставив вместо name и *numeral* некоторые значения из соответствующих множеств, мы можем породить такую строку:
10 * (x + y * z)
Задача *синтаксического анализа (разбора)* преследует прямо противоположную цель - восстановить последовательность применения правил вывода, то есть по заданной строке определить, каким образом она могла быть порождена. Как правило, результатом анализа является *дерево разбора,* наглядно демонстрирующее порядок выбора продукций.

Одной из проблем, возникающей в ходе синтаксического анализа, является неоднозначность грамматики, т. е. возможность порождения заданной строки несколькими различными способами. В рассмотренном выше примере та же самая строка могла быть порождена иным путём:

term
     −
      →
          term * term
     −
      →
          term * (term)
     −
      →
          term * (term * term)
     −
      →
          term * (term + term * term)
     −
      →
          numeral * (name + name * name)

  Очевидная возможность устранения неоднозначности - назначение инфиксным
операциям приоритетов и ассоциативности. Кроме того, мы можем добиться такого
же эффекта без привлечения дополнительных механизмов за счёт добавления новых
синтаксических категорий:

atom
−
→
name(*termlist*)
|
name
|
numeral
|
(*term*)
|
-atom
mulexp
−
→
atom * mulexp
|
atom
term
−
→
mulexp + term
|
mulexp
termlist
−
→
term, termlist
|
term

Отметим, что такая модификация грамматики делает обе инфиксные операции правоассоциативными. Более сложным примером использования этого приёма служит формальное определение понятия «выражение» в стандарте ANSI C.

## 9.2.1 Метод Рекурсивного Спуска

Строение правил вывода подсказывает очень простой алгоритм синтаксического анализа при помощи множества взаимно рекурсивных функций. Его суть в том, что для каждой синтаксической категории вводится своя функция, причём структура рекурсивных вызовов соответствует зависимости одних продукций от других.

Например, процедура анализа термов term при получении из входной последовательности символа - будет рекурсивно вызывать саму себя для анализа аргумента операции, а при встрече имени, за которым следует открывающая скобка, обратится к процедуре termlist. Последняя, в свою очередь, вызовет term не менее одного раза, и так далее. Такой подход естественно выражается на языке, подобном ML, для которого рекурсия служит одной из основных управляющих конструкций.

Предположим, что наш синтаксический анализатор, реализованный средствами ML, получает в качестве входной последовательности список объектов некоторого типа α. Возможно, чтобы входная последовательность состояла из простых символов, но на практике обычно вводится дополнительный уровень лексического анализа, в ходе которого символы группируются в *лексемы (токены),* например, «x12», «:=» и «96», так что входная последовательность состоит уже из лексем, о типе которых мы не будем делать предположений. Аналогично, будем считать, что анализатор производит результат типа β. Этот результат может быть, например, деревом разбора, представленным рекурсивным типом данных, либо просто числом, если анализатор предназначен для разбора выражения и его вычисления одновременно. В общем случае, анализатор может не обработать входную последовательность полностью, так что нам потребуется вернуть в дополнение к результату разбора ещё и список необработанных лексем. Таким образом, тип анализатора:

## (Α)List →Β × (Α)List

Например, для входной последовательности (x + y) * z функция atom должна обработать (x + y) и вернуть * z. Результирующее дерево разбора принятой части входа может быть представлено значением рекурсивного типа, введённого ранее. Отсюда мы имеем atom " (x␣+␣y) ␣∗␣z" = Fn( "+" , [ Var "x" ; Var "y" ] ) , "∗␣z"
Поскольку любое обращение к функции atom должно происходить из функции mulexp, то последняя будет использовать результат, полученный вычислением atom, а также обрабатывать оставшиеся лексемы, вызывая повторно atom для анализа подвыражения z.

## 9.2.2 Комбинаторы Синтаксического Анализа

Ещё одна причина, по которой предложенный метод разбора особенно хорошо подходит для реализации на языке ML, это возможность определения некоторых полезных комбинаторов, при помощи которых новые анализаторы легко создаются на базе уже существующих. Определив эти комбинаторы как инфиксные операции, мы в состоянии придать программе синтаксического анализатора вид, очень схожий со структурой исходной грамматики.

Для начала введём исключение, сигнализирующее об ошибках анализа. Далее определим инфиксную операцию ++, которая применяет два анализатора последовательно, объединяя их результаты, а также инфиксную операцию ||, которая вначале делает попытку применить один из анализаторов, а затем - второй. Операция many представляет собой свёртку относительно ++, т. е. применяет заданный анализатор максимально возможное количество раз, выдавая список результатов. Наконец, инфиксная операция >> применяется для завершающей обработки результатов анализа заданной функцией.

Согласно синтаксису CAML, идентификаторы наподобие ++ автоматически считаются инфиксными операциями, поэтому определение операций включает временную блокировку этой возможности при помощи ключевого слова prefix. Приоритеты также задаются автоматически по первым символам идентификаторов и полагаются равными приоритетам арифметических операций, обозначенных этими символами.

Таким образом, приоритет ++ наивысший, >> - средний, || - низший, что нам и требуется.

exception Noparse ; ;

let
    p r e f i x
            | |
                parser1
                         parser2
                                  input =
  try
      parser1
                input
  with Noparse −> parser2
                              input ; ;

let
p r e f i x ++ parser1
parser2
input =
let
result1 , rest1 = parser1
input in
let
result2 , rest2 = parser2
rest1
in
( result1 , r e s u l t 2 ) , rest2 ; ;

let rec many parser
                    input =
  try
      let
          result , next = parser
                                input in
      let
          r es u lt s , r e s t = many parser
                                      next in
      ( r e s u l t : : r e s u l t s ) , r e s t
 with Noparse −> [ ] , input ; ;

let
p r e f i x >> parser
treatment
input =
let
result , r e s t = parser
input in
treatment ( r e s u l t ) , r e s t ; ;
использует встроенные функции sub_string и string_length, которые не рассматривались, но их назначение легко понять из примера.

let rec itlist f =
fun [] b -> b
| (h::t) b -> f h (itlist f t b);;
let uncurry f(x,y) = f x y;; let K x y = x;; let C f x y = f y x;; let o f g x = f(g x);; #infix "o";;

let explode s =
 let rec exap n l =
     if n < 0 then l else
     exap (n - 1) ((sub_string s n 1)::l) in
 exap (string_length s - 1) [];;

  Для начала, определим некоторые «атомарные» анализаторы. Функция some при-
нимает любой входной символ, удовлетворяющий заданному предикату, и возвраща-
ет его. Функция a выполняет схожее действие, с той разницей, что она проверяет
входной символ на равенство заданному. Наконец, finished предназначена для про-
верки того, что вся входная последовательность была обработана.

let some p =
  fun
       [ ] −> raise Noparse
    |
      (h : : t ) −> i f p h then (h , t )
                                       else
                                             raise Noparse ; ;

let a tok = some (fun item −> item = tok ) ; ;

let
    f i n i s h e d
               input =
  i f
     input = [ ]
                  then 0 , input
                                 else
                                       raise Noparse ; ;

## 9.2.3 Лексический Анализ

анализатора нашего языка термов. Прежде всего, определим тип, представляющий лексемы (токены), после чего реализуем лексический анализатор, преобразующий входную последовательность в список лексем. Лексической категории Other соответствуют обозначения операций и т. п., причём в нашем случае все они весьма просты и состоят лишь из одного символа (в отличие от составных обозначений, таких как :=).

type token = Name of
                     s t r i n g
                             | Num of
                                      s t r i n g
                                             |
                                               Other of
                                                        s t r i n g ; ;

let
    lex =
  let
       s e v e r a l p = many ( some p) in
  let
       lowercase_letter
                          s = "a" <= s & s <= "z" in
  let
      uppercase_letter
                          s = "A" <= s & s <= "Z" in
  let
       l e t t e r
               s = lowercase_letter
                                       s
                                         or
                                             uppercase_letter
                                                                 s in
  let
      alpha
             s = l e t t e r
                          s
                             or
                                s = "_" or
                                             s = " ' " in
  let
       d i g i t
             s = "0" <= s & s <= "9" in
  let alphanum s = alpha s
                               or
                                   d i g i t
                                         s in
  let
      space
             s = s = "␣" or
                               s = "\n" or
                                             s = "\ t " in
  let
       c o l l e c t (h , t ) = h^( i t l i s t
                                    ( p r e f i x
                                             ^) t "" ) in
  let rawname =
     some alpha ++ s e v e r a l alphanum >> (Name o
                                                      c o l l e c t ) in
  let rawnumeral =
     some
           d i g i t ++ s e v e r a l
                               d i g i t >> (Num o
                                                  c o l l e c t ) in
  let
      rawother = some (K true ) >> Other in
  let
      token =
    (rawname
               | |
                  rawnumeral
                               | |
                                  rawother ) ++ s e v e r a l
                                                           space >> f s t
                                                                          in
  let
      tokens = ( s e v e r a l
                           space ++ many token ) >> snd in
  let
       a l l t o k e n s = ( tokens ++ f i n i s h e d ) >> f s t
                                                     in
  f s t
      o a l l t o k e n s o explode ; ;

Например,

#lex "sin(x + y) * cos(2 * x + y)";;
- : token list =
[Name "sin"; Other "("; Name "x"; Other "+"; Name "y"; Other ")";
 Other "*"; Name "cos"; Other "("; Num "2"; Other "*"; Name "x";
 Other "+"; Name "y"; Other ")"]

## 9.2.4 Анализатор Термов

Для завершения перехода от анализа отдельных символов к анализу лексем, введём базовые анализаторы, принимающие лексемы заданной категории:
let name =
fun (Name s : : r e s t ) −> s , r e s t
| _ −> **raise** Noparse ; ;

let
    numeral =
  fun (Num s : : r e s t ) −> s , r e s t
    | _ −> raise Noparse ; ;

let
    other =
  fun ( Other s : : r e s t ) −> s , r e s t
    | _ −> raise Noparse ; ;

С помощью этих функций мы можем определить анализатор термов в виде, очень схожем с исходной грамматикой. Основное различие состоит в том, что каждой продукции сопоставлено некоторое действие, результат которого возвращается как результат анализа.

let rec atom input
      = (name ++ a ( Other " ( " ) ++ t e r m l i s t ++ a ( Other " ) " )
              >> (fun ( ( ( name ,_) , args ) ,_) −> Fn(name , args ))
       | |
          name
              >> (fun s −> Var s )
       | |
          numeral
              >> (fun s −> Const s )
       | |
          a ( Other " ( " ) ++ term ++ a ( Other " ) " )
              >> ( snd o
                         f s t )
       | |
          a ( Other "−" ) ++ atom
              >> snd )
                       input
 and mulexp input
      = (atom ++ a ( Other "∗" ) ++ mulexp
              >> (fun (( a ,_) ,m) −> Fn( "∗" , [ a ;m] ) )
       | |
          atom)
                input
 and term input
      = ( mulexp ++ a ( Other "+" ) ++ term
              >> (fun (( a ,_) ,m) −> Fn( "+" , [ a ;m] ) )
       | |
          mulexp )
                  input
 and t e r m l i s t
               input
      = ( term ++ a ( Other " , " ) ++ t e r m l i s t
              >> (fun (( h ,_) , t ) −> h : : t )
       | |
          term
              >> (fun h −> [ h ] ) )
                                  input ; ;

Объединим определённые ранее примитивы в единую функцию:

let
    parser = f s t
                   o ( term ++ f i n i s h e d >> f s t ) o lex ; ;

Наглядной иллюстрацией работы этой функции является её вызов до и после установки специализированной функции вывода (см. выше):

#parser "sin(x + y) * cos(2 * x + y)";;
- : term =
Fn
 ("*",
  [Fn ("sin", [Fn ("+", [Var "x"; Var "y"])]);
   Fn ("cos", [Fn ("+", [Fn ("*", [Const "2"; Var "x"]);
                         Var "y"])])])
#install_printer "print_term";;
- : unit = ()
#parser "sin(x + y) * cos(2 * x + y)";;
- : term = 'sin(x + y) * cos(2 * x + y)'

## 9.2.5 Автоматический Учёт Приоритетов

Синтаксический анализатор, рассмотренный выше, реализует разбор двух инфиксных операций в явном виде. Однако, для большего удобства и согласованности с нашим подходом к выводу выражений, следует учесть введённую ранее информацию о множестве доступных инфиксных операций. Более того, наличие даже двух различных бинарных операций заставляет прибегать к искусственным приёмам при построении грамматики и программы разбора - нетрудно представить себе, во что превратится работа, например, с дюжиной таких операций. Таким образом, несомненна полезность автоматического порождения иерархии анализаторов для каждой доступной операции, упорядоченных согласно их приоритетам. Решение этой задачи достаточно просто. Прежде всего, зададим обобщённую функцию, которая принимает в качестве аргумента анализатор синтаксической категории, которая на данном уровне приоритета считается атомарным выражением, и возвращает новый анализатор, предназначенный для разбора последовательности таких атомарных выражений, объединённых заданной операцией. Заметим, что того же эффекта мы можем добиться при помощи нашего набора комбинаторов, но функция, приведённая ниже, проще и эффективнее.

let rec binop op parser
                         input =
  let atom1 , rest1
                  as
                      r e s u l t = parser
                                      input in
  i f
     not
         rest1 = [ ] & hd rest1 = Other op then
    let atom2 , rest2 = binop op parser
                                       ( t l
                                            rest1 ) in
   Fn(op , [ atom1 ;
                  atom2 ] ) , rest2
  else
       r e s u l t ; ;

Далее определим функции, которые извлекают из нашего ассоциативного списка очередную операцию с наименьшим (равным предыдущему) приоритетом. Если список был заранее сортирован по приоритетам, мы можем просто выбирать очередной элемент по порядку следования.

let
    findmin
              l = i t l i s t
  (fun (_, pr1 as p1 )
                        (_, pr2 as p2 ) −> i f
                                               pr1 <= pr2 then p1 else p2 )
  ( t l
       l )
          (hd l ) ; ;

let rec
        delete x (h : : t ) = i f h = x then t
                                            else h : : ( delete x t ) ; ;

Обобщённый анализатор множества бинарных операций с приоритетами:

let rec precedence
                    i l i s t
                          parser
                                 input =
  i f
     i l i s t = [ ]
                then parser
                             input
                                   else
  let opp = findmin
                     i l i s t
                           in
  let
      i l i s t ' = delete opp
                           i l i s t
                                 in
  binop ( f s t
             opp )
                  ( precedence
                               i l i s t '
                                      parser )
                                               input ; ;

let rec atom input
      = (name ++ a ( Other " ( " ) ++ t e r m l i s t ++ a ( Other " ) " )
              >> (fun ( ( ( name ,_) , args ) ,_) −> Fn(name , args ))
       | |
          name
              >> (fun s −> Var s )
       | |
          numeral
              >> (fun s −> Const s )
       | |
          a ( Other " ( " ) ++ term ++ a ( Other " ) " )
              >> ( snd o
                         f s t )
       | |
          a ( Other "−" ) ++ atom
              >> snd )
                       input
 and term input = precedence
                               ( ! i n f i x e s ) atom input
 and t e r m l i s t
               input
      = ( term ++ a ( Other " , " ) ++ t e r m l i s t
              >> (fun (( h ,_) , t ) −> h : : t )
       | |
          term
              >> (fun h −> [ h ] ) )
                                  input ; ;

let
    parser = f s t
                   o ( term ++ f i n i s h e d >> f s t ) o lex ; ;

Пример разбора выражения:

#parser "2 * sin(x)^2 + 2 * sin(y)^2 - 2";;
- : term =
Fn
 ("+",
  [Fn ("*", [Const "2"; Fn ("^", [Fn ("sin", [Var "x"]);
                                  Const "2"])]);
   Fn
    ("-",
     [Fn ("*", [Const "2"; Fn ("^", [Fn ("sin", [Var "y"]);
                                     Const "2"])]);
      Const "2"])])
#install_printer "print_term";;
- : unit = ()
#parser "2 * sin(x)^2 + 2 * sin(y)^2 - 2";;
- : term = '2 * sin(x) ^ 2 + (2 * sin(y) ^ 2 - 2)'

## 9.2.6 Недостатки Метода

Наш подход к лексическому и синтаксическому анализу не отличается особой эффективностью. Действительно, CAML и некоторые другие реализации языка ML включают генератор синтаксических анализаторов для LR-грамматик, аналогичный популярной в Unix-среде системе YACC (Yet Another Compiler Compiler) для языка C. Эти генераторы не только охватывают более широкий класс грамматик, но и производят более эффективные анализаторы. Однако, мы считаем, что предложенный метод достаточно прозрачен, приемлем в большинстве случаев и является хорошим введением в программирование с использованием функций высших порядков.

Небольшая доработка некоторых особенно ресурсоёмких фрагментов анализатора может заметно улучшить его общую эффективность. Так, при наличии в одной синтаксической категории нескольких продукций с общим префиксом, следует избегать его многократного анализа, который может оказаться нетривиальным. Примером подобной ситуации служат правила вывода для термов:

term
−
→
name(*termlist*)
|
name
|
· · ·

Мы намеренно поместили в ходе реализации более длинное правило первым, так как в противном случае успешное чтение имени приведёт в дальнейшем к отказу при попытке разбора списка аргументов. Однако, возникающее при этом повторное сканирование избыточно. В данном случае цена избыточности невелика, поскольку повторному анализу подвергается лишь одна лексема, но потенциальные накладные расходы при разборе *termlist* могут оказаться более существенными:

let
     . . .
and t e r m l i s t
               input
     = ( term ++ a ( Other " , " ) ++ t e r m l i s t
             >> (fun (( h ,_) , t ) −> h : : t )
      | |
         term
             >> (fun h −> [ h ] ) )
                                    input ; ;

В отличие от предыдущего примера, здесь повторному сканированию в случае возврата подвергается целый терм, который может быть сколь угодно сложным. Существуют различные способы избежать этого. Например, мы можем преобразовать правила вывода так, чтобы выбор одного из них происходил уже после того, как прочитан начальный терм. Комбинатор many позволяет легко устранить явную рекурсию:

let
     . . .
and t e r m l i s t
               input
    = term ++ many ( a ( Other " , " ) ++ term >> snd )
             >> (fun (h , t ) −> h : : t )
                                         input ; ;

let rec atom input
      = (name ++ a ( Other " ( " ) ++ t e r m l i s t ++ a ( Other " ) " )
              >> (fun ( ( ( name ,_) , args ) ,_) −> Fn(name , args ))
       | |
          name
              >> (fun s −> Var s )
       | |
          numeral
              >> (fun s −> Const s )
       | |
          a ( Other " ( " ) ++ term ++ a ( Other " ) " )
              >> ( snd o
                         f s t )
       | |
          a ( Other "−" ) ++ atom
              >> snd )
                       input
 and term input = precedence
                               ( ! i n f i x e s ) atom input
 and t e r m l i s t
               input
        = ( term ++ many ( a ( Other " , " ) ++ term >> snd )
              >> (fun (h , t ) −> h : : t ))
                                       input ; ;

   Общим недостатком нашего подхода и метода рекурсивного спуска в целом явля-
ются проблемы с разбором леворекурсивных грамматик. Правило вывода некоторой
синтаксической категории называется леворекурсивным, если его правая часть начи-
нается с этой же категории. Например, если бы мы попытались определить в нашей
грамматике левоассоциативную операцию сложения, это можно было бы выразить
так:

term
−
→
term + mulexp
|
mulexp

Прямое отображение этих правил вывода на язык ML приведёт к зацикливанию, поскольку функция term будет вызываться для одного и того же подвыражения снова и снова. Существуют различные, причём не слишком универсальные, способы решения проблемы. Например, мы можем реализовать в явном виде цикл вместо рекурсии, применение которой в данном контексте не имеет под собой особых оснований. Для этого воспользуемся стандартными комбинаторами наподобие many, чтобы получить список деревьев разбора подвыражений вида *mulexp*, после чего построим по этому списку результирующее левоассоциативное дерево.

В заключение отметим, что наша обработка ошибок разбора не отличается особой элегантностью. При возникновении любого затруднения мы порождаем исключение Noparse, обработка которого представляет собой возврат. Такое поведение, однако, не всегда подходит для типичных грамматик. В лучшем случае, оно приведёт к интенсивному повторному сканированию, но может вызвать и последовательность возвратов вплоть до корня дерева разбора. Например, встретив в ходе анализа подвыражение 5 + мы ожидаем, что вслед за символом + следует очередной терм. Если он не был найден, следует выдать пользователю внятное сообщение об ошибке вместо простой генерации Noparse и, возможно, последующих безуспешных попыток разобрать выражение другим путём.

## 9.3 Точная Арифметика Вещественных Чисел

Машинная реализация вещественной арифметики обычно использует приближённое представление чисел в формате с плавающей точкой. В общем случае, мы можем оперировать вещественными числами (либо вручную, либо при помощи компьютера) лишь в том случае, когда они имеют то или иное конечное представление. Возникает вопрос, уместно ли говорить о 'существовании' чисел, которые не представимы в конечной форме. Например, Кронекер признавал целые и рациональные числа, поскольку их можно задать точно, а также *алгебраические* числа4, представимые многочленами, корнями которых они являются. Однако, он отвергал трансцендентные числа, как не имеющие конечного представления. Говорят, что когда Кронекеру попалось на глаза известное доказательство трансцендентности числа π [36], он якобы отозвался о нём так: «интересно, если не принимать во внимание того, что числа π
не существует».

Учитывая современные достижения, мы можем сказать, что конечное представление в принципе возможно для гораздо большего количества чисел, чем те, существование которых признавалось Кронекером. Этим представлением являются программы (или, вообще говоря, *правила*) вычисления требуемых чисел с произвольной заданной разрядностью. Например, мы можем написать программу, вычисляющую для заданного n первые n знаков числа π или же рациональное число r такое, что |π −r| < 2−n. Независимо от того, какой из подходов был выбран для последовательного уточнения вещественного числа, важнейшим его свойством является конечность программы-представления.

Такой подход особенно хорошо реализуется на языках, подобных ML, при помощи функций высших порядков. То, что мы называли выше «программой», в ML- реализации становится просто функцией. Арифметические операции при этом представимы функциями высших порядков, которые по заданным аппроксимациям x и y конструируют аппроксимации для x + y, xy, sin(x) и т.д. В более традиционных языках программирования нам пришлось бы задать конкретное представление программ, например, гёделеву нумерацию, и реализовать для него интерпретатор.5

## 9.3.1 Выбор Представления Вещественных Чисел

Каждому вещественному числу x поставим в соответствие функцию fx : N →
Z, которая для произвольного n ∈N возвращает масштабированное приближённое значение x с точностью 2−n:
|fx(n) −2nx| < 1.

В свою очередь, данное выражение эквивалентно | fx(n)
2n
−x| <
1
2n. Также возможно непосредственное вычисление рационального приближённого значения, но для удобства вычислений важно, чтобы знаменатели всех вычисляемых величин были предарифметикой. Выбор 2 в качестве основания произволен. Малые основания предпочтительнее тем, что позволяют подбирать подходящую точность более гибко. Например, выбор основания 10 ведёт к тому, что даже при необходимости небольшого увеличения точности представления мы вынуждены увеличивать её в 10 раз.

## 9.3.2 Целые Числа Произвольной Разрядности

Стандартный целочисленный тип (int) в CAML имет довольно ограниченный диапазон представимых значений, поэтому нам прежде всего потребуется возможность оперировать целыми числами неограниченной разрядности. Программная реализация подобной арифметики не слишком сложна, но несколько утомительна. К
счастью, версия CAML Light, установленная на Thor, уже включает в себя библиотеку быстрых алгоритмов целочисленной (на самом деле, рациональной) арифметики. Предположим, что конфигурация системы задаёт следующие пути поиска исполнимых файлов:
PATH
="$PATH:/ home/ jrh13 /caml/ bin "
export PATH
В этом случае CAML-система с поддержкой «длинной» арифметики запускается командой:
$ camllight my_little_caml После запуска системы используйте директиву #open для получения доступа ко всем функциям библиотеки:
##open "num";;
В библиотеке определяется новый тип данных num, представляющий рациональные числа произвольной разрядности, среди которых нам понадобится лишь подмножество целых чисел. Язык CAML не предоставляет возможности перегрузки операций, поэтому для обозначения арифметических действий над num приходится использовать другие символы.

Отметим, что числа-константы типа num должны задаваться как Int k, а не просто k. Фактически, Int является конструктором типа num и применяется в случае, когда число имеет прямое машинное представление. Большие числа конструируются Big_int.

Унарная операция смены знака величины типа num обозначается minus_num. Ещё
одна полезная унарная операция - abs_num, которая вычисляет абсолютную величину аргумента, т. е. по заданному x возвращает |x|.

Помимо унарных, в наше распоряжение предоставлен стандартный набор бинарных операций. Операции целочисленного деления и вычисления остатка, обозначенные quo_num и mod_num, не являются инфиксными. В то же время, большинство прочих бинарных операций определены как инфиксные с именами, полученными добавлением символа "/" к именам аналогичных операций над типом int. Важно помнить, что в общем случае требуется использовать =/ для сравнения чисел. Причина этого в том, что конструкторы типа num, как всегда, различны по определению, но могут пересекаться по интерпретации представляемых значений. Например, в ходе вычисления частного 230 и 2 при помощи двух доступных операций деления мы можем получить результаты, численно равные, но различные с точки зрения языка, поскольку в одном случае будет использован конструктор Int, а в другом - Ratio.

#(Int 2 **/ Int 30) // Int 2 = quo_num (Int 2 **/ Int 30) (Int 2);;
it : bool = false
#(Int 2 **/ Int 30) // Int 2 =/ quo_num (Int 2 **/ Int 30) (Int 2);;
it : bool = true

Полный список инфиксных операций:

| Оператор           | Тип                |
|--------------------|--------------------|
| **/                | num -> num -> num  |
| Вычисление степени |                    |
| */                 | num -> num -> num  |
| Умножение          |                    |
| +/                 | num -> num -> num  |
| Сложение           |                    |
| -/                 | num -> num -> num  |
| Вычитание          |                    |
| =/                 | num -> num -> bool |
| Равенство          |                    |
| <>/                | num -> num -> bool |
| Неравенство        |                    |
| </                 | num -> num -> bool |
| Меньше, чем        |                    |
| <=/                | num -> num -> bool |
| Меньше либо равно  |                    |
| >/                 | num -> num -> bool |
| Больше, чем        |                    |
| >=/                | num -> num -> bool |
| Больше либо равно  |                    |

Пример использования операций:

#Int 5 */ Int 14;;
it : num = Int 70
#Int 2 **/ Int 30;;
it : num = Big_int <abstr>
#(Int 2 **/ Int 30) // Int 2;;
it : num = Ratio <abstr>
#quo_num (Int 2 **/ Int 30) (Int 2);;
it : num = Int 536870912

  Отметим, что числа типа num по умолчанию не выводятся. Однако, мы всегда
можем преобразовать их в строки при помощи функции string_of_num.

#string_of_num(Int 2 ** Int 150);;
- : string = "1427247692705959881058285969449495136382746624"

Аналогично делается и обратное преобразование, реализуемое функцией с вполне
естественным именем num_of_string.

## 9.3.3 Основные Операции

Напомним, что для вещественных чисел нами было выбрано представление в виде функций Z →Z. Реализация на языке ML в действительности будет использовать int -> num, поскольку диапазона значений встроенного целочисленного типа

#let real_of_int k n = (Int 2 **/ Int n) */ Int k;;
real_of_int : int -> int -> num = <fun>
#real_of_int 23;;
- : int -> num = <fun>

Очевидно, что для произвольного k справедлив критерий аппроксимации:

$$|f_{k}(n)-2^{n}k|=|2^{n}k-2^{n}k|=0<1$$
Определим первую нетривиальную операцию - смену знака.

let real_neg f n = minus_num( f n ) ; ;
Компилятор для этой функции выводит более общий тип, чем требуется, но это не создаст трудностей. Достаточно легко убедиться, что критерий аппроксимации не нарушается. Если нам известно, что для любого n выполняется

$$|f_{x}(n)-2^{n}x|<1,$$
то из этого следует

$$\begin{array}{r c l}{{|f_{-x}(n)-2^{n}(-x)|}}&{{=}}&{{|-f_{x}(n)-2^{n}(-x)|}}\\ {{}}&{{=}}&{{|-\left(f_{x}(n)-2^{n}x\right)|}}\\ {{}}&{{=}}&{{|f_{x}(n)-2^{n}x|}}\\ {{}}&{{<}}&{{1}}\end{array}$$
Аналогично, мы можем определить вычисление абсолютной величины вещественных чисел, используя функцию abs_num:
let real_abs f n = abs_num ( f n ) ; ;
Доказательство корректности этого определения также не представляет трудности, принимая во внимание, что ||x| −|y*|| ≤|*x −y|.

Перейдём к следующей задаче - сложению двух вещественных чисел. Предположим, что x и y представлены как fx и fy соответственно. Определим сложение так:
fx+y(n) = fx(n) + fy(n).

Однако, такое определение не гарантирует соблюденния критерия аппроксимации:

$$|f_{x+y}(n)-2^{n}(x+y)|=|f_{x}(n)+f_{y}(n)-2^{n}(x+y)|$$ $$\leq|f_{x}(n)-2^{n}x|+|f_{y}(n)-2^{n}y|$$

Moxho yrepecpazar, t${}_{\rm T}$Otovka na prishobad "necuencia" na prishemarer 2, a ro pencza na, kaz kripreprinta opuammera I. C. C.Upcoremaho, b. Jaumo curva e naz pruefyecer- es bastanteurf $x$ u $y$ e _6 ausque_ a pasapologueno, veai pruefyecriy or pey:urara opeuquantit. I'De:uuo:zakt, t${}_{\rm T}$

$$f_{x+y}(n)=(f_{x}(n+1)+f_{y}(n+1))/2.$$
Это, в свою очередь, даёт

$$|f_{x+y}(n)-2^{n}(x+y)|=|(f_{x}(n+1)+f_{y}(n+1))/2-2^{n}(x+y)|$$ $$\leq|f_{x}(n+1)/2-2^{n}x|+|f_{y}(n+1)/2-2^{n}y|$$ $$=\frac{1}{2}|f_{x}(n+1)-2^{n+1}x|+\frac{1}{2}|f_{y}(n+1)-2^{n+1}y|$$ $$<\frac{1}{2}1+\frac{1}{2}1=1$$
Очевидно, что такое определение достигает желаемой точности. Однако, в нём неявно используется операция деления вещественных чисел. Поскольку функция должна возвращать целочисленный результат, частное требуется округлить. Если мы вычислим частное при помощи quo_num, ошибка округления составит почти 1 и не позволит достичь требуемой точности независимо от точности вычисления аргументов. В то же время, затратив чуть больше усилий, мы можем определить функцию деления, которая всегда будет возвращать целое число, ближайшее к точному результату (или одно из двух ближайших, если расстояние до них оказывается одинаковым), так что ошибка округления никогда не превысит 1
2. Такая функция может быть реализована в целочисленной арифметике, но будет проще всего воспользоваться операцией деления рациональных чисел с последующим округлением частного к ближайшему целому, поскольку для этих действий уже определены встроенные функции:

#let ndiv x y = round_num(x // y);;
ndiv : num -> num -> num = <fun>
##infix "ndiv";;
#(Int 23) ndiv (Int 5);;
- : num = Int 5
#(Int 22) ndiv (Int 5);;
- : num = Int 4
#(Int(-11)) ndiv (Int 4);;
- : num = Int -3
#(Int(-9)) ndiv (Int 4);;
- : num = Int -2

Если мы определим операцию сложения с учётом сказанного выше,

$$f_{x+y}(n)=(f_{x}(n+2)+f_{y}(n+2)){\mathrm{~ndiv~}}4,$$
всё будет работать, как требуется:

$$|f_{x+y}(n)-2^{n}(x+y)|=|((f_{x}(n+2)+f_{y}(n+2))\ {\rm ndiv}\ 4)-2^{n}(x+y)|$$ $$\leq\frac{1}{2}+|(f_{x}(n+2)+f_{y}(n+2))/4-2^{n}(x+y)|$$ $$=\frac{1}{2}+\frac{1}{4}|(f_{x}(n+2)+f_{y}(n+2))-2^{n+2}(x+y)|$$ $$\leq\frac{1}{2}+\frac{1}{4}|f_{x}(n+2)-2^{n+2}x|+\frac{1}{4}|f_{y}(n+2)-2^{n+2}y|$$ $$<\frac{1}{2}+\frac{1}{4}1+\frac{1}{4}1$$ $$=1$$

let
    real_add
               f g n =
  ( f (n + 2) +/ g (n + 2))
                             ndiv ( Int
                                        4 ) ; ;

Аналогичные рассуждения могут быть использованы для определения операции вычитания, но проще всего построить её на основе уже введённых функций:
#let real_sub f g = real_add f (real_neg g);; real_sub : (num -> num) -> (num -> num) -> num -> num = <fun>
Реализация умножения, вычисления обратных чисел и деления потребует в общем случае несколько больших усилий. Однако, частные случаи умножения и деления на целое число существенно легче и при этом достаточно часты. По соображениям эффективности они заслуживают отдельного рассмотрения. Пусть

$$f_{m x}(n)=(m f_{x}(n+p+1))\mathrm{~ndiv~}2^{p+1},$$
где p выбирается так, чтобы 2p ≥|m|. Доказать корректность этого определения легко:

$$\begin{array}{rcl}\left|f_{mx}(n)-2^{n}(mx)\right|&\leq&\frac{1}{2}+\left|\frac{mf_{x}(n+p+1)}{2^{p+1}}-2^{n}(mx)\right|\\ &=&\frac{1}{2}+\frac{|m|}{2^{p+1}}|f_{x}(n+p+1)-2^{n+p+1}x|\\ &<&\frac{1}{2}+\frac{|m|}{2^{p+1}}\\ &\leq&\frac{1}{2}+\frac{1}{2}\frac{|m|}{2^{p}}\\ &\leq&\frac{1}{2}+\frac{1}{2}=1.\end{array}$$
ствующего p. Не слишком изощрённое, но вполне подходящее определение может выглядеть так:

let
    log2 =
  let rec log2 x y =
    i f
       x </ Int 1 then y
    else
          log2
                (quo_num x ( Int
                                  2))
                                       (y + 1) in
  fun x −> log2
                  (x −/ Int
                              1)
                                 0 ; ;

С учётом сказанного выше, операция умножения на целое число принимает вид:

let
    real_intmul m x n =
   let p = log2
                  (abs_num m) in
   let p1 = p + 1 in
   (m ∗/ x(n + p1 ))
                       ndiv ( Int 2 ∗∗/ Int p1 ) ; ;

Деление на целое число вводится следующим образом:

$$f_{x/m}(n)=f_{x}(n){\mathrm{~ndiv~}}m$$

  Для упрощения доказательства корректности этого определения будем считать,
что случай m = 0 никогда не может возникнуть, а при m = ±1 результат опера-
ции не изменяет погрешности. В остальных случаях из |fx(n) −2nx| < 1 следует,
что |fx(n)/m −2nx/m| <
                        1

|m| ≤1

2 получаем требуемое. В итоге, программная реализация деления такова:

                                        2, откуда, в свою очередь, с учётом |fx(n) ndiv m −
fx(n)/m| ≤1

let
    real_intdiv m x n =
   x(n) ndiv ( Int m) ; ;

## 9.3.4 Умножение: Общий Случай

Определить умножение в общем случае труднее, поскольку погрешность аппроксимации одного из сомножителей умножается на порядок второго. Следовательно, нам потребуется предварительно оценить порядки сомножителей. Поступим следующим образом. Предположим, что нам требуется вычислить выражение x + y до n-го разряда. Для этого выберем r и s такие, что |r −s| ≤1 и r + s = n + 2. Таким образом, обе эти величины несколько больше, чем половина требуемой разрядности. Далее вычислим fx(r) и fy(s), после чего определим p и q - соответствующие «двоичные логарифмы», для которых справедливо |fx(r)| ≤2p and |fy(s)| ≤2q. Если как p, так и q равны нулю, то легко убедиться, что результатом вычислений также будет 0. В противном случае отметим, что либо *p >* 0, либо *q >* 0 - этот факт нам понадобится в дальнейшем.

Пусть

$$k=n+q-s+3=q+r+1$$ $$l=n+p-r+3=p+s+1$$ $$m=(k+l)-n=p+q+4.$$

Ilookaen, trto interpretissaupacenusa $f_{xy}(n)=(f_{x}(k)f_{y}(l))$ ndiv $2^{m}$ y.ubscriptopper $k$prreto aplicamathu, $\tau$. e. $|f_{xy}(n)-2^{n}(xy)|<1$. E.m necrn obfuscamente

$$2^{k}x=f_{x}(k)+\delta,$$ $$2^{l}y=f_{y}(l)+\epsilon,$$
где |δ| < 1 и |ϵ| < 1, то мы получим:

$$|f_{xy}(n)-2^{n}(xy)|\leq\frac{1}{2}+|\frac{f_{x}(k)f_{y}(l)}{2^{m}}-2^{n}(xy)|$$ $$=\frac{1}{2}+2^{-m}|f_{x}(k)f_{y}(l)-2^{k+l}xy|$$ $$=\frac{1}{2}+2^{-m}|f_{x}(k)f_{y}(l)-(f_{x}(k)+\delta)(f_{y}(l)+\epsilon)|$$ $$=\frac{1}{2}+2^{-m}|\delta f_{y}(l)+\epsilon f_{x}(k)+\delta\epsilon|$$ $$\begin{array}{l l}{{\leq}}&{{\frac{1}{2}+2^{-m}(|\delta f_{y}(l)|+|\epsilon f_{x}(k)|+|\delta\epsilon|)}}\\ {{}}&{{\leq}}&{{\frac{1}{2}+2^{-m}(|f_{y}(l)|+|f_{x}(k)|+|\delta\epsilon|)}}\\ {{}}&{{\ }}&{{\ }}\\ {{<}}&{{\frac{1}{2}+2^{-m}(|f_{y}(l)|+|f_{x}(k)|+1)}}\end{array}$$
Отсюда имеем |fx(r)| ≤2p, так что |2rx| < 2p +1. Следовательно, |2kx| < 2q+1(2p +1), откуда |fx(k)| < 2q+1(2p + 1) + 1, т. е. |fx(k)| ≤2q+1(2p + 1). Аналогично доказывается справедливость |fy(l)| ≤2p+1(2q + 1). Таким образом,

$$\begin{array}{l l l}{{|f_{y}(l)|+|f_{x}(k)|+1}}&{{\leq}}&{{2^{p+1}(2^{q}+1)+2^{q+1}(2^{p}+1)+1}}\\ {{}}&{{=}}&{{2^{p+q+1}+2^{p+1}+2^{p+q+1}+2^{q+1}+1}}\\ {{}}&{{=}}&{{2^{p+q+2}+2^{p+1}+2^{q+1}+1.}}\end{array}$$
Для получения требуемой максимальной погрешности введём ограничение |fy(l)| + |fx(k)| + 1 ≤2m−1, либо, разделив на 2 и учитывая дискретность множества целых чисел,
2p+q+1 + 2p + 2q < 2p+q+2.

В свою очередь, данное отношение может быть записано как (2p+q + 2p) + (2p+q +
2q) < 2p+q+1 + 2p+q+1. Его справедливость следует из упомянутого ранее факта, что либо *p >* 0, либо *q >* 0. Таким образом, мы обосновали следующее определение:

let
    real_mul x y n =
  let n2 = n + 2 in
  let
      r = n2 / 2 in
  let
      s = n2 −r in
  let
      xr = x( r )
  and ys = y( s ) in
  let p = log2
                 xr
  and q = log2
                 ys in
  i f p = 0 & q = 0 then Int 0 else
  let k = q + r + 1
  and l = p + s + 1
  and m = p + q + 4 in
  (x(k) ∗/ y( l ))
                   ndiv ( Int 2 ∗∗/ Int m) ; ;

## 9.3.5 Обратные Числа

Нашим следующим шагом будет реализация вычисления обратных чисел. Чтобы получить любую верхнюю оценку обратного числа, не говоря уж о хорошем его приближении, потребуется оценить аргумент *снизу*. В общем случае для этого не существует лучшего способа, чем вычисление аргумента с возрастающей точностью, пока мы не убедимся в том, что он отличен от нуля. Следующая лемма служит обоснованием этой процедуры.

Лемма 9.1 *Пусть* 2e ≥n + k + 1, |fx(k)| ≥2e и |fx(k) −2kx| < 1, где fx(k) - целое, а e, n и k - натуральные числа. Если мы определим fy(n) = 2n+k ndiv fx(k),

то получим |fy(n) −2nx−1| < 1, т. е. требуемую верхнюю оценку погрешности.
Доказательство: Доказательство этой леммы достаточно утомительно и бу-
дет приведено здесь не полностью, а лишь в виде основных соображений. Ес-
ли |fx(k)| > 2e, то результат очевидно следует из простых рассуждений. Округ-
ление в результате выполнения операции ndiv даёт погрешность, не превышаю-
щую 1

2, итоговая погрешность меньше 1

                                                   2. Если |fx(k)| = 2e, но при этом n + k ≥e,
то можно пренебречь тем, что второй компонент погрешности может быть
вдвое большим, т. е. меньшим 1 - в этом случае ошибка округления будет от-
сутствовать потому, что fx(k) = ±2e делится на 2n+k нацело. (Воспользуемся
фактом, что 2e −1 ≤2e−1, поскольку при 2e ≥n + k + 1 значение e не может
равняться нулю.) Наконец, при |fx(k)| = 2e и n + k < e, мы имеем |fy(n) −2n 1

                                                                                       x| < 1,
поскольку |fy(n)| ≤1 и 0 < |2n 1

x| < 1, а знаки этих величин совпадают. □

   Предположим, что нам требуется найти число, обратное x, с точностью n. Прежде
всего, вычислим fx(0). Нам потребуется рассмотреть два случая:

1. Если |fx(0)| > 2r для некоторого натурального числа r, то выберем наименьшее натуральное число k (которое может быть и равным нулю) такое,
что 2r + k ≥n + 1, и положим e = r + k. Результатом вычислений в этом
случае будет 2n+k ndiv fx(k). Легко убедиться, что условия, требуемые леммой,
выполняются. Поскольку |fx(0)| ≥2r+1, мы имеем |x| > 2r, так что |2kx| > 2r+k.
Это значит, что |fx(k)| > 2r+k −1, а отсюда (учитывая целочисленность fx(k))
получаем требуемое соотношение |fx(k)| ≥2r+k = 2e. Условие 2e ≥n = k + 1
легко проверить. Отметим, что из r ≥n непосредственно следует корректность
аппроксимации fy(n) = 0.

2. При |fx(0)| ≤1 воспользуемся функцией 'msd', возвращающей наименьшее p
  такое, что |fx(p)| > 1. Отметим, что при x = 0 произойдёт зацикливание. Поло-
  жив e = n+p+1 и k = e+p, определим результат операции как 2n+k ndiv fx(k). В
  этом случае также справедливы условия, требуемые леммой. Так как |fx(p)| ≥
  2, мы имеем |2px| > 1, т. е. |x| >
                                 1

                                            2p. Следовательно |2kx| > 2k−p = 2e, отку-
да |fx(k)| > 2e −1, т. е. |fx(k)| ≥2e.

Реализацию начнём с функции msd:

let msd =
  let rec msd n x =
    i f abs_num(x(n )) >/ Int 1 then n else msd (n + 1) x in
  msd 0 ; ;

let
    real_inv x n =
  let x0 = x (0)
                  in
  let k =
    i f
        x0 >/ Int 1 then
      let
           r = log2 x0 −1 in
      let k0 = n + 1 −2 ∗r in
       i f
          k0 < 0 then 0 else k0
    else
      let p = msd x in
      n + 2 ∗p + 1 in
  ( Int 2 ∗∗/ Int
                   (n + k ))
                              ndiv (x(k ) ) ; ;

В итоге определение операции деления становится тривиальным:

let
    real_div x y = real_mul x ( real_inv y ) ; ;

## 9.3.6 Отношения Порядка

Примечательным свойством отношений порядка является то, что их вычисление в общем случае алгоритмически неразрешимо. В основе такого вывода лежит невозможность установить в общем случае равенство данного числа нулю. Если последовательное вычисление с увеличением требуемой точности продолжает выдавать 0, это ещё не служит гарантией того, что в дальнейшем мы не получим ненулевой результат.6 Если значение x не равно нулю, поиск первого ненулевого разряда числа когда-либо завершится, но в случае x = 0 он будет длиться вечно.

Принимая во внимание сказанное выше, несложно реализовать отношения порядка. Для определения взаимного порядка чисел x и y достаточно найти n такое, что |xn −yn| ≥2. Например, для xn ≥yn + 2 мы имеем

$$2^{n}x>x_{n}-1\geq y_{n}+1>2^{n}y,$$
откуда делаем вывод, что *x > y*. Прежде всего, приведём общую процедуру вычисления n, после чего все отношения порядка могут быть выражены с её использованием.

Отметим, что единственным способом реализации рефлексивных отношений будет положить их тождественными соответствующим нерефлексивным отношениям!

let
    separate =
  let rec
           separate n x y =
    let d = x(n) −/ y(n) in
    i f abs_num(d) >/ Int 1 then d
    else
          separate
                    (n + 1) x y in
separate
          0 ; ;

let
    real_gt x y = separate x y >/ Int
                                            0 ; ;
let
    real_ge x y = real_gt x y ; ;
let
    real_lt x y = separate x y </ Int
                                            0 ; ;
let
    real_le x y = real_lt x y ; ;

## 9.3.7 Кэширование

Чтобы протестировать определённые нами функции, потребуется возможность вывода некоторого приближённого значения вещественного числа в десятеричной системе счисления. Возможности стандартной библиотеки CAML делают эту задачу несложной. Если нам требуется вывести d десятичных знаков числа, положим точность вычислений n такой, чтобы 2n > 10d, т. е. точность вычислений была бы не меньшей, чем количество выводимых цифр.

let
    view x d =
  let n = 4 ∗d in
  let
      out = x(n) // ( Int 2 ∗∗/ Int n) in
  approx_num_fix d out ; ;

Начнём с простых примеров, которые работают, как ожидается:

#let x = real_of_int 3;;
x : int -> num = <fun>
#let xi = real_inv x;;
xi : int -> num = <fun>
#let wun = real_mul x xi;;
wun : int -> num = <fun>
#view x 20;;
it : string = "3.00000000000000000000"
#view xi 20;;
it : string = ".33333333333333333333"
#view wun 20;;
it : string = "1.00000000000000000000"

  Однако, дальнейшее тестирование обнаруживает в нашей реализации серьёзную
трудноуловимую проблему, которая проявляется с ростом сложности задач. Эта про-
блема - многократное вычисление одних и тех же значений. Помимо очевидного
случая - явного наличия общих подвыражений, многократное вычисление одних и
тех же выражений с различной точностью требуется в алгоритмах умножения и, в
особенности, вычисления обратного числа. Количество обращений к одному и то-
му же подвыражению зависит от глубины его вложенности в исходное выражение и
может расти экспоненциально:

#let x1 = real_of_int 1 in
let x2 = real_mul x1 x1 in
let x3 = real_mul x2 x2 in
let x4 = real_mul x3 x3 in
let x5 = real_mul x4 x4 in
let x6 = real_mul x5 x5 in
let x7 = real_mul x6 x6 in
view x7 10;;
- : string = "+1.0000000000"

Вычисление этого примера может занять несколько секунд.
Для решения проблемы воспользуемся идеей *кэширования* или функций с памятью [42]. Каждой функции поставим в соответствие ссылку на ячейку памяти, в которой будем хранить её значение, вычисленное с наибольшей на данный момент точностью. При очередном обращении к функции с той же самой требуемой точностью это значение может быть возвращено немедленно, без каких-либо повторных вычислений. Кроме того, менее точная аппроксимация (например, порядка n) всегда может быть получена из более точной (n + k, где k ≥1). Если нам известно, что |fx(n + k) −2n+kx| < 1, из этого следует:

$$|f_{x}(n+k)\ {\rm ndiv}\ 2^{k}-2^{n}x|\leq\frac{1}{2}+|\frac{f_{x}(n+k)}{2^{k}}-2^{n}x|$$ $$=\frac{1}{2}+\frac{1}{2^{k}}|f_{x}(n+k)-2^{n+k}x|$$ $$<\frac{1}{2}+\frac{1}{2^{k}}$$ $$\leq1.$$
Таким образом, использование fx(n+k) ndiv 2k в качестве аппроксимации порядка n обосновано.

let real_of_int k = memo ( **fun** n −> ( Int 2 ∗∗/ Int n) ∗/ Int k ) ; ;
let real_neg f = memo (fun n −> minus_num( f n ) ) ; ;
let real_abs f = memo ( **fun** n −> abs_num ( f n ) ) ; ;

let
    real_add
               f g = memo ( fun n −>
   ( f (n + 2) +/ g (n + 2))
                              ndiv ( Int
                                          4 ) ) ; ;

let
    real_sub
               f g = real_add
                                f
                                  ( real_neg g ) ; ;

let
    real_intmul m x = memo ( fun n −>
   let p = log2
                  (abs_num m) in
   let p1 = p + 1 in
   (m ∗/ x(n + p1 ))
                       ndiv ( Int 2 ∗∗/ Int p1 ) ) ; ;

let
    real_intdiv m x = memo ( fun n −>
   x(n) ndiv ( Int m) ) ; ;

let
    real_mul x y = memo ( fun n −>
  let n2 = n + 2 in
  let
      r = n2 / 2 in
  let
      s = n2 −r in
  let
      xr = x( r )
  and ys = y( s ) in
  let p = log2
                 xr
  and q = log2
                 ys in
  i f p = 0 & q = 0 then Int 0 else
  let k = q + r + 1
  and l = p + s + 1
  and m = p + q + 4 in
  (x(k) ∗/ y( l ))
                   ndiv ( Int 2 ∗∗/ Int m) ) ; ;

let
    real_inv x = memo (fun n −>
  let x0 = x (0)
                  in
  let k =
    i f
        x0 >/ Int 1 then
      let
           r = log2 x0 −1 in
      let k0 = n + 1 −2 ∗r in
       i f
          k0 < 0 then 0 else k0
    else
      let p = msd x in
      n + 2 ∗p + 1 in
  ( Int 2 ∗∗/ Int
                   (n + k ))
                              ndiv (x(k ) ) ) ; ;

let
    real_div x y = real_mul x ( real_inv y ) ; ;

let memo f =
  let mem = r e f
                  (−1, Int
                           0) in
  fun n −> let
                 (m, res ) = !mem in
            i f n <= m then
               i f m = n then res
               else
                     res
                         ndiv ( Int 2 ∗∗/ Int (m −n ))
            else
               let
                   res = f n in
              mem := (n , res ) ;
                                 res ; ;

  Проведённая оптимизация делает вычисление упомянутого выше произведения
практически мгновенным. Рассмотрим ещё несколько примеров:

#let pi1 = real_div (real_of_int 22) (real_of_int 7);;
pi1 : int -> num = <fun>
#view pi1 10;;
it : string = "+3.1428571429"
#let pi2 = real_div (real_of_int 355) (real_of_int 113);;
pi2 : int -> num = <fun>
#view pi2 10;;
it : string = "+3.1415929204"
#let pidiff = real_sub pi1 pi2;;
pidiff : int -> num = <fun>
#view pidiff 20;;
it : string = "+0.00126422250316055626"
#let ipidiff = real_inv pidiff;;
ipidiff : int -> num = <fun>
#view ipidiff 20;;
it : string = "+791.00000000000000000000"

В заключение отметим, что все расчёты, приведённые в данном разделе, можно, безусловно, проделать и в рациональной арифметике. Но на деле может оказаться, что наш подход более эффективен в некоторых ситуациях, так как он избавляет от свойственного вычислениям в рациональных числах лавинообразного роста числителей и знаменателей, который абсолютно избыточен, когда нам нужно лишь приближённое значение результата. Однако, предложенный метод раскрывает в полной мере свои достоинства лишь тогда, когда нам потребуется ввести трансцендентные функции наподобие exp, sin и т. д. Этот вопрос здесь рассматриваться не будет ввиду ограничений на объём курса, но может оказаться интересным в качестве упражнения. Одним из подходов является применение частичных сумм соответствующих рядов Тейлора. Отметим, что конечные суммы могут быть вычислены напрямую вместо итеративного применения функции сложения - это существенно улучшает их точность.

## 9.4 Пролог И Доказательство Теорем

Язык Пролог популярен в исследованиях в области искусственного интеллекта и применяется в различных практических приложениях, таких как интеллектуальные базы данных и экспертные системы. В этом разделе рассматривается реализация средствами ML основного механизма Пролога - поиска в глубину по базе знаний с унификацией и возвратом. Мы не претендуем на полную реализацию Пролога, но изложенного будет достаточно, чтобы получить точное представление об основных достоинствах языка и запустить несколько примеров.

## 9.4.1 Термы Пролога

Данные и код в Прологе представляются с помощью единой системы термов первого порядка. Ранее мы определили тип термов для математических выражений и реализовали для них процедуры вывода и синтаксического анализа. Сейчас мы будем использовать нечто похожее, но с некоторыми модификациями. Во-первых, немного упростим код: будем рассматривать константы как нуль-арные функции, т.е. как функции, принимающие пустой список аргументов. Соответственно, определим:

**type term = Var of string**

| Fn of string * (term list );
Там, где раньше использовался Const s, теперь будет Fn(s,[]). Отметим, что функции различной арности (с разным числом аргументов) рассматриваются как различные, даже если у них одинаковое имя. Следовательно, можно не опасаться, что такое представление констант войдет в конфликт с представлением функций.

## 9.4.2 Лексический Анализ

Для более точного соблюдения соглашений Пролога, которые включают чувствительность к регистру, изменим должным образом функции лексического анализа. Не будем требовать точного совпадения во всём, но учтём самое главное: алфавитноцифровые идентификаторы, начинающиеся с буквы *в верхнем регистре* или знака подчёркивания, рассматриваются как переменные, а прочие алфавитно-цифровые идентификаторы и числа - как константы. Например, X и Answer - переменные, тогда как x и john - константы. Символьные идентификаторы также классифицируются как константы, причём последовательности символов объединяются в строки наибольшей возможной длины, так что символьные идентификаторы не обязаны состоять из единственного символа. Исключение составляют символы пунктуации: левая и правая скобки, запятая и точка с запятой, которые выделены в специальный лексический класс.

type token = Variable
                      of
                         s t r i n g
           |
             Constant of
                         s t r i n g
           |
             Punct of
                      s t r i n g ; ;

let
    lex =
  let
       s e v e r a l p = many ( some p) in
  let
       c o l l e c t (h , t ) = h^( i t l i s t
                                    ( p r e f i x
                                             ^) t "" ) in
  let
      upper_alpha s = "A" <= s & s <= "Z" or
                                                    s = "_"
  and lower_alpha s = "a" <= s & s <= "z" or "0" <= s & s <= "9"
  and punct s = s = " ( " or
                               s = " ) " or
                                            s = " [ " or
                                                         s = " ] "
                  or
                      s = " , " or
                                  s = " . "
  and space
             s = s = "␣" or
                               s = "\n" or
                                             s = "\ t " in
  let
      alphanumeric s = upper_alpha s
                                           or lower_alpha s in
  let
      symbolic
                 s = not space
                                 s & not alphanumeric s & not punct s in
  let
      rawvariable =
    some upper_alpha ++ s e v e r a l
                                     alphanumeric >> ( Variable o
                                                                     c o l l e c t )
  and rawconstant =
    ( some lower_alpha ++ s e v e r a l
                                      alphanumeric
                                                     | |
     some symbolic ++ s e v e r a l
                                  symbolic ) >> ( Constant o
                                                                c o l l e c t )
  and rawpunct = some punct >>
                                     Punct in
  let
      token =
    ( rawvariable
                   | |
                       rawconstant
                                     | |
                                        rawpunct ) ++
    s e v e r a l
             space >> f s t
                             in
  let
      tokens = ( s e v e r a l
                           space ++ many token ) >> snd in
  let
       a l l t o k e n s = ( tokens ++ f i n i s h e d ) >> f s t
                                                     in
  f s t
      o a l l t o k e n s o explode ; ;

Пример его использования:

#lex "add(X,Y,Z) :- X is Y+Z.";;
- : token list =
[Constant "add"; Punct "("; Variable "X"; Punct ",";
 Variable "Y"; Punct ","; Variable "Z"; Punct ")";
 Constant ":-"; Variable "X"; Constant "is"; Variable "Y";
 Constant "+"; Variable "Z"; Punct "."]

## 9.4.3 Синтаксический Анализ

Основной синтаксический анализатор остаётся в значительной степени таким же, каким был ранее, система печати не меняется. Единственная модификация - прологовские списки записываются в более удобной нотации. Конструкции Пролога «.»
и «nil» соответствуют «::» и «[]» в ML, и мы модифицируем анализатор с тем, чтобы он распознавал выражения вида «[1,2,3]». Мы также допустим принятую в Прологе запись сопоставления с образцом «[H|T]» вместо «cons(H,T)». Определив базовые функции

let
    variable =
  fun ( Variable
                  s : : r e s t ) −> s , r e s t
    | _ −> raise Noparse ; ;

let
    constant =
  fun ( Constant s : : r e s t ) −> s , r e s t
    | _ −> raise Noparse ; ;

мы получаем синтаксический анализатор для термов, а также правил Пролога, имеющих следующий вид:
term.

term
:-
term1*, . . . , term*n.

Реализация анализатора приводится ниже:

let rec atom input
      = ( constant ++ a ( Punct " ( " ) ++ t e r m l i s t ++ a ( Punct " ) " )
              >> (fun ( ( ( name ,_) , args ) ,_) −> Fn(name , args ))
       | |
          constant
              >> (fun s −> Fn( s , [ ] ) )
       | |
          variable
              >> (fun s −> Var s )
       | |
          a ( Punct " ( " ) ++ term ++ a ( Punct " ) " )
              >> ( snd o
                         f s t )
       | |
          a ( Punct " [ " ) ++ l i s t
              >> snd )
                       input
 and term input = precedence
                               ( ! i n f i x e s ) atom input
 and t e r m l i s t
               input
      = ( term ++ a ( Punct " , " ) ++ t e r m l i s t
              >> (fun (( h ,_) , t ) −> h : : t )
       | |
          term
              >> (fun h −> [ h ] ) )
                                  input
 and l i s t
           input
      = ( term ++ ( a ( Constant " | " ) ++ term ++ a ( Punct " ] " )
                        >> ( snd o
                                   f s t )
                | |
                   a ( Punct " , " ) ++ l i s t
                         >> snd
                | |
                   a ( Punct " ] " )
                        >> (K (Fn( " [ ] " , [ ] ) ) ) )
              >> (fun (h , t ) −> Fn( " . " , [ h ;
                                            t ] ) )
       | |
          a ( Punct " ] " )
              >> (K (Fn( " [ ] " , [ ] ) ) ) )
                                     input
 and rule
           input
     = ( term ++ ( a ( Punct " . " )
                        >> (K [ ] )
               | |
                  a ( Constant ":−" ) ++ term ++
                  many ( a ( Punct " , " ) ++ term >> snd ) ++
                  a ( Punct " . " )
                        >> (fun ( ( (_, h ) , t ) ,_) −> h : : t ) ) )
                                                           input ; ;

let
    parse_term = f s t
                        o ( term ++ f i n i s h e d >> f s t ) o lex ; ;

let
    parse_rules = f s t
                         o (many rule ++ f i n i s h e d >> f s t ) o lex ; ;

## 9.4.4 Унификация

Пролог использует для достижения текущей *цели* набор правил, пытаясь подобрать подходящее. Если найдётся правило, которое состоит из единственного терма и совпадает с целью, она считается достигнутой. В случае правила вида term :- term1*, . . . , term*n. , если цель совпадает с *term*, то для каждого терма termi требуется, в свою очередь, установить достижимость. Если это выполнено, исходная цель также достигнута.

Однако, цели и правила не обязаны в точности совпадать. В их состав могут входить переменные, значения которых *конкретизируются* Пролог-системой так, чтобы добиться нужного совпадения - этот процесс получил название *унификация*. Это значит, что в итоге процесс доказательства может ограничиться специальным случаем исходной цели, например, P(f(X)) вместо P(Y ). Например:
- Для унификации f(g(X), Y ) и f(g(a), X) конкретизируем X = a и Y = a, получив два одинаковых терма: f(g(a), a).

- Для унификации f(a, X, Y ) и f(*X, a, Z*) конкретизируем X = a и Y = Z, после
чего оба терма примут вид f(*a, a, Z*).
- Невозможно унифицировать f(X) и X.
В общем случае, унификация неоднозначна. Например, во втором примере можно выбрать конкретизацию Y = f(b) и Z = f(b). Однако, всегда предпочтительнее наиболее общая унификация, из которой остальные выводятся дальнейшей конкретизацией (сравните с наиболее общими типами в ML). Для того, чтобы её найти, требуется рекурсивно (и синхронно) обходить в глубину оба терма, связывая обнаруженные в одном терме переменные с соответствующими подтермами другого. При этом также требуется следить, чтобы уже связанные переменные не конкретизировались повторно другими термами, а также чтобы не возникало ситуаций, как в последнем примере, когда переменная сама входит в свой терм-конкретизацию. Рассмотрим простую реализацию этой идеи. Будем сохранять конкретизации переменных в ассоциативном списке insts, предварительно проверяя, что они ещё не были конкретизированы. Эта переменная выполняет роль аккумулятора:

let rec unify tm1 tm2 i n s t s =
 match tm1 with
    Var(x) −>
      ( try
           let tm1 ' = assoc x i n s t s
                                     in
           unify tm1 ' tm2 i n s t s
       with Not_found −>
           augment (x , tm2)
                            i n s t s )
  | Fn( f1 , args1 ) −>
      match tm2 with
        Var(y) −>
          ( try
               let tm2 ' = assoc y i n s t s
                                         in
               unify tm1 tm2 '
                               i n s t s
           with Not_found −>
               augment (y , tm1)
                                i n s t s )
      | Fn( f2 , args2 ) −>
          i f
             f1 = f2
          then
               i t l i s t 2
                        unify
                              args1
                                    args2
                                           i n s t s
          else
               raise
                      ( error " functions ␣do␣not␣match" ) ; ;

В ходе пополнения списка конкретизаций должна выполняться так называемая «проверка вхождения».7 А именно, мы должны запретить конкретизацию переменной X
нетривиальным термом, который сам включает X, подобно третьему примеру выше. Большинство реализаций Пролога игнорируют подобную проверку или по (заявленным) причинам эффективности, или для поддержки циклических структур данных вместо простых термов первого порядка.

let rec occurs_in x =
 fun (Var y) −> x = y
    |
      (Fn(_, args )) −> e x i s t s
                              ( occurs_in x)
                                             args ; ;

let rec subst
              i n s t s = fun
   (Var y) −> ( try
                   assoc y i n s t s with Not_found −> tm)
 |
   (Fn( f , args )) −> Fn( f ,map ( subst
                                    i n s t s )
                                            args ) ; ;

let raw_augment =
  let augment1 theta
                        (x , s ) =
    let s ' = subst
                      theta
                             s in
    i f
        occurs_in x s & not ( s = Var(x ))
    then raise
                 ( error "Occurs␣check" )
    else
          (x , s ' )
                  in
  fun p i n s t s −> p : : ( map ( augment1
                                        [ p ] )
                                              i n s t s ) ; ;

let augment (v , t )
                     i n s t s =
  let t ' = subst
                   i n s t s
                          t in match t ' with
    Var(w) −> i f w <= v then
                  i f w = v then i n s t s
                  else raw_augment (v , t ' )
                                              i n s t s
                else raw_augment (w, Var(v ))
                                                 i n s t s
  | _ −> i f
             occurs_in v t '
          then raise
                       ( error "Occurs␣check" )
          else raw_augment (v , t ' )
                                      i n s t s ; ;

## 9.4.5 Поиск С Возвратом

быть достигнуты при текущих конкретизациях, происходит *возврат*, после чего будет опробовано другое начальное правило. Следовательно, мы будем рассматривать цели не поочередно, а все сразу, чтобы реализовать требуемую стратегию:

let rec
        f i r s t
              f =
 fun
      [ ] −> raise
                  ( error "No␣r u l e s ␣applicable " )
    |
      (h : : t ) −> try
                     f h with error _ −> f i r s t
                                                f
                                                  t ; ;

let rec expand n r u l e s
                        i n s t s
                              goals =
  f i r s t
        (fun rule −>
    i f
       goals = [ ]
                  then i n s t s
                              else
    let conc , asms =
      rename_rule ( string_of_int n)
                                     rule
                                          in
    let
        insts ' = unify
                        conc (hd goals )
                                         i n s t s
                                               in
    let
        local , global = p a r t i t i o n
      (fun (v ,_) −> occurs_in v conc or
              e x i s t s
                      ( occurs_in v) asms )
                                           insts '
                                                  in
    let
        goals ' = (map ( subst
                              local ) asms ) @
                 ( t l
                      goals ) in
    expand (n + 1)
                    r u l e s
                          global
                                 goals ' )
                                          r u l e s ; ;

Для генерации новых имён переменных используется функция rename:

let rec rename s =
 fun (Var v) -> Var("~"^v^s)
   | (Fn(f,args)) -> Fn(f,map (rename s) args);;

let rename_rule s (conc,asms) =
 (rename s conc,map (rename s) asms);;

Наконец, соберём всё вместе, в одну функцию prolog, которая пытается достичь требуемой цели на основе заданных правил:
type outcome = No | Yes of (string * term) list;;

let prolog rules goal =
 try let insts = expand 0 rules [] [goal] in
     Yes(filter (fun (v,_) -> occurs_in v goal)
                insts)
 with error _ -> No;;

Результат функции - сообщение о том, что цель или не может быть достигнута, или может при некоторой конкретизации переменных. В последнем случае мы возвращаем только один ответ (один набор конкретизаций), но можно изменить код так, чтобы выводились все возможные решения.

## 9.4.6 Примеры

Протестируем полученный интерпретатор на примерах из какой-нибудь книги по Прологу. Например:

#let rules = parse_rules
 "male(albert).
  male(edward).
  female(alice).
  female(victoria).
  parents(edward,victoria,albert).
  parents(alice,victoria,albert).
  sister_of(X,Y) :-
    female(X),
    parents(X,M,F),
    parents(Y,M,F).";;
rules : (term * term list) list =
['male(albert)', []; 'male(edward)', [];
 'female(alice)', []; 'female(victoria)', [];
 'parents(edward,victoria,albert)', [];
 'parents(alice,victoria,albert)', [];
 'sister_of(X,Y)',
   ['female(X)'; 'parents(X,M,F)'; 'parents(Y,M,F)']]
#prolog rules ("sister_of(alice,edward)");;
- : outcome = Yes []
#prolog rules (parse_term "sister_of(alice,X)");;
- : outcome = Yes ["X", 'edward']
#prolog rules (parse_term "sister_of(X,Y)");;
- : outcome = Yes ["Y", 'edward'; "X", 'alice']

Введём набор правил, соответствующий некоторым элементарным действиям над списками, доступным в ML. Поскольку Пролог является скорее реляционным, чем функциональным языком, можно использовать запросы в более гибкой форме, например, чтобы выяснить, при каких аргументах можно получить заданный результат:

#let r = parse_rules
 "append([],L,L).
  append([H|T],L,[H|A]) :- append(T,L,A).";;
r : (term * term list) list =
['append([],L,L)', [];
 'append(H . T,L,H . A)', ['append(T,L,A)']]
#prolog r (parse_term "append([1,2],[3],[1,2,3])");;
- : outcome = Yes []
#prolog r (parse_term "append([1,2],[3,4],X)");;
- : outcome = Yes ["X", '1 . (2 . (3 . (4 . [])))']
#prolog r (parse_term "append([3,4],X,X)");;
- : outcome = No
#prolog r (parse_term "append([1,2],X,Y)");;
- : outcome = Yes ["Y", '1 . (2 . X)']

ным. Но за этоим фасадом скрывается простая стратегия поиска, которую достаточно просто сбить с толку. Например, следующий запрос зацикливается:

## 9.4.7 Доказательство Теорем

Пролог действует как простая система доказательства теорем, использующая базу логических фактов (правил) для доказательства цели. Однако, он весьма ограничен в своих возможностях, отчасти из-за неполноты стратегии поиска в глубину, частично же потому, что он может выполнять только логический вывод определённого вида. Вообще, можно реализовать более мощную пролог-подобную систему наподобие описанной в работе [58]. Далее мы покажем, как в сущности на тех же идеях
(унификация и возврат) строится более функциональная система доказательства.8
Унификация является эффективным способом ограничения переменных, связанных квантором всеобщности. Например, имея правила ∀*X. p*(X) ⇒q(X) и p(f(a)), можно унифицировать оба выражения, включающие p, и тем самым конкретизировать X значением f(a). Напротив, самые ранние системы доказательства теорем пытались строить всевозможные термы из доступных констант и функций («Эрбрановского базиса»).

Обычно поиск в глубину может привести к бесконечному зацикливанию, так что мы должны незначительно изменить его стратегию. Будем использовать последовательное углубление. Это значит, что для поиска в глубину задаётся фиксировнный предел, при достижении которого выполняется возврат. Если доказательство не найдено при заданной глубине, её значение увеличивается, и делается ещё одна попытка. Таким образом, сначала ищутся доказательства глубины 1, в случае неудачи - глубины 2, 3 и так далее. В качестве предельной глубины могут использоваться различные параметры, например, высота или размер дерева поиска; мы будем использовать число унифицируемых переменных.

## Манипулирование Формулами

Для определения формул будем использовать термы первого порядка, добавив к ним новые константы для логических операций, многие из которых будут инфиксными.

| Оператор    | Значение                                         |
|-------------|--------------------------------------------------|
| ~           |                                                  |
| (p)         | не p                                             |
| p           |                                                  |
| &           |                                                  |
| q           | p и q                                            |
| p           |                                                  |
| |           |                                                  |
| q           | p или q                                          |
| p           |                                                  |
| -->         |                                                  |
| q           | p влечёт q (импликация)                          |
| p           |                                                  |
| <->         |                                                  |
| q           | p только и если только q (эквивалентность)       |
| forall(X,p) | для всех X, p (квантор всеобщности)              |
| exists(X,p) | существует X такой что p (квантор существования) |

Альтернативный подход заключается в добавлении отдельного типа, представляющего формулы, но тогда потребуется реализовать также и синтаксический разбор, и печать. Из соображений простоты ограничимся первым решением.

Предварительная обработка формул Очевидно, программа упростится, если основная часть системы вывода не будет работать с импликацией и эквивалентностью. Следовательно, сначала определим
8Будем также использовать термин «система (логического) вывода».— Прим. перев.

функцию, заменяющую их композицией других операций:

let rec proc tm =
match tm with
Fn( "~" , [ t ] ) −> Fn( "~" , [ proc
t ] )
| Fn( "&" , [ t1 ;
t2 ] ) −> Fn( "&" , [ proc
t1 ;
proc
t2 ] )
| Fn( " | " , [ t1 ;
t2 ] ) −> Fn( " | " , [ proc
t1 ;
proc
t2 ] )
| Fn( "−
−
>" , [ t1 ;
t2 ] ) −>
proc
(Fn( " | " , [ Fn( "~" , [ t1 ] ) ;
t2 ] ) )
| Fn( "<
−
>" , [ t1 ;
t2 ] ) −>
proc
(Fn( "&" , [ Fn( "−
−
>" , [ t1 ;
t2 ] ) ;
Fn( "−
−
>" , [ t2 ;
t1 ] ) ] ) )
| Fn( " f o r a l l " , [ x ;
t ] ) −> Fn( " f o r a l l " , [ x ;
proc
t ] )
| Fn( " e x i s t s " , [ x ;
t ] ) −> Fn( " e x i s t s " , [ x ;
proc
t ] )
|
t −> t ; ;

их отрицаний, связанных с помощью операций «И», «ИЛИ» и кванторов.

let rec nnf_p tm =
 match tm with
   Fn( "~" , [ t ] ) −> nnf_n t
  | Fn( "&" , [ t1 ;
                t2 ] ) −> Fn( "&" , [ nnf_p t1 ; nnf_p t2 ] )
  | Fn( " | " , [ t1 ;
                t2 ] ) −> Fn( " | " , [ nnf_p t1 ; nnf_p t2 ] )
  | Fn( " f o r a l l " , [ x ;
                    t ] ) −> Fn( " f o r a l l " , [ x ; nnf_p t ] )
  | Fn( " e x i s t s " , [ x ;
                    t ] ) −> Fn( " e x i s t s " , [ x ; nnf_p t ] )
  |
    t −> t

and nnf_n tm =
match tm with
Fn( "~" , [ t ] ) −> nnf_p t
| Fn( "&" , [ t1 ;
t2 ] ) −> Fn( " | " , [ nnf_n t1 ; nnf_n t2 ] )
| Fn( " | " , [ t1 ;
t2 ] ) −> Fn( "&" , [ nnf_n t1 ; nnf_n t2 ] )
| Fn( " f o r a l l " , [ x ;
t ] ) −> Fn( " e x i s t s " , [ x ; nnf_n t ] )
| Fn( " e x i s t s " , [ x ;
t ] ) −> Fn( " f o r a l l " , [ x ; nnf_n t ] )
|
t −> Fn( "~" , [ t ] ) ; ;

## Система Вывода

На каждом этапе системе вывода доступны текущая формула, список формул, которые ещё предстоит рассмотреть, и список литералов. Система вывода пытается получить на их основе противоречие, следуя такой стратегии:

- Если текущая формула - p & q, то p и q рассматриваются по отдельности, т.е p
делается текущей формулой, а q добавляется к формулам «на рассмотрение».
- Если текущая формула имеет вид p | q, то делается попытка получить противоречие сначала с p, а затем с q.
- Если текущая формула - *forall(X, p)*, для замещения X вводится новая переменная, правильное значение может быть получено позже, при унификации.
- Если текущая формула - *exists(X,p)*, для замещения X вводится новая константа.
- В противном случае, формула должна быть литералом, так что делается попытка унифицировать его с противоречивым литералом.
- Если унификация не удалась, литерал добавляется в список литералов, а система вывода переходит к обработке следующей формулы.
всех оставшихся целей. Можно было бы снова использовать списки, но вместо них мы попробуем воспользоваться продолжениями(*continuations*). Продолжение - это функция, которая передаётся другой функции в качестве параметра, и которая может вызываться из последней «для выполнения дальнейших вычислений». В нашем случае она принимает список конкретизаций и пытается достичь оставшихся целей в данном контексте. То есть, вместо попыток явно сделать эти действия, мы просто

let rec prove fm unexp pl
                           nl n cont
                                     i =
  i f n < 0 then raise
                       ( error "No␣proof " )
                                           else
 match fm with
   Fn( "&" , [ p ; q ] ) −>
        prove p (q : : unexp )
                            pl
                               nl n cont
                                          i
  | Fn( " | " , [ p ; q ] ) −>
        prove p unexp pl
                          nl n
        ( prove q unexp pl
                           nl n cont )
                                      i
  | Fn( " f o r a l l " , [ Var x ; p ] ) −>
        let v = mkvar ()
                         in
        prove ( subst
                      [ x , Var v ] p)
                                   (unexp@ [ fm ] )
                                                 pl
                                                    nl
                                                       (n −1)
                                                                cont
                                                                     i
  | Fn( " e x i s t s " , [ Var x ; p ] ) −>
        let v = mkvar ()
                         in
        prove ( subst
                      [ x , Fn(v , [ ] ) ]
                                   p) unexp pl
                                                nl
                                                   (n −1)
                                                           cont
                                                                 i
  | Fn( "~" , [ t ] ) −>
        ( try
             f i r s t
                   (fun t ' −> let
                                   i ' = unify
                                               t t '
                                                    i
                                                      in
                               cont
                                    i ' )
                                        pl
         with error _ −>
            prove (hd unexp )
                              ( t l
                                  unexp )
                                          pl
                                             ( t : : nl ) n cont
                                                            i )
  |
    t −>
        ( try
             f i r s t
                   (fun t ' −> let
                                   i ' = unify
                                               t t '
                                                    i
                                                      in
                               cont
                                    i ' )
                                        nl
         with error _ −>
            prove (hd unexp )
                              ( t l
                                  unexp )
                                         ( t : : pl )
                                                  nl n cont
                                                            i ) ; ;

Приведём, наконец, главную функцию нашей системы доказательства:

let
    prover =
  let rec prove_iter n t =
    try
         let
              i n s t s = prove t
                                [ ]
                                    [ ]
                                       [ ]
                                          n I
                                               [ ]
                                                   in
         let
              g l o b i n s t s = f i l t e r
           (fun (v ,_) −> occurs_in v t )
                                             i n s t s
                                                    in
         n , g l o b i n s t s
    with error _ −> prove_iter
                                    (n + 1)
                                             t in
  fun t −> prove_iter 0 (nnf_n( proc ( parse_term t ) ) ) ; ;

## Примеры

Вот несколько простых примеров, взятых у Пеллетье [49]:
